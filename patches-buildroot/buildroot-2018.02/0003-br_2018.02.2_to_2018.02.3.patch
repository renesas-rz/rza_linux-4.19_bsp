diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 027c1c6053..59ce6ae59e 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -4,7 +4,7 @@
 # It needs to be regenerated every time a defconfig is added, using
 # "make .gitlab-ci.yml".
 
-image: buildroot/base:20180205.0730
+image: buildroot/base:20180318.1724
 
 .defconfig_script: &defconfig_script
     - echo 'Configure Buildroot'
@@ -110,14 +110,11 @@ engicam_imx6qdl_icore_rqs_defconfig: *defconfig
 engicam_imx6ul_geam_defconfig: *defconfig
 engicam_imx6ul_isiot_defconfig: *defconfig
 freescale_imx28evk_defconfig: *defconfig
-freescale_imx31_3stack_defconfig: *defconfig
 freescale_imx6dlsabreauto_defconfig: *defconfig
 freescale_imx6dlsabresd_defconfig: *defconfig
 freescale_imx6qsabreauto_defconfig: *defconfig
 freescale_imx6qsabresd_defconfig: *defconfig
-freescale_imx6sololiteevk_defconfig: *defconfig
 freescale_imx6sxsabresd_defconfig: *defconfig
-freescale_imx6ulevk_defconfig: *defconfig
 freescale_imx7dsabresd_defconfig: *defconfig
 friendlyarm_nanopi_a64_defconfig: *defconfig
 friendlyarm_nanopi_neo2_defconfig: *defconfig
diff --git a/.gitlab-ci.yml.in b/.gitlab-ci.yml.in
index cb3eb715f2..c0e9563f2f 100644
--- a/.gitlab-ci.yml.in
+++ b/.gitlab-ci.yml.in
@@ -4,7 +4,7 @@
 # It needs to be regenerated every time a defconfig is added, using
 # "make .gitlab-ci.yml".
 
-image: buildroot/base:20180205.0730
+image: buildroot/base:20180318.1724
 
 .defconfig_script: &defconfig_script
     - echo 'Configure Buildroot'
diff --git a/CHANGES b/CHANGES
index c11118efd3..f98790154f 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,57 @@
+2018.02.3, Released June 18th, 2018
+
+	Important / security related fixes.
+
+	Various fixes for building on modern distributions (GCC 8.x,
+	no rpcgen utility).
+
+	ARM: Default to binutils 2.28 and warn about newer binutils
+	versions, which are known to cause boot failures for Linux
+	kernels built in thumb mode.
+
+	Busybox/mdev: Fix module autoloading.
+
+	Busybox/sysvinit: inittab: Add /dev/{stdin,stdout,stderr}
+	symlinks, call swapon -a to activate any configured swap
+	devices.
+
+	Dependencies: Check that PATH does not contain current working
+	directory, which triggers a number of build failures.
+
+	Infrastructure: Error out for packages erroneously using the
+	'local' site method but not defining a _SITE.
+
+	Linux: Fix cuImage.<dtb> / simpleImage.<dtb> handling.  Ensure
+	kconfig uses ncurses from the host to fix a ncurses/ncursesw
+	mixup, causing menuconfig display corruption.
+
+	Toolchain: Workarounds for fix-rpath issues with binutils and
+	elf2flt.
+
+	Util-linux: Fix blocking on getrandom() issue with recent
+	kernels.
+
+	Remove broken freescale_imx31_3stack,
+	freescale_imx6sololiteevk and freescale_imx6ulevk defconfigs.
+
+	Updated/fixed packages: apr-util, asterisk, attr, audit,
+	autofs, binutils, busybox, cifs-utils, cups-filters, dash,
+	ebtables, exim, expect, f2fs-tools, faketime, file, gdb, git,
+	glibc, gnupg, gnupg2, gst1-plugins-bad, imagemagick, jamvm,
+	jpeg-turbo, libcap, libcoap, libcurl, libgcrypt, libjpeg,
+	libnss, libressl, libtirpc, libvncserver, libvorbis, libxslt,
+	log4cplus, lrzsz, ltrace, lynx, mariadb, mbedtls, mpg123,
+	nasm, netplug, network-manager, nfs-utils, nodejs,
+	openvmtools, patch, perl, php-amqp, poppler, procps-ng,
+	python, python-websockets, quota, redis, samba4, sysvinit,
+	transmission, triggerhappy, util-linux, wavpack, wget,
+	wireshark, xen, zmqpp
+
+	Issues resolved (http://bugs.uclibc.org):
+
+	#10986: Installing package attr when already supplied by busybox..
+	#11031: ld-elf2flt: host/bin/ld.real': execvp: No such file or..
+
 2018.02.2, Released May 4th, 2018
 
 	Important / security related fixes.
diff --git a/Config.in.legacy b/Config.in.legacy
index 60f9148234..40f39e3a0b 100644
--- a/Config.in.legacy
+++ b/Config.in.legacy
@@ -145,6 +145,17 @@ endif
 ###############################################################################
 comment "Legacy options removed in 2018.02"
 
+config BR2_PACKAGE_TRANSMISSION_REMOTE
+	bool "transmission remote tool option removed"
+	select BR2_LEGACY
+	select BR2_PACKAGE_TRANSMISSION_DAEMON
+	help
+	  Upstream does not provide a separate configure option for
+	  the tool transmission-remote, it is built when the
+	  transmission daemon has been enabled. Therefore, Buildroot
+	  has automatically enabled BR2_PACKAGE_TRANSMISSION_DAEMON
+	  for you.
+
 config BR2_KERNEL_HEADERS_3_4
 	bool "kernel headers version 3.4.x are no longer supported"
 	select BR2_KERNEL_HEADERS_4_1
diff --git a/DEVELOPERS b/DEVELOPERS
index 4b6c6274f8..909b4cedfe 100644
--- a/DEVELOPERS
+++ b/DEVELOPERS
@@ -1959,7 +1959,7 @@ F:	package/x11r7/xapp_xinput-calibrator/
 F:	package/zlog/
 F:	utils/scanpypi
 
-N:	Zoltan Gyarmati <mr.zoltan.gyarmati@gmail.com>
+N:	Zoltan Gyarmati <zgyarmati@zgyarmati.de>
 F:	package/crudini/
 F:	package/grantlee/
 F:	package/proj/
diff --git a/Makefile b/Makefile
index 864a15ba0a..c725f329d4 100644
--- a/Makefile
+++ b/Makefile
@@ -87,9 +87,9 @@ all:
 .PHONY: all
 
 # Set and export the version string
-export BR2_VERSION := 2018.02.2
+export BR2_VERSION := 2018.02.3
 # Actual time the release is cut (for reproducible builds)
-BR2_VERSION_EPOCH = 1525450000
+BR2_VERSION_EPOCH = 1529344000
 
 # Save running make version since it's clobbered by the make package
 RUNNING_MAKE_VERSION := $(MAKE_VERSION)
diff --git a/board/freescale/imx31_3stack/linux.fragment b/board/freescale/imx31_3stack/linux.fragment
deleted file mode 100644
index beb6b46f2e..0000000000
--- a/board/freescale/imx31_3stack/linux.fragment
+++ /dev/null
@@ -1 +0,0 @@
-# CONFIG_FB_MXS is not set
diff --git a/board/freescale/imx31_3stack/readme.txt b/board/freescale/imx31_3stack/readme.txt
deleted file mode 100644
index 4f8f393b12..0000000000
--- a/board/freescale/imx31_3stack/readme.txt
+++ /dev/null
@@ -1,92 +0,0 @@
-**************************************
-Freescale i.MX31 PDK development board
-**************************************
-
-This file documents the Buildroot support for the Freescale i.MX31 PDK in "3
-stack" configuration.
-
-The i.MX31 Product Development Kit (or PDK) is Freescale development board [1]
-based on the i.MX31 application processor [2].
-
-For more details on the i.MX31 PDK board, refer to the User's Guide [3].
-
-Build
-=====
-
-First, configure Buildroot for your i.MX31 PDK board:
-
-  make freescale_imx31_3stack_defconfig
-
-Build all components:
-
-  make
-
-You will find in ./output/images/ the following files:
-  - rootfs.cpio
-  - rootfs.cpio.gz
-  - rootfs.tar
-  - zImage
-
-The generated zImage does include the rootfs.
-
-Boot the PDK board
-==================
-
-The i.MX31 PDK contains a RedBoot bootloader in flash, which can be used to
-boot the newly created Buildroot images from the network.
-
-This necessitates to setup a TFTP server first. This setup is explained for
-example in Freescale i.MX31 PDK 1.5 Linux User's Guide [4].
-
-Here is a sample RedBoot configuration, for proper network boot of Buildroot on
-the i.MX31 PDK:
-
-    RedBoot> fconfig -l
-    Run script at boot: true
-    Boot script:
-    .. load -r -b 0x100000 zImage
-    .. exec -c "console=ttymxc0,115200"
-
-    Boot script timeout (1000ms resolution): 2
-    Use BOOTP for network configuration: false
-    Gateway IP address: <your gateway IP address>
-    Local IP address: <your PDK IP address>
-    Local IP address mask: 255.255.255.0
-    Default server IP address: <your TFTP server IP address>
-    Board specifics: 0
-    Console baud rate: 115200
-    Set eth0 network hardware address [MAC]: false
-    GDB connection port: 9000
-    Force console for special debug messages: false
-    Network debug at boot time: false
-
-Adapt those settings to your network configuration by replacing the appropriate
-network addresses where necessary.
-
-You might want to verify that your i.MX31 PDK switches settings are the correct
-ones for UART, power, boot mode, etc. Here is a reference switches
-configuration:
-
-    SW4
-    1   2   3   4   5   6   7  8
-    ON off off off off off off ON
-
-    SW5 SW6 SW7 SW8 SW9 SW10
-     0   1   0   0   0    0
-
-See the i.MX31 PDK Linux Quick Start Guide [5] for more details on the switches
-settings.
-
-Connect a serial terminal set to 115200n8 and power on the i.MX31 PDK board.
-Buildroot will present a login prompt on the serial port.
-
-Enjoy!
-
-References
-==========
-
-[1] http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=i.MX31PDK
-[2] http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=i.MX31
-[3] http://cache.freescale.com/files/32bit/doc/user_guide/pdk15_imx31_Hardware_UG.pdf
-[4] http://cache.freescale.com/files/32bit/doc/support_info/IMX31_PDK15_LINUXDOCS_BUNDLE.zip, pdk15_imx31__Linux_UG.pdf
-[5] http://www.freescale.com/files/32bit/doc/quick_ref_guide/PDK14LINUXQUICKSTART.pdf
diff --git a/board/synopsys/axs10x/fs-overlay/etc/inittab b/board/synopsys/axs10x/fs-overlay/etc/inittab
index 43bacc6580..7412a27366 100644
--- a/board/synopsys/axs10x/fs-overlay/etc/inittab
+++ b/board/synopsys/axs10x/fs-overlay/etc/inittab
@@ -14,12 +14,16 @@
 # process   == program to run
 
 # Startup the system
-null::sysinit:/bin/mount -t proc proc /proc
-null::sysinit:/bin/mount -o remount,rw /
-null::sysinit:/bin/mkdir -p /dev/pts
-null::sysinit:/bin/mkdir -p /dev/shm
-null::sysinit:/bin/mount -a
-null::sysinit:/bin/hostname -F /etc/hostname
+::sysinit:/bin/mount -t proc proc /proc
+::sysinit:/bin/mount -o remount,rw /
+::sysinit:/bin/mkdir -p /dev/pts /dev/shm
+::sysinit:/bin/mount -a
+::sysinit:/sbin/swapon -a
+null::sysinit:/bin/ln -sf /proc/self/fd /dev/fd
+null::sysinit:/bin/ln -sf /proc/self/fd/0 /dev/stdin
+null::sysinit:/bin/ln -sf /proc/self/fd/1 /dev/stdout
+null::sysinit:/bin/ln -sf /proc/self/fd/2 /dev/stderr
+::sysinit:/bin/hostname -F /etc/hostname
 # now run any rc scripts
 ::sysinit:/etc/init.d/rcS
 
diff --git a/configs/freescale_imx31_3stack_defconfig b/configs/freescale_imx31_3stack_defconfig
deleted file mode 100644
index 025f93f6a6..0000000000
--- a/configs/freescale_imx31_3stack_defconfig
+++ /dev/null
@@ -1,20 +0,0 @@
-# architecture
-BR2_arm=y
-BR2_arm1136jf_s=y
-BR2_ARM_EABIHF=y
-
-# Linux headers same as kernel, a 4.9 series
-BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_4_9=y
-
-# system
-BR2_TARGET_GENERIC_GETTY_PORT="ttymxc0"
-
-# kernel
-BR2_LINUX_KERNEL=y
-BR2_LINUX_KERNEL_CUSTOM_GIT=y
-BR2_LINUX_KERNEL_CUSTOM_REPO_URL="https://source.codeaurora.org/external/imx/linux-imx.git"
-BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION="rel_imx_4.9.x_1.0.0_ga"
-BR2_LINUX_KERNEL_DEFCONFIG="imx_v6_v7"
-BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES="board/freescale/imx31_3stack/linux.fragment"
-BR2_TARGET_ROOTFS_CPIO_GZIP=y
-BR2_TARGET_ROOTFS_INITRAMFS=y
diff --git a/configs/freescale_imx6sololiteevk_defconfig b/configs/freescale_imx6sololiteevk_defconfig
deleted file mode 100644
index b840f2f185..0000000000
--- a/configs/freescale_imx6sololiteevk_defconfig
+++ /dev/null
@@ -1,39 +0,0 @@
-# architecture
-BR2_arm=y
-BR2_cortex_a9=y
-BR2_ARM_ENABLE_NEON=y
-BR2_ARM_ENABLE_VFP=y
-BR2_ARM_FPU_VFPV3=y
-
-# Linux headers same as kernel, a 4.9 series
-BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_4_9=y
-
-# system
-BR2_TARGET_GENERIC_GETTY_PORT="ttymxc0"
-
-# kernel
-BR2_LINUX_KERNEL=y
-BR2_LINUX_KERNEL_CUSTOM_GIT=y
-BR2_LINUX_KERNEL_CUSTOM_REPO_URL="https://source.codeaurora.org/external/imx/linux-imx.git"
-BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION="rel_imx_4.9.x_1.0.0_ga"
-BR2_LINUX_KERNEL_DEFCONFIG="imx_v7"
-BR2_LINUX_KERNEL_DTS_SUPPORT=y
-BR2_LINUX_KERNEL_INTREE_DTS_NAME="imx6sl-evk"
-
-# filesystem
-BR2_ROOTFS_POST_IMAGE_SCRIPT="board/freescale/common/imx/post-image.sh"
-BR2_TARGET_ROOTFS_EXT2=y
-
-# required tools to create the microSD image
-BR2_PACKAGE_HOST_DOSFSTOOLS=y
-BR2_PACKAGE_HOST_GENIMAGE=y
-BR2_PACKAGE_HOST_MTOOLS=y
-
-# bootloader
-BR2_TARGET_UBOOT=y
-BR2_TARGET_UBOOT_BOARDNAME="mx6slevk"
-BR2_TARGET_UBOOT_FORMAT_IMX=y
-BR2_TARGET_UBOOT_CUSTOM_GIT=y
-BR2_TARGET_UBOOT_CUSTOM_REPO_URL="https://source.codeaurora.org/external/imx/uboot-imx.git"
-BR2_TARGET_UBOOT_CUSTOM_REPO_VERSION="rel_imx_4.9.x_1.0.0_ga"
-BR2_TARGET_UBOOT_NEEDS_DTC=y
diff --git a/configs/freescale_imx6ulevk_defconfig b/configs/freescale_imx6ulevk_defconfig
deleted file mode 100644
index 76ad101053..0000000000
--- a/configs/freescale_imx6ulevk_defconfig
+++ /dev/null
@@ -1,36 +0,0 @@
-# architecture
-BR2_arm=y
-BR2_cortex_a7=y
-
-# Linux headers same as kernel, a 4.9 series
-BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_4_9=y
-
-# system
-BR2_TARGET_GENERIC_GETTY_PORT="ttymxc0"
-
-# kernel
-BR2_LINUX_KERNEL=y
-BR2_LINUX_KERNEL_CUSTOM_GIT=y
-BR2_LINUX_KERNEL_CUSTOM_REPO_URL="https://source.codeaurora.org/external/imx/linux-imx.git"
-BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION="rel_imx_4.9.x_1.0.0_ga"
-BR2_LINUX_KERNEL_DEFCONFIG="imx_v7"
-BR2_LINUX_KERNEL_DTS_SUPPORT=y
-BR2_LINUX_KERNEL_INTREE_DTS_NAME="imx6ul-14x14-evk"
-
-# bootloader
-BR2_TARGET_UBOOT=y
-BR2_TARGET_UBOOT_BOARDNAME="mx6ul_14x14_evk"
-BR2_TARGET_UBOOT_CUSTOM_GIT=y
-BR2_TARGET_UBOOT_CUSTOM_REPO_URL="https://source.codeaurora.org/external/imx/uboot-imx.git"
-BR2_TARGET_UBOOT_CUSTOM_REPO_VERSION="rel_imx_4.9.x_1.0.0_ga"
-BR2_TARGET_UBOOT_FORMAT_IMX=y
-
-# required tools to create the microSD image
-BR2_PACKAGE_HOST_DOSFSTOOLS=y
-BR2_PACKAGE_HOST_GENIMAGE=y
-BR2_PACKAGE_HOST_MTOOLS=y
-
-# filesystem / image
-BR2_ROOTFS_POST_IMAGE_SCRIPT="board/freescale/common/imx/post-image.sh"
-BR2_TARGET_ROOTFS_EXT2=y
-BR2_TARGET_ROOTFS_EXT2_4=y
diff --git a/docs/manual/adding-packages-generic.txt b/docs/manual/adding-packages-generic.txt
index 521d6d50c7..ff8de69d0f 100644
--- a/docs/manual/adding-packages-generic.txt
+++ b/docs/manual/adding-packages-generic.txt
@@ -197,12 +197,12 @@ information is (assuming the package name is +libfoo+) :
 * +LIBFOO_VERSION+, mandatory, must contain the version of the
   package. Note that if +HOST_LIBFOO_VERSION+ doesn't exist, it is
   assumed to be the same as +LIBFOO_VERSION+. It can also be a
-  revision number, branch or tag for packages that are fetched
-  directly from their revision control system. +
-  Examples: +
-    +LIBFOO_VERSION = 0.1.2+ +
-    +LIBFOO_VERSION = cb9d6aa9429e838f0e54faa3d455bcbab5eef057+ +
-    +LIBFOO_VERSION = stable+
+  revision number or a tag for packages that are fetched directly
+  from their version control system. Do not use a branch name as
+  version; it does not work. Examples:
+  ** a version for a release tarball: +LIBFOO_VERSION = 0.1.2+
+  ** a sha1 for a git tree: +LIBFOO_VERSION = cb9d6aa9429e838f0e54faa3d455bcbab5eef057+
+  ** a tag for a git tree +LIBFOO_VERSION = v0.1.2+
 
 * +LIBFOO_SOURCE+ may contain the name of the tarball of the package,
   which Buildroot will use to download the tarball from
diff --git a/docs/manual/adding-packages-perl.txt b/docs/manual/adding-packages-perl.txt
index 08ef559209..eb14d9de18 100644
--- a/docs/manual/adding-packages-perl.txt
+++ b/docs/manual/adding-packages-perl.txt
@@ -46,7 +46,7 @@ built.
 
 Most of these data can be retrieved from https://metacpan.org/.
 So, this file and the Config.in can be generated by running
-the script +supports/scripts/scancpan Foo-Bar+ in the Buildroot directory
+the script +utils/scancpan Foo-Bar+ in the Buildroot directory
 (or in a br2-external tree).
 This script creates a Config.in file and foo-bar.mk file for the
 requested package, and also recursively for all dependencies specified by
diff --git a/docs/manual/manual.txt b/docs/manual/manual.txt
index afb53d0482..9d5076047f 100644
--- a/docs/manual/manual.txt
+++ b/docs/manual/manual.txt
@@ -9,8 +9,8 @@ Buildroot {sys:echo $\{BR2_VERSION%%-git*\}} manual generated on {localdate}
 
 The Buildroot manual is written by the Buildroot developers.
 It is licensed under the GNU General Public License, version 2. Refer to the
-http://git.buildroot.org/buildroot/tree/COPYING[COPYING] file in the Buildroot
-sources for the full text of this license.
+http://git.buildroot.org/buildroot/tree/COPYING?id={sys:git rev-parse HEAD}[COPYING]
+file in the Buildroot sources for the full text of this license.
 
 Copyright (C) 2004-2018 The Buildroot developers
 
diff --git a/linux/Config.in b/linux/Config.in
index 142d42e10c..6f5c0ea694 100644
--- a/linux/Config.in
+++ b/linux/Config.in
@@ -8,6 +8,10 @@ config BR2_LINUX_KERNEL
 
 if BR2_LINUX_KERNEL
 
+comment "Linux kernel in thumb mode may be broken with binutils >= 2.29"
+	depends on BR2_arm || BR2_armeb
+	depends on !BR2_BINUTILS_VERSION_2_28_X
+
 # Packages that need to have a kernel with support for loadable modules,
 # but do not use the kernel-modules infrastructure, should select that
 # option.
@@ -29,7 +33,7 @@ config BR2_LINUX_KERNEL_LATEST_VERSION
 	bool "Latest version (4.15)"
 
 config BR2_LINUX_KERNEL_LATEST_CIP_VERSION
-	bool "Latest CIP SLTS version (v4.4.112-cip18)"
+	bool "Latest CIP SLTS version (v4.4.130-cip23)"
 	help
 	  CIP launched in the spring of 2016 to address the needs of
 	  organizations in industries such as power generation and
@@ -117,7 +121,7 @@ endif
 config BR2_LINUX_KERNEL_VERSION
 	string
 	default "4.15.16" if BR2_LINUX_KERNEL_LATEST_VERSION
-	default "v4.4.112-cip18" if BR2_LINUX_KERNEL_LATEST_CIP_VERSION
+	default "v4.4.130-cip23" if BR2_LINUX_KERNEL_LATEST_CIP_VERSION
 	default BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE \
 		if BR2_LINUX_KERNEL_CUSTOM_VERSION
 	default "custom" if BR2_LINUX_KERNEL_CUSTOM_TARBALL
diff --git a/linux/linux.mk b/linux/linux.mk
index 8d14f41c6b..701d7ee1ae 100644
--- a/linux/linux.mk
+++ b/linux/linux.mk
@@ -155,9 +155,9 @@ LINUX_IMAGE_NAME = zImage.epapr
 else ifeq ($(BR2_LINUX_KERNEL_APPENDED_ZIMAGE),y)
 LINUX_IMAGE_NAME = zImage
 else ifeq ($(BR2_LINUX_KERNEL_CUIMAGE),y)
-LINUX_IMAGE_NAME = cuImage.$(KERNEL_DTS_NAME)
+LINUX_IMAGE_NAME = cuImage.$(firstword $(KERNEL_DTS_NAME))
 else ifeq ($(BR2_LINUX_KERNEL_SIMPLEIMAGE),y)
-LINUX_IMAGE_NAME = simpleImage.$(KERNEL_DTS_NAME)
+LINUX_IMAGE_NAME = simpleImage.$(firstword $(KERNEL_DTS_NAME))
 else ifeq ($(BR2_LINUX_KERNEL_IMAGE),y)
 LINUX_IMAGE_NAME = Image
 else ifeq ($(BR2_LINUX_KERNEL_LINUX_BIN),y)
@@ -235,7 +235,14 @@ LINUX_KCONFIG_FILE = $(call qstrip,$(BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE))
 endif
 LINUX_KCONFIG_FRAGMENT_FILES = $(call qstrip,$(BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES))
 LINUX_KCONFIG_EDITORS = menuconfig xconfig gconfig nconfig
-LINUX_KCONFIG_OPTS = $(LINUX_MAKE_FLAGS)
+
+# LINUX_MAKE_FLAGS overrides HOSTCC to allow the kernel build to find our
+# host-openssl and host-libelf. However, this triggers a bug in the kconfig
+# build script that causes it to build with /usr/include/ncurses.h (which is
+# typically wchar) but link with $(HOST_DIR)/lib/libncurses.so (which is not).
+# We don't actually need any host-package for kconfig, so remove the HOSTCC
+# override again.
+LINUX_KCONFIG_OPTS = $(LINUX_MAKE_FLAGS) HOSTCC="$(HOSTCC)"
 
 # If no package has yet set it, set it from the Kconfig option
 LINUX_NEEDS_MODULES ?= $(BR2_LINUX_NEEDS_MODULES)
diff --git a/package/acl/0003-all-use-install-1-to-install-executables.patch b/package/acl/0003-all-use-install-1-to-install-executables.patch
new file mode 100644
index 0000000000..9640dd866d
--- /dev/null
+++ b/package/acl/0003-all-use-install-1-to-install-executables.patch
@@ -0,0 +1,67 @@
+From d3bd7b29b79147b4155e78a8ea06ded98b91f92a Mon Sep 17 00:00:00 2001
+From: "Yann E. MORIN" <yann.morin.1998@free.fr>
+Date: Tue, 8 May 2018 15:23:57 +0200
+Subject: [PATCH] all: use install(1) to install executables
+
+When the destination file already exists, the current install script
+will overwrite it with the new executable.
+
+However, when the existing executable is a symlink or hardlink to
+something else, like busybox, this effectively overwrites that something
+with the new executable, and thus replaces busybox and all its applets
+with the code for either of the three commands.
+
+We fix that by simply calling install(1). install(1) is sufficiently
+widespread that we don't bother checking for it, as tis is just a
+workaround while waiting for the version bump that will eventually fix
+it for good.
+
+Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
+---
+ chacl/Makefile   | 4 ++--
+ getfacl/Makefile | 4 ++--
+ setfacl/Makefile | 4 ++--
+ 3 files changed, 6 insertions(+), 6 deletions(-)
+
+diff --git a/chacl/Makefile b/chacl/Makefile
+index 33858d6..c857329 100644
+--- a/chacl/Makefile
++++ b/chacl/Makefile
+@@ -30,6 +30,6 @@ default: $(LTCOMMAND)
+ include $(BUILDRULES)
+ 
+ install: default
+-	$(INSTALL) -m 755 -d $(PKG_BIN_DIR)
+-	$(LTINSTALL) -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)
++	install -D -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)/$(LTCOMMAND)
++
+ install-dev install-lib:
+diff --git a/getfacl/Makefile b/getfacl/Makefile
+index 7fbafda..8ac63e0 100644
+--- a/getfacl/Makefile
++++ b/getfacl/Makefile
+@@ -31,6 +31,6 @@ default: $(LTCOMMAND)
+ include $(BUILDRULES)
+ 
+ install: default
+-	$(INSTALL) -m 755 -d $(PKG_BIN_DIR)
+-	$(LTINSTALL) -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)
++	install -D -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)/$(LTCOMMAND)
++
+ install-dev install-lib:
+diff --git a/setfacl/Makefile b/setfacl/Makefile
+index c44e7c0..eea2ede 100644
+--- a/setfacl/Makefile
++++ b/setfacl/Makefile
+@@ -31,6 +31,6 @@ default: $(LTCOMMAND)
+ include $(BUILDRULES)
+ 
+ install: default
+-	$(INSTALL) -m 755 -d $(PKG_BIN_DIR)
+-	$(LTINSTALL) -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)
++	install -D -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)/$(LTCOMMAND)
++
+ install-dev install-lib:
+-- 
+2.14.1
+
diff --git a/package/apr-util/apr-util.mk b/package/apr-util/apr-util.mk
index c44cef009f..b006964ccb 100644
--- a/package/apr-util/apr-util.mk
+++ b/package/apr-util/apr-util.mk
@@ -47,6 +47,17 @@ else
 APR_UTIL_CONF_OPTS += --without-sqlite3
 endif
 
+ifeq ($(BR2_PACKAGE_OPENLDAP),y)
+APR_UTIL_CONF_ENV += ac_cv_ldap_set_rebind_proc_style=three
+APR_UTIL_CONF_OPTS += \
+	--with-ldap \
+	--with-ldap-include="$(STAGING_DIR)/usr/include/" \
+	--with-ldap-lib="$(STAGING_DIR)/usr/lib"
+APR_UTIL_DEPENDENCIES += openldap
+else
+APR_UTIL_CONF_OPTS += --without-ldap
+endif
+
 ifeq ($(BR2_PACKAGE_OPENSSL),y)
 APR_UTIL_CONF_OPTS += --with-crypto --with-openssl="$(STAGING_DIR)/usr"
 APR_UTIL_DEPENDENCIES += openssl
@@ -54,6 +65,13 @@ else
 APR_UTIL_CONF_OPTS += --without-crypto
 endif
 
+ifeq ($(BR2_PACKAGE_POSTGRESQL),y)
+APR_UTIL_CONF_OPTS += --with-pgsql="$(STAGING_DIR)/usr"
+APR_UTIL_DEPENDENCIES += postgresql
+else
+APR_UTIL_CONF_OPTS += --without-pgsql
+endif
+
 ifeq ($(BR2_PACKAGE_UNIXODBC),y)
 APR_UTIL_CONF_OPTS += --with-odbc="$(STAGING_DIR)/usr"
 # avoid using target binary $(STAGING_DIR)/usr/bin/odbc_config
diff --git a/package/asterisk/0006-build-fix-issues-building-without-ssl.patch b/package/asterisk/0006-build-fix-issues-building-without-ssl.patch
new file mode 100644
index 0000000000..b02031e5ab
--- /dev/null
+++ b/package/asterisk/0006-build-fix-issues-building-without-ssl.patch
@@ -0,0 +1,57 @@
+From 999e0c17d7e4139d36730752a34fbfde18a4f9f1 Mon Sep 17 00:00:00 2001
+From: Corey Farrell <git@cfware.com>
+Date: Sun, 19 Nov 2017 14:52:59 -0500
+Subject: [PATCH] Build: Fix issues building without SSL.
+
+* Fix conditional in libasteriskssl.
+* Use variables produced by configure to link the SSL and uuid libraries
+  into libasteriskpj.so instead of hard-coding them.
+
+ASTERISK-27431
+
+Change-Id: I3977931fd3ef8c4e4376349ccddb354eb839b58d
+
+Downloaded from upstream master branch
+https://github.com/asterisk/asterisk/commit/999e0c17d7e4139d36730752a34fbfde18a4f9f1
+
+Signed-off-by: Bernd Kuhls <bernd.kuhls@t-online.de>
+---
+ main/Makefile         | 4 ++--
+ main/libasteriskssl.c | 2 +-
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/main/Makefile b/main/Makefile
+index 08d1f65580e..c724e2012b0 100644
+--- a/main/Makefile
++++ b/main/Makefile
+@@ -273,7 +273,7 @@ endif
+ 
+ $(ASTPJ_LIB).$(ASTPJ_SO_VERSION): _ASTLDFLAGS+=-Wl,-soname=$(ASTPJ_LIB).$(ASTPJ_SO_VERSION) $(PJ_LDFLAGS)
+ $(ASTPJ_LIB).$(ASTPJ_SO_VERSION): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskpj\" -DAST_NOT_MODULE $(PJ_CFLAGS)
+-$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): LIBS+=$(PJPROJECT_LDLIBS) -lssl -lcrypto -luuid -lm -lpthread $(RT_LIB)
++$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): LIBS+=$(PJPROJECT_LDLIBS) $(OPENSSL_LIB) $(UUID_LIB) -lm -lpthread $(RT_LIB)
+ ifeq ($(GNU_LD),1)
+     $(ASTPJ_LIB).$(ASTPJ_SO_VERSION): SO_SUPPRESS_SYMBOLS=-Wl,--version-script,libasteriskpj.exports,--warn-common
+ endif
+@@ -298,7 +298,7 @@ ASTPJ_LIB:=libasteriskpj.dylib
+ # /lib or /usr/lib
+ $(ASTPJ_LIB): _ASTLDFLAGS+=-dynamiclib -install_name $(ASTLIBDIR)/$(ASTPJ_LIB) $(PJ_LDFLAGS)
+ $(ASTPJ_LIB): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskpj\" $(PJ_CFLAGS) -DAST_NOT_MODULE
+-$(ASTPJ_LIB): LIBS+=$(PJPROJECT_LIBS)  -lssl -lcrypto -luuid -lm -lpthread $(RT_LIB)
++$(ASTPJ_LIB): LIBS+=$(PJPROJECT_LIBS)  $(OPENSSL_LIB) $(UUID_LIB) -lm -lpthread $(RT_LIB)
+ $(ASTPJ_LIB): SOLINK=$(DYLINK)
+ 
+ # Special rules for building a shared library (not a dynamically loadable module)
+diff --git a/main/libasteriskssl.c b/main/libasteriskssl.c
+index 8b19e247da9..e2e256f8ffe 100644
+--- a/main/libasteriskssl.c
++++ b/main/libasteriskssl.c
+@@ -37,7 +37,7 @@
+ #endif
+ 
+ #if defined(HAVE_OPENSSL) && \
+-	!defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
++	(!defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
+ 
+ #include <dlfcn.h>
+ 
diff --git a/package/attr/0004-all-use-install-1-to-install-executables.patch b/package/attr/0004-all-use-install-1-to-install-executables.patch
new file mode 100644
index 0000000000..ef59bb797c
--- /dev/null
+++ b/package/attr/0004-all-use-install-1-to-install-executables.patch
@@ -0,0 +1,67 @@
+From 4187e60ab52cac3ed36036a354977310dab68dcb Mon Sep 17 00:00:00 2001
+From: "Yann E. MORIN" <yann.morin.1998@free.fr>
+Date: Tue, 8 May 2018 15:16:10 +0200
+Subject: [PATCH] all: use install(1) to install executables
+
+When the destination file already exists, the current install script
+will overwrite it with the new executable.
+
+However, when the existing executable is a symlink or hardlink to
+something else, like busybox, this effectively overwrites that something
+with the new executable, and thus replaces busybox and all its applets
+with the code for either of the three commands.
+
+We fix that by simply calling install(1). install(1) is sufficiently
+widespread that we don't bother checking for it, as this is just a
+workaround while waiting for the version bump that will eventually fix
+it for good.
+
+Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
+---
+ attr/Makefile     | 4 ++--
+ getfattr/Makefile | 4 ++--
+ setfattr/Makefile | 4 ++--
+ 3 files changed, 6 insertions(+), 6 deletions(-)
+
+diff --git a/attr/Makefile b/attr/Makefile
+index 1c467e8..326dd7e 100644
+--- a/attr/Makefile
++++ b/attr/Makefile
+@@ -29,6 +29,6 @@ default: $(LTCOMMAND)
+ include $(BUILDRULES)
+ 
+ install: default
+-	$(INSTALL) -m 755 -d $(PKG_BIN_DIR)
+-	$(LTINSTALL) -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)
++	install -D -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)/$(LTCOMMAND)
++
+ install-dev install-lib:
+diff --git a/getfattr/Makefile b/getfattr/Makefile
+index 91d3df2..f913172 100644
+--- a/getfattr/Makefile
++++ b/getfattr/Makefile
+@@ -30,6 +30,6 @@ default: $(LTCOMMAND)
+ include $(BUILDRULES)
+ 
+ install: default
+-	$(INSTALL) -m 755 -d $(PKG_BIN_DIR)
+-	$(LTINSTALL) -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)
++	install -D -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)/$(LTCOMMAND)
++
+ install-dev install-lib:
+diff --git a/setfattr/Makefile b/setfattr/Makefile
+index d55461b..26dc5d8 100644
+--- a/setfattr/Makefile
++++ b/setfattr/Makefile
+@@ -30,6 +30,6 @@ default: $(LTCOMMAND)
+ include $(BUILDRULES)
+ 
+ install: default
+-	$(INSTALL) -m 755 -d $(PKG_BIN_DIR)
+-	$(LTINSTALL) -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)
++	install -D -m 755 $(LTCOMMAND) $(PKG_BIN_DIR)/$(LTCOMMAND)
++
+ install-dev install-lib:
+-- 
+2.14.1
+
diff --git a/package/audit/audit.mk b/package/audit/audit.mk
index f5aa00d2f0..2f6e6653b3 100644
--- a/package/audit/audit.mk
+++ b/package/audit/audit.mk
@@ -51,8 +51,8 @@ define AUDIT_INSTALL_INIT_SYSTEMD
 endef
 
 define AUDIT_INSTALL_CLEANUP
-	$(RM) -rf $(TARGET_DIR)/etc/rc.d
-	$(RM) -rf $(TARGET_DIR)/etc/sysconfig
+	$(RM) $(TARGET_DIR)/etc/rc.d/init.d/auditd
+	$(RM) $(TARGET_DIR)/etc/sysconfig/auditd
 endef
 AUDIT_POST_INSTALL_TARGET_HOOKS += AUDIT_INSTALL_CLEANUP
 
diff --git a/package/autofs/autofs.mk b/package/autofs/autofs.mk
index 90cc38de55..befee15495 100644
--- a/package/autofs/autofs.mk
+++ b/package/autofs/autofs.mk
@@ -9,7 +9,7 @@ AUTOFS_SOURCE = autofs-$(AUTOFS_VERSION).tar.xz
 AUTOFS_SITE = $(BR2_KERNEL_MIRROR)/linux/daemons/autofs/v5
 AUTOFS_LICENSE = GPL-2.0+
 AUTOFS_LICENSE_FILES = COPYING COPYRIGHT
-AUTOFS_DEPENDENCIES = host-flex host-bison
+AUTOFS_DEPENDENCIES = host-flex host-bison host-nfs-utils
 
 # autofs looks on the build machine for the path of modprobe, so tell
 # it explicitly where it will be located on the target.
diff --git a/package/binutils/Config.in.host b/package/binutils/Config.in.host
index d4ed1e3183..bc0e223e9f 100644
--- a/package/binutils/Config.in.host
+++ b/package/binutils/Config.in.host
@@ -2,6 +2,8 @@ comment "Binutils Options"
 
 choice
 	prompt "Binutils Version"
+	default BR2_BINUTILS_VERSION_2_28_X if BR2_ARM_INSTRUCTIONS_THUMB
+	default BR2_BINUTILS_VERSION_2_28_X if BR2_ARM_INSTRUCTIONS_THUMB2
 	default BR2_BINUTILS_VERSION_2_29_X if !BR2_arc
 	default BR2_BINUTILS_VERSION_ARC if BR2_arc
 	help
diff --git a/package/binutils/binutils.mk b/package/binutils/binutils.mk
index 1bd01ecefc..ac4575b616 100644
--- a/package/binutils/binutils.mk
+++ b/package/binutils/binutils.mk
@@ -136,5 +136,18 @@ ifeq ($(BR2_BINUTILS_ENABLE_LTO),y)
 HOST_BINUTILS_CONF_OPTS += --enable-plugins --enable-lto
 endif
 
+# Hardlinks between binaries in different directories cause a problem
+# with rpath fixup, so we de-hardlink those binaries, and replace them
+# with copies instead.
+BINUTILS_TOOLS = ar as ld ld.bfd nm objcopy objdump ranlib readelf strip
+define HOST_BINUTILS_FIXUP_HARDLINKS
+	$(foreach tool,$(BINUTILS_TOOLS),\
+		rm -f $(HOST_DIR)/$(GNU_TARGET_NAME)/bin/$(tool) && \
+		cp -a $(HOST_DIR)/bin/$(GNU_TARGET_NAME)-$(tool) \
+			$(HOST_DIR)/$(GNU_TARGET_NAME)/bin/$(tool)
+	)
+endef
+HOST_BINUTILS_POST_INSTALL_HOOKS += HOST_BINUTILS_FIXUP_HARDLINKS
+
 $(eval $(autotools-package))
 $(eval $(host-autotools-package))
diff --git a/package/busybox/S01logging b/package/busybox/S01logging
index 4632a4cc99..fcb3e7d236 100644
--- a/package/busybox/S01logging
+++ b/package/busybox/S01logging
@@ -33,7 +33,7 @@ case "$1" in
 	start
 	;;
   *)
-	echo "Usage: $0 {start|stop|restart}"
+	echo "Usage: $0 {start|stop|restart|reload}"
 	exit 1
 esac
 
diff --git a/package/busybox/S10mdev b/package/busybox/S10mdev
index 63ca955b1c..7075b77016 100644
--- a/package/busybox/S10mdev
+++ b/package/busybox/S10mdev
@@ -9,7 +9,8 @@ case "$1" in
 	echo /sbin/mdev >/proc/sys/kernel/hotplug
 	/sbin/mdev -s
 	# coldplug modules
-	find /sys/ -name modalias -print0 | xargs -0 sort -u -z | xargs -0 modprobe -abq
+	find /sys/ -name modalias -print0 | xargs -0 sort -u | tr '\n' '\0' | \
+	    xargs -0 modprobe -abq
 	;;
   stop)
 	;;
diff --git a/package/busybox/inittab b/package/busybox/inittab
index 3f49f6bd7a..ff1725c775 100644
--- a/package/busybox/inittab
+++ b/package/busybox/inittab
@@ -16,9 +16,13 @@
 # Startup the system
 ::sysinit:/bin/mount -t proc proc /proc
 ::sysinit:/bin/mount -o remount,rw /
-::sysinit:/bin/mkdir -p /dev/pts
-::sysinit:/bin/mkdir -p /dev/shm
+::sysinit:/bin/mkdir -p /dev/pts /dev/shm
 ::sysinit:/bin/mount -a
+::sysinit:/sbin/swapon -a
+null::sysinit:/bin/ln -sf /proc/self/fd /dev/fd
+null::sysinit:/bin/ln -sf /proc/self/fd/0 /dev/stdin
+null::sysinit:/bin/ln -sf /proc/self/fd/1 /dev/stdout
+null::sysinit:/bin/ln -sf /proc/self/fd/2 /dev/stderr
 ::sysinit:/bin/hostname -F /etc/hostname
 # now run any rc scripts
 ::sysinit:/etc/init.d/rcS
diff --git a/package/cifs-utils/cifs-utils.mk b/package/cifs-utils/cifs-utils.mk
index 9044fdf83c..e0efb3bf2e 100644
--- a/package/cifs-utils/cifs-utils.mk
+++ b/package/cifs-utils/cifs-utils.mk
@@ -13,9 +13,9 @@ CIFS_UTILS_LICENSE_FILES = COPYING
 CIFS_UTILS_AUTORECONF = YES
 CIFS_UTILS_DEPENDENCIES = host-pkgconf
 
-ifeq ($(BR2_TOOLCHAIN_SUPPORTS_PIE),)
-CIFS_UTILS_CONF_OPTS += --disable-pie
-endif
+# Let's disable PIE unconditionally. We want PIE to be enabled only by
+# the global BR2_RELRO_FULL option.
+CIFS_UTILS_CONF_OPTS = --disable-pie --disable-man
 
 ifeq ($(BR2_PACKAGE_KEYUTILS),y)
 CIFS_UTILS_DEPENDENCIES += keyutils
diff --git a/package/cups-filters/0001-Replace-relative-linking-with-absolute-linking.patch b/package/cups-filters/0001-Replace-relative-linking-with-absolute-linking.patch
new file mode 100644
index 0000000000..e4b35cda39
--- /dev/null
+++ b/package/cups-filters/0001-Replace-relative-linking-with-absolute-linking.patch
@@ -0,0 +1,46 @@
+From c26b4c3550557442890f2f790d4f8b61a3734c1f Mon Sep 17 00:00:00 2001
+From: Olivier Schonken <olivier.schonken@gmail.com>
+Date: Thu, 8 Mar 2018 12:32:23 +0200
+Subject: [PATCH] install: don't use ln -r
+
+Oldish enterprise-class distributions have too old versions of
+coreutils, with ln not supporting -r.
+
+So we fake it.
+
+ln -r would create minimalist relative paths, but they are not
+trivial to generate. Instead, we always create paths relative to the
+root, i.e.:
+
+    ln -s -r /usr/bin/foo /usr/sbin/foo
+
+would create:  /usr/sbin/foo -> ../bin/foo
+while we do :  /usr/sbin/foo -> ../../usr/bin/foo
+
+Signed-off-by: Olivier Schonken <olivier.schonken@gmail.com>
+---
+ Makefile.am | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/Makefile.am b/Makefile.am
+index d959227..b49914a 100644
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -998,11 +998,11 @@ install-exec-hook:
+ 	$(INSTALL) -d -m 755 $(DESTDIR)$(pkgfilterdir)
+ 	$(INSTALL) -d -m 755 $(DESTDIR)$(pkgbackenddir)
+ if ENABLE_FOOMATIC
+-	$(LN_S) -r -f $(DESTDIR)$(pkgfilterdir)/foomatic-rip $(DESTDIR)$(bindir)
++	$(LN_S) -f ../..$(pkgfilterdir)/foomatic-rip $(DESTDIR)$(bindir)
+ endif
+ if ENABLE_DRIVERLESS
+-	$(LN_S) -r -f $(DESTDIR)$(pkgppdgendir)/driverless $(DESTDIR)$(bindir)
+-	$(LN_S) -r -f $(DESTDIR)$(pkgppdgendir)/driverless $(DESTDIR)$(pkgbackenddir)
++	$(LN_S) -f ../..$(pkgppdgendir)/driverless $(DESTDIR)$(bindir)
++	$(LN_S) -f ../..$(pkgppdgendir)/driverless $(DESTDIR)$(pkgbackenddir)
+ endif
+ if ENABLE_BRAILLE
+ 	$(LN_S) -f imagetobrf $(DESTDIR)$(pkgfilterdir)/imagetoubrl
+-- 
+2.14.1
+
diff --git a/package/cups-filters/cups-filters.hash b/package/cups-filters/cups-filters.hash
index da9d31c998..7bb00818df 100644
--- a/package/cups-filters/cups-filters.hash
+++ b/package/cups-filters/cups-filters.hash
@@ -1,2 +1,3 @@
 # Locally computed:
-sha256 95254d7950df4c74d293ed7dfa0b714f51cff329a82da74a4ac976d342bb35ab  cups-filters-1.17.9.tar.gz
+sha256 aad95e35033154f54639923b439e0657fc9f616b9eac7490df89514362551f98  cups-filters-1.20.3.tar.gz
+sha256 24cc91478ca68d6d982dfd86181210ad5f0931ec431bdb740793e3d6555fdcd8  COPYING
diff --git a/package/cups-filters/cups-filters.mk b/package/cups-filters/cups-filters.mk
index 6d05aa7e31..131e58246e 100644
--- a/package/cups-filters/cups-filters.mk
+++ b/package/cups-filters/cups-filters.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-CUPS_FILTERS_VERSION = 1.17.9
+CUPS_FILTERS_VERSION = 1.20.3
 CUPS_FILTERS_SITE = http://openprinting.org/download/cups-filters
 CUPS_FILTERS_LICENSE = GPL-2.0, GPL-2.0+, GPL-3.0, GPL-3.0+, LGPL-2, LGPL-2.1+, MIT, BSD-4-Clause
 CUPS_FILTERS_LICENSE_FILES = COPYING
@@ -40,7 +40,8 @@ else
 CUPS_FILTERS_CONF_OPTS += --disable-dbus
 endif
 
-ifeq ($(BR2_PACKAGE_AVAHI),y)
+# avahi support requires avahi-client, which needs avahi-daemon and dbus
+ifeq ($(BR2_PACKAGE_AVAHI_DAEMON)$(BR2_PACKAGE_DBUS),yy)
 CUPS_FILTERS_DEPENDENCIES += avahi
 CUPS_FILTERS_CONF_OPTS += --enable-avahi
 else
diff --git a/package/dash/dash.mk b/package/dash/dash.mk
index 2ee292b8d3..2d415558d2 100644
--- a/package/dash/dash.mk
+++ b/package/dash/dash.mk
@@ -9,6 +9,9 @@ DASH_SITE = http://gondor.apana.org.au/~herbert/dash/files
 DASH_LICENSE = BSD-3-Clause, GPL-2.0+ (mksignames.c)
 DASH_LICENSE_FILES = COPYING
 
+# dash does not build in parallel
+DASH_MAKE = $(MAKE1)
+
 ifeq ($(BR2_PACKAGE_LIBEDIT),y)
 DASH_DEPENDENCIES += libedit host-pkgconf
 DASH_CONF_OPTS += --with-libedit
diff --git a/package/ebtables/Config.in b/package/ebtables/Config.in
index 2fdac06cd1..3f7566a607 100644
--- a/package/ebtables/Config.in
+++ b/package/ebtables/Config.in
@@ -5,6 +5,3 @@ config BR2_PACKAGE_EBTABLES
 	  Ethernet bridge frame table administration
 
 	  http://ebtables.netfilter.org/
-
-comment "ebtables needs a glibc or uClibc toolchain"
-	depends on BR2_USE_MMU
diff --git a/package/elf2flt/elf2flt.mk b/package/elf2flt/elf2flt.mk
index 995dfedebd..557f94d338 100644
--- a/package/elf2flt/elf2flt.mk
+++ b/package/elf2flt/elf2flt.mk
@@ -29,4 +29,20 @@ endif
 
 HOST_ELF2FLT_CONF_ENV = LIBS="$(HOST_ELF2FLT_LIBS)"
 
+# Hardlinks between binaries in different directories cause a problem
+# with rpath fixup, so we de-hardlink those binaries, and replace them
+# with copies instead. Note that elf2flt will rename ld to ld.real
+# before installing its own ld, but we already took care of the
+# original ld from binutils so that it is already de-hardlinked. So
+# ld is now the one from elf2flt, and we want to de-hardlinke it.
+ELF2FLT_TOOLS = elf2flt flthdr ld
+define HOST_ELF2FLT_FIXUP_HARDLINKS
+	$(foreach tool,$(ELF2FLT_TOOLS),\
+		rm -f $(HOST_DIR)/$(GNU_TARGET_NAME)/bin/$(tool) && \
+		cp -a $(HOST_DIR)/bin/$(GNU_TARGET_NAME)-$(tool) \
+			$(HOST_DIR)/$(GNU_TARGET_NAME)/bin/$(tool)
+	)
+endef
+HOST_ELF2FLT_POST_INSTALL_HOOKS += HOST_ELF2FLT_FIXUP_HARDLINKS
+
 $(eval $(host-autotools-package))
diff --git a/package/exim/0001-Build-buildconfig-for-the-host.patch b/package/exim/0001-Build-buildconfig-for-the-host.patch
index a926fbdab3..87eb527974 100644
--- a/package/exim/0001-Build-buildconfig-for-the-host.patch
+++ b/package/exim/0001-Build-buildconfig-for-the-host.patch
@@ -17,7 +17,7 @@ index 29a6ad3..420ba60 100644
 -	@echo "$(CC) buildconfig.c"
 -	$(FE)$(CC) $(CFLAGS) $(INCLUDE) -o buildconfig buildconfig.c $(LIBS)
 +	@echo "$(HOSTCC) buildconfig.c"
-+	$(FE)$(HOSTCC) $(HOSTCFLAGS) $(INCLUDE) -o buildconfig buildconfig.c $(LIBS)
++	$(FE)$(HOSTCC) $(HOSTCFLAGS) $(INCLUDE) -o buildconfig buildconfig.c
  
  
  # Target for the exicyclog utility script
diff --git a/package/expect/expect.hash b/package/expect/expect.hash
new file mode 100644
index 0000000000..c89f323906
--- /dev/null
+++ b/package/expect/expect.hash
@@ -0,0 +1,4 @@
+# From https://sourceforge.net/projects/expect/files/Expect/5.45.3/expect5.45.3.tar.gz.SHA256
+sha256  c520717b7195944a69ce1492ec82ca0ac3f3baf060804e6c5ee6d505ea512be9  expect5.45.3.tar.gz
+# Locally calculated
+sha256  b2415b17dc8d9a287f4509047ef5ac3436baef7ba7c50faef5222dcdf61a2bab  README
diff --git a/package/expect/expect.mk b/package/expect/expect.mk
index d78ff6c208..ccde33a71b 100644
--- a/package/expect/expect.mk
+++ b/package/expect/expect.mk
@@ -4,12 +4,13 @@
 #
 ################################################################################
 
-# Version 5.45.3
-EXPECT_VERSION = 2014-05-02
-EXPECT_SITE = cvs://expect.cvs.sourceforge.net:/cvsroot/expect
+EXPECT_VERSION = 5.45.3
+EXPECT_SITE = https://sourceforge.net/projects/expect/files/Expect/$(EXPECT_VERSION)
+EXPECT_SOURCE = expect$(EXPECT_VERSION).tar.gz
 EXPECT_LICENSE = Public domain
 EXPECT_LICENSE_FILES = README
 
+# 0001-enable-cross-compilation.patch
 EXPECT_AUTORECONF = YES
 EXPECT_DEPENDENCIES = tcl
 EXPECT_CONF_OPTS = --with-tcl=$(BUILD_DIR)/tcl-$(TCL_VERSION)/unix
diff --git a/package/f2fs-tools/Config.in b/package/f2fs-tools/Config.in
index f0630e99c6..e373096380 100644
--- a/package/f2fs-tools/Config.in
+++ b/package/f2fs-tools/Config.in
@@ -6,7 +6,7 @@ config BR2_PACKAGE_F2FS_TOOLS
 	help
 	  Tools for Flash-Friendly File System (F2FS)
 
-	  http://sourceforge.net/projects/f2fs-tools/
+	  https://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs-tools.git
 
 comment "f2fs-tools needs a toolchain w/ wchar"
 	depends on !BR2_USE_WCHAR
diff --git a/package/faketime/0002-src-Makefile-disable-Werror.patch b/package/faketime/0002-src-Makefile-disable-Werror.patch
new file mode 100644
index 0000000000..e1e3b321b8
--- /dev/null
+++ b/package/faketime/0002-src-Makefile-disable-Werror.patch
@@ -0,0 +1,32 @@
+From bcde6e6f34c3cf78a254315c5caa530db91802fb Mon Sep 17 00:00:00 2001
+From: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Date: Thu, 17 May 2018 23:41:03 +0200
+Subject: [PATCH] src/Makefile: disable -Werror
+
+gcc 8.x has enabled additional warnings that break the build due to
+-Werror, so let's drop -Werror for now. A set of patches has been
+submitted upstream (https://github.com/wolfcw/libfaketime/pull/161) to
+properly fix the gcc 8.x issues, but in the mean time, disabling
+-Werror is a simpler option.
+
+Signed-off-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ src/Makefile | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/src/Makefile b/src/Makefile
+index bbbd476..6b0d2cd 100644
+--- a/src/Makefile
++++ b/src/Makefile
+@@ -67,7 +67,7 @@ INSTALL ?= install
+ PREFIX ?= /usr/local
+ LIBDIRNAME ?= /lib/faketime
+ 
+-CFLAGS += -std=gnu99 -Wall -Wextra -Werror -Wno-nonnull-compare -DFAKE_STAT -DFAKE_SLEEP -DFAKE_TIMERS -DFAKE_INTERNAL_CALLS -fPIC -DPREFIX='"'$(PREFIX)'"' -DLIBDIRNAME='"'$(LIBDIRNAME)'"'
++CFLAGS += -std=gnu99 -Wall -Wextra -Wno-nonnull-compare -DFAKE_STAT -DFAKE_SLEEP -DFAKE_TIMERS -DFAKE_INTERNAL_CALLS -fPIC -DPREFIX='"'$(PREFIX)'"' -DLIBDIRNAME='"'$(LIBDIRNAME)'"'
+ LIB_LDFLAGS += -shared
+ LDFLAGS += -Wl,--version-script=libfaketime.map -lpthread
+ LDADD += -ldl -lm -lrt
+-- 
+2.14.3
+
diff --git a/package/file/0001-Avoid-reading-past-the-end-of-buffer-Rui-Reis.patch b/package/file/0001-Avoid-reading-past-the-end-of-buffer-Rui-Reis.patch
new file mode 100644
index 0000000000..daff866692
--- /dev/null
+++ b/package/file/0001-Avoid-reading-past-the-end-of-buffer-Rui-Reis.patch
@@ -0,0 +1,30 @@
+From a642587a9c9e2dd7feacdf513c3643ce26ad3c22 Mon Sep 17 00:00:00 2001
+From: Christos Zoulas <christos@zoulas.com>
+Date: Sat, 9 Jun 2018 16:00:06 +0000
+Subject: [PATCH] Avoid reading past the end of buffer (Rui Reis)
+
+[baruch: drop file version string update hunk]
+Signed-off-by: Baruch Siach <baruch@tkos.co.il>
+---
+Upstream status: commit a642587a9c9 in github mirror
+
+ src/readelf.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/src/readelf.c b/src/readelf.c
+index 79c83f9f5048..1f41b46113c3 100644
+--- a/src/readelf.c
++++ b/src/readelf.c
+@@ -842,7 +842,8 @@ do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,
+ 
+ 				cname = (unsigned char *)
+ 				    &nbuf[doff + prpsoffsets(i)];
+-				for (cp = cname; *cp && isprint(*cp); cp++)
++				for (cp = cname; cp < nbuf + size && *cp
++				    && isprint(*cp); cp++)
+ 					continue;
+ 				/*
+ 				 * Linux apparently appends a space at the end
+-- 
+2.17.1
+
diff --git a/package/file/file.hash b/package/file/file.hash
index fee516c8e2..a6b40be349 100644
--- a/package/file/file.hash
+++ b/package/file/file.hash
@@ -1,2 +1,5 @@
 # Locally calculated
-sha256 8639dc4d1b21e232285cd483604afc4a6ee810710e00e579dbe9591681722b50  file-5.32.tar.gz
+sha256 1c52c8c3d271cd898d5511c36a68059cda94036111ab293f01f83c3525b737c6  file-5.33.tar.gz
+sha256 3c0ad13c36f891a9b4f951e59eb2fc108065a46f849697cc6fd3cdb41cc23a3d  COPYING
+sha256 d98ee4d8d95e7d021a5dfc41f137ecc3b624a7b98e8bd793130202d12a21ed57  src/mygetopt.h
+sha256 85e358d575ad4ac5b38b623a25b24246ccff3c7e680d930c0a9ff5228fe434b6  src/vasprintf.c
diff --git a/package/file/file.mk b/package/file/file.mk
index df0e0f0eb9..422e29b1ce 100644
--- a/package/file/file.mk
+++ b/package/file/file.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-FILE_VERSION = 5.32
+FILE_VERSION = 5.33
 FILE_SITE = ftp://ftp.astron.com/pub/file
 FILE_DEPENDENCIES = host-file zlib
 HOST_FILE_DEPENDENCIES = host-zlib
@@ -13,5 +13,12 @@ FILE_INSTALL_STAGING = YES
 FILE_LICENSE = BSD-2-Clause, BSD-4-Clause (one file), BSD-3-Clause (one file)
 FILE_LICENSE_FILES = COPYING src/mygetopt.h src/vasprintf.c
 
+ifeq ($(BR2_PACKAGE_LIBSECCOMP),y)
+FILE_CONF_OPTS += --enable-libseccomp
+FILE_DEPENDENCIES += libseccomp
+else
+FILE_CONF_OPTS += --disable-libseccomp
+endif
+
 $(eval $(autotools-package))
 $(eval $(host-autotools-package))
diff --git a/package/gdb/gdb.mk b/package/gdb/gdb.mk
index ad81818a35..0981b6ef53 100644
--- a/package/gdb/gdb.mk
+++ b/package/gdb/gdb.mk
@@ -109,7 +109,7 @@ GDB_CONF_OPTS = \
 	--without-x \
 	--disable-sim \
 	$(GDB_DISABLE_BINUTILS_CONF_OPTS) \
-	$(if $(BR2_PACKAGE_GDB_SERVER),--enable-gdbserver) \
+	$(if $(BR2_PACKAGE_GDB_SERVER),--enable-gdbserver,--disable-gdbserver) \
 	--with-curses \
 	--without-included-gettext \
 	--disable-werror \
diff --git a/package/git/git.hash b/package/git/git.hash
index 504f7d993a..4bcc5ee5d3 100644
--- a/package/git/git.hash
+++ b/package/git/git.hash
@@ -1,4 +1,4 @@
 # From: https://www.kernel.org/pub/software/scm/git/sha256sums.asc
-sha256 cfad4337f2fdbfc1e2c8abce5e17e1dd4e1718a34ac2cbe3238fbe2426f2ea19  git-2.16.1.tar.xz
+sha256 6e69b0e9c487e5da52a14d4829f0b6a28b2c18a0bb6fb67c0dc8b5b5658bd532  git-2.16.4.tar.xz
 sha256 5b2198d1645f767585e8a88ac0499b04472164c0d2da22e75ecf97ef443ab32e  COPYING
 sha256 1922f45d2c49e390032c9c0ba6d7cac904087f7cec51af30c2b2ad022ce0e76a  LGPL-2.1
diff --git a/package/git/git.mk b/package/git/git.mk
index 1109f7a8a2..ac7b8f2e8c 100644
--- a/package/git/git.mk
+++ b/package/git/git.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-GIT_VERSION = 2.16.1
+GIT_VERSION = 2.16.4
 GIT_SOURCE = git-$(GIT_VERSION).tar.xz
 GIT_SITE = $(BR2_KERNEL_MIRROR)/software/scm/git
 GIT_LICENSE = GPL-2.0, LGPL-2.1+
diff --git a/package/glibc/glibc.hash b/package/glibc/glibc.hash
index 3dab1e1516..890f523fd9 100644
--- a/package/glibc/glibc.hash
+++ b/package/glibc/glibc.hash
@@ -1,4 +1,4 @@
 # Locally calculated (fetched from Github)
-sha256  00fbc845678a96f4acc574c4bda4be76506ecd8bafb2d08c58bfa3507625c81a     glibc-glibc-2.26-146-gd300041c533a3d837c9f37a099bcc95466860e98.tar.gz
+sha256  1e18aee61dc51a5aaf7bfcb65ed01894aa82c3d3f7b9a01f20d59cd9db2f082b     glibc-glibc-2.26-160-g4df8479e6b3baf365bd4eedbba922b73471e5d73.tar.gz
 # Locally calculated (fetched from Github)
 sha256  5aa9adeac09727db0b8a52794186563771e74d70410e9fd86431e339953fd4bb     glibc-arc-2017.09-release.tar.gz
diff --git a/package/glibc/glibc.mk b/package/glibc/glibc.mk
index 0351433e6a..562f0258d5 100644
--- a/package/glibc/glibc.mk
+++ b/package/glibc/glibc.mk
@@ -10,7 +10,7 @@ GLIBC_SITE = $(call github,foss-for-synopsys-dwc-arc-processors,glibc,$(GLIBC_VE
 else
 # Generate version string using:
 #   git describe --match 'glibc-*' --abbrev=40 origin/release/MAJOR.MINOR/master
-GLIBC_VERSION = glibc-2.26-146-gd300041c533a3d837c9f37a099bcc95466860e98
+GLIBC_VERSION = glibc-2.26-160-g4df8479e6b3baf365bd4eedbba922b73471e5d73
 # Upstream doesn't officially provide an https download link.
 # There is one (https://sourceware.org/git/glibc.git) but it's not reliable,
 # sometimes the connection times out. So use an unofficial github mirror.
diff --git a/package/gnupg/gnupg.hash b/package/gnupg/gnupg.hash
index abd76cde9c..3bacdf6563 100644
--- a/package/gnupg/gnupg.hash
+++ b/package/gnupg/gnupg.hash
@@ -1,3 +1,3 @@
 # Locally computed based on signature
-# https://gnupg.org/ftp/gcrypt/gnupg/gnupg-1.4.22.tar.bz2.sig
-sha256	9594a24bec63a21568424242e3f198b9d9828dea5ff0c335e47b06f835f930b4	gnupg-1.4.22.tar.bz2
+# https://gnupg.org/ftp/gcrypt/gnupg/gnupg-1.4.23.tar.bz2.sig
+sha256	c9462f17e651b6507848c08c430c791287cd75491f8b5a8b50c6ed46b12678ba	gnupg-1.4.23.tar.bz2
diff --git a/package/gnupg/gnupg.mk b/package/gnupg/gnupg.mk
index 3ff202b709..ac9047894d 100644
--- a/package/gnupg/gnupg.mk
+++ b/package/gnupg/gnupg.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-GNUPG_VERSION = 1.4.22
+GNUPG_VERSION = 1.4.23
 GNUPG_SOURCE = gnupg-$(GNUPG_VERSION).tar.bz2
 GNUPG_SITE = https://gnupg.org/ftp/gcrypt/gnupg
 GNUPG_LICENSE = GPL-3.0+
diff --git a/package/gnupg2/gnupg2.hash b/package/gnupg2/gnupg2.hash
index 155295244e..f5890c5e2a 100644
--- a/package/gnupg2/gnupg2.hash
+++ b/package/gnupg2/gnupg2.hash
@@ -1,6 +1,6 @@
-# From https://lists.gnupg.org/pipermail/gnupg-announce/2018q2/000421.html
-sha1 295298debcc2c12f02a2f2fdf04aecb6d6aae396  gnupg-2.2.6.tar.bz2
+# From https://lists.gnupg.org/pipermail/gnupg-announce/2018q2/000425.html
+sha1 d87553a125832ea90e8aeb3ceeecf24f88de56fb  gnupg-2.2.8.tar.bz2
 # Calculated based on the hash above and signature
-# https://gnupg.org/ftp/gcrypt/gnupg/gnupg-2.2.6.tar.bz2.sig
-sha256 e64d8c5fa2d05938a5080cb784a98ac21be0812f2a26f844b18f0d6a0e711984  gnupg-2.2.6.tar.bz2
+# https://gnupg.org/ftp/gcrypt/gnupg/gnupg-2.2.8.tar.bz2.sig
+sha256 777b4cb8ced21965a5053d4fa20fe11484f0a478f3d011cef508a1a49db50dcd  gnupg-2.2.8.tar.bz2
 sha256 bc2d6664f6276fa0a72d57633b3ae68dc7dcb677b71018bf08c8e93e509f1357  COPYING
diff --git a/package/gnupg2/gnupg2.mk b/package/gnupg2/gnupg2.mk
index 4d84bfbb9e..3151860f37 100644
--- a/package/gnupg2/gnupg2.mk
+++ b/package/gnupg2/gnupg2.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-GNUPG2_VERSION = 2.2.6
+GNUPG2_VERSION = 2.2.8
 GNUPG2_SOURCE = gnupg-$(GNUPG2_VERSION).tar.bz2
 GNUPG2_SITE = https://gnupg.org/ftp/gcrypt/gnupg
 GNUPG2_LICENSE = GPL-3.0+
diff --git a/package/gstreamer1/gst1-plugins-bad/gst1-plugins-bad.mk b/package/gstreamer1/gst1-plugins-bad/gst1-plugins-bad.mk
index 83cb94be81..b041014f81 100644
--- a/package/gstreamer1/gst1-plugins-bad/gst1-plugins-bad.mk
+++ b/package/gstreamer1/gst1-plugins-bad/gst1-plugins-bad.mk
@@ -8,10 +8,10 @@ GST1_PLUGINS_BAD_VERSION = 1.12.4
 GST1_PLUGINS_BAD_SOURCE = gst-plugins-bad-$(GST1_PLUGINS_BAD_VERSION).tar.xz
 GST1_PLUGINS_BAD_SITE = https://gstreamer.freedesktop.org/src/gst-plugins-bad
 GST1_PLUGINS_BAD_INSTALL_STAGING = YES
-GST1_PLUGINS_BAD_LICENSE_FILES = COPYING COPYING.LIB
-# Unknown and GPL licensed plugins will append to GST1_PLUGINS_BAD_LICENSE if
-# enabled.
-GST1_PLUGINS_BAD_LICENSE = LGPL-2.0+, LGPL-2.1+
+# Additional plugin licenses will be appended to GST1_PLUGINS_BAD_LICENSE and
+# GST1_PLUGINS_BAD_LICENSE_FILES if enabled.
+GST1_PLUGINS_BAD_LICENSE_FILES = COPYING.LIB
+GST1_PLUGINS_BAD_LICENSE := LGPL-2.0+, LGPL-2.1+
 
 GST1_PLUGINS_BAD_CONF_OPTS = \
 	--disable-examples \
@@ -198,7 +198,6 @@ endif
 
 ifeq ($(BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_AUDIOVISUALIZERS),y)
 GST1_PLUGINS_BAD_CONF_OPTS += --enable-audiovisualizers
-GST1_PLUGINS_BAD_HAS_GPL_LICENSE = y
 else
 GST1_PLUGINS_BAD_CONF_OPTS += --disable-audiovisualizers
 endif
@@ -379,7 +378,7 @@ else
 GST1_PLUGINS_BAD_CONF_OPTS += --disable-mxf
 endif
 
-ifeq ($(BR2_PACKAGE_GST1_PLUGINS_BAD_NETSIM),y)
+ifeq ($(BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_NETSIM),y)
 GST1_PLUGINS_BAD_CONF_OPTS += --enable-netsim
 else
 GST1_PLUGINS_BAD_CONF_OPTS += --disable-netsim
@@ -514,6 +513,7 @@ endif
 
 ifeq ($(BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_YADIF),y)
 GST1_PLUGINS_BAD_CONF_OPTS += --enable-yadif
+GST1_PLUGINS_BAD_HAS_GPL_LICENSE = y
 else
 GST1_PLUGINS_BAD_CONF_OPTS += --disable-yadif
 endif
@@ -585,7 +585,6 @@ endif
 ifeq ($(BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_FDK_AAC),y)
 GST1_PLUGINS_BAD_CONF_OPTS += --enable-fdk_aac
 GST1_PLUGINS_BAD_DEPENDENCIES += fdk-aac
-GST1_PLUGINS_BAD_HAS_UNKNOWN_LICENSE = y
 else
 GST1_PLUGINS_BAD_CONF_OPTS += --disable-fdk_aac
 endif
@@ -632,6 +631,7 @@ endif
 ifeq ($(BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DTLS),y)
 GST1_PLUGINS_BAD_CONF_OPTS += --enable-dtls
 GST1_PLUGINS_BAD_DEPENDENCIES += openssl
+GST1_PLUGINS_BAD_HAS_BSD2C_LICENSE = y
 else
 GST1_PLUGINS_BAD_CONF_OPTS += --disable-dtls
 endif
@@ -682,6 +682,7 @@ endif
 ifeq ($(BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_OPENH264),y)
 GST1_PLUGINS_BAD_CONF_OPTS += --enable-openh264
 GST1_PLUGINS_BAD_DEPENDENCIES += libopenh264
+GST1_PLUGINS_BAD_HAS_BSD2C_LICENSE = y
 else
 GST1_PLUGINS_BAD_CONF_OPTS += --disable-openh264
 endif
@@ -771,12 +772,18 @@ endif
 
 # Add GPL license if GPL licensed plugins enabled.
 ifeq ($(GST1_PLUGINS_BAD_HAS_GPL_LICENSE),y)
-GST1_PLUGINS_BAD_LICENSE += GPL
+GST1_PLUGINS_BAD_LICENSE := $(GST1_PLUGINS_BAD_LICENSE), GPL-2.0+
+GST1_PLUGINS_BAD_LICENSE_FILES += COPYING
+endif
+
+# Add BSD license if BSD licensed plugins enabled.
+ifeq ($(GST1_PLUGINS_BAD_HAS_BSD2C_LICENSE),y)
+GST1_PLUGINS_BAD_LICENSE := $(GST1_PLUGINS_BAD_LICENSE), BSD-2-Clause
 endif
 
 # Add Unknown license if Unknown licensed plugins enabled.
 ifeq ($(GST1_PLUGINS_BAD_HAS_UNKNOWN_LICENSE),y)
-GST1_PLUGINS_BAD_LICENSE += UNKNOWN
+GST1_PLUGINS_BAD_LICENSE := $(GST1_PLUGINS_BAD_LICENSE), UNKNOWN
 endif
 
 # Use the following command to extract license info for plugins.
diff --git a/package/imagemagick/imagemagick.hash b/package/imagemagick/imagemagick.hash
index 170231c4b7..cf529b597c 100644
--- a/package/imagemagick/imagemagick.hash
+++ b/package/imagemagick/imagemagick.hash
@@ -1,3 +1,3 @@
 # Locally computed
-sha256 723a28f9cbc5c6130f496065fc01c839083e97bf3e4930f940a03c0155046170  7.0.7-27.tar.gz
+sha256 ac957ef303fb870cb92331947ebcdcef5b553e80c7897c0aec866889f35e1a23  7.0.7-38.tar.gz
 sha256 2318cc05bbd2c25c1b2d13af1aadccc45b9cf6f94757421ae59a3c8ea9064f1c  LICENSE
diff --git a/package/imagemagick/imagemagick.mk b/package/imagemagick/imagemagick.mk
index 116543888b..4aa9d56db2 100644
--- a/package/imagemagick/imagemagick.mk
+++ b/package/imagemagick/imagemagick.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-IMAGEMAGICK_VERSION = 7.0.7-27
+IMAGEMAGICK_VERSION = 7.0.7-38
 IMAGEMAGICK_SOURCE = $(IMAGEMAGICK_VERSION).tar.gz
 IMAGEMAGICK_SITE = https://github.com/ImageMagick/ImageMagick/archive
 IMAGEMAGICK_LICENSE = Apache-2.0
diff --git a/package/jamvm/Config.in b/package/jamvm/Config.in
index 57e1a8e6f4..7717ccaadb 100644
--- a/package/jamvm/Config.in
+++ b/package/jamvm/Config.in
@@ -1,10 +1,17 @@
+config BR2_PACKAGE_JAMVM_ARCH_SUPPORTS
+	bool
+	default y if BR2_arm || BR2_armeb
+	default y if BR2_i386 || BR2_x86_64
+	default y if (BR2_mips || BR2_mipsel) \
+		&& (BR2_MIPS_FP32_MODE_32 || BR2_MIPS_SOFT_FLOAT)
+	default y if BR2_powerpc
+
 config BR2_PACKAGE_JAMVM
 	bool "jamvm"
+	depends on BR2_PACKAGE_JAMVM_ARCH_SUPPORTS
+	depends on BR2_PACKAGE_CLASSPATH_ARCH_SUPPORTS
 	depends on BR2_TOOLCHAIN_HAS_THREADS
 	depends on !BR2_STATIC_LIBS
-	depends on BR2_arm || BR2_armeb || BR2_i386 || BR2_x86_64 \
-		|| BR2_mips || BR2_mipsel || BR2_powerpc
-	depends on BR2_PACKAGE_CLASSPATH_ARCH_SUPPORTS
 	select BR2_PACKAGE_ZLIB
 	select BR2_PACKAGE_CLASSPATH
 	help
@@ -14,7 +21,6 @@ config BR2_PACKAGE_JAMVM
 	  http://jamvm.sf.net
 
 comment "jamvm needs a toolchain w/ threads, dynamic library"
-	depends on BR2_arm || BR2_armeb || BR2_i386 || BR2_x86_64 \
-		|| BR2_mips || BR2_mipsel || BR2_powerpc
+	depends on BR2_PACKAGE_JAMVM_ARCH_SUPPORTS
 	depends on BR2_PACKAGE_CLASSPATH_ARCH_SUPPORTS
 	depends on !BR2_TOOLCHAIN_HAS_THREADS || BR2_STATIC_LIBS
diff --git a/package/jpeg-turbo/jpeg-turbo.hash b/package/jpeg-turbo/jpeg-turbo.hash
index 320bbb2a94..11b323b8bf 100644
--- a/package/jpeg-turbo/jpeg-turbo.hash
+++ b/package/jpeg-turbo/jpeg-turbo.hash
@@ -3,3 +3,5 @@ sha1 e788f6defa58b4393a5e1685c018f3b962971457  libjpeg-turbo-1.5.2.tar.gz
 md5 6b4923e297a7eaa255f08511017a8818  libjpeg-turbo-1.5.2.tar.gz
 # Locally computed
 sha256 9098943b270388727ae61de82adec73cf9f0dbb240b3bc8b172595ebf405b528  libjpeg-turbo-1.5.2.tar.gz
+sha256 5c08657eda60b7946a913ee22ac73603335a468a6aa95204506a1586a8d677ee  LICENSE.md
+sha256 53a3e3c299e08856964f4c5986e242c3695837b73c64625092f70c774e8af5d2  README.ijg
diff --git a/package/jpeg-turbo/jpeg-turbo.mk b/package/jpeg-turbo/jpeg-turbo.mk
index bb1278f8b2..d52ab916e0 100644
--- a/package/jpeg-turbo/jpeg-turbo.mk
+++ b/package/jpeg-turbo/jpeg-turbo.mk
@@ -7,8 +7,8 @@
 JPEG_TURBO_VERSION = 1.5.2
 JPEG_TURBO_SOURCE = libjpeg-turbo-$(JPEG_TURBO_VERSION).tar.gz
 JPEG_TURBO_SITE = https://downloads.sourceforge.net/project/libjpeg-turbo/$(JPEG_TURBO_VERSION)
-JPEG_TURBO_LICENSE = jpeg-license (BSD-3-Clause-like)
-JPEG_TURBO_LICENSE_FILES = LICENSE.md
+JPEG_TURBO_LICENSE = IJG (libjpeg), BSD-3-Clause (TurboJPEG), Zlib (SIMD)
+JPEG_TURBO_LICENSE_FILES = LICENSE.md README.ijg
 JPEG_TURBO_INSTALL_STAGING = YES
 JPEG_TURBO_PROVIDES = jpeg
 JPEG_TURBO_DEPENDENCIES = host-pkgconf
diff --git a/package/libcap/libcap.hash b/package/libcap/libcap.hash
index a1dcd62b3c..2d3aee591d 100644
--- a/package/libcap/libcap.hash
+++ b/package/libcap/libcap.hash
@@ -1,2 +1,5 @@
 # https://www.kernel.org/pub/linux/libs/security/linux-privs/libcap2/sha256sums.asc
 sha256	693c8ac51e983ee678205571ef272439d83afe62dd8e424ea14ad9790bc35162  libcap-2.25.tar.xz
+
+# Hash for license file:
+sha256	088cabde4662b4121258d298b0b2967bc1abffa134457ed9bc4a359685ab92bc  License
diff --git a/package/libcap/libcap.mk b/package/libcap/libcap.mk
index 48c2cb3456..a947fa0686 100644
--- a/package/libcap/libcap.mk
+++ b/package/libcap/libcap.mk
@@ -18,6 +18,9 @@ HOST_LIBCAP_DEPENDENCIES = host-gperf
 ifeq ($(BR2_STATIC_LIBS),y)
 LIBCAP_MAKE_TARGET = libcap.a libcap.pc
 LIBCAP_MAKE_INSTALL_TARGET = install-static
+else ifeq ($(BR2_SHARED_LIBS),y)
+LIBCAP_MAKE_TARGET = all
+LIBCAP_MAKE_INSTALL_TARGET = install-shared
 else
 LIBCAP_MAKE_TARGET = all
 LIBCAP_MAKE_INSTALL_TARGET = install
diff --git a/package/libcoap/libcoap.mk b/package/libcoap/libcoap.mk
index 31a6822dd3..4f87886ba0 100644
--- a/package/libcoap/libcoap.mk
+++ b/package/libcoap/libcoap.mk
@@ -9,6 +9,7 @@ LIBCOAP_SITE = $(call github,obgm,libcoap,$(LIBCOAP_VERSION))
 LIBCOAP_INSTALL_STAGING = YES
 LIBCOAP_LICENSE = GPL-2.0+ or BSD-2-Clause
 LIBCOAP_LICENSE_FILES = COPYING LICENSE.GPL LICENSE.BSD
+LIBCOAP_DEPENDENCIES = host-pkgconf
 LIBCOAP_CONF_OPTS = --disable-examples
 LIBCOAP_AUTORECONF = YES
 
diff --git a/package/libcurl/0001-Fix-link-with-ssh2-built-with-a-static-mbedtls.patch b/package/libcurl/0001-Fix-link-with-ssh2-built-with-a-static-mbedtls.patch
new file mode 100644
index 0000000000..9107fa7c8c
--- /dev/null
+++ b/package/libcurl/0001-Fix-link-with-ssh2-built-with-a-static-mbedtls.patch
@@ -0,0 +1,40 @@
+From b5fbc486e805805efb8400373ccec2a3dee1c81b Mon Sep 17 00:00:00 2001
+From: Fabrice Fontaine <fontaine.fabrice@gmail.com>
+Date: Mon, 21 May 2018 12:07:00 +0200
+Subject: [PATCH 1/1] Fix link with ssh2 built with a static mbedtls
+
+The ssh2 pkg-config file could contain the following lines when build
+with a static version of mbedtls:
+   Libs: -L${libdir} -lssh2 /xxx/libmbedcrypto.a
+   Libs.private: /xxx/libmbedcrypto.a
+
+This static mbedtls library must be used to correctly detect ssh2
+support and this library must be copied in libcurl.pc otherwise
+compilation of any application (such as upmpdcli) with libcurl will fail
+when trying to found mbedtls functions included in libssh2.
+So, replace pkg-config --libs-only-l by pkg-config --libs.
+
+Fixes:
+ - http://autobuild.buildroot.net/results/43e24b22a77f616d6198c10435dcc23cc3b9088a
+
+Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
+---
+ configure.ac | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/configure.ac b/configure.ac
+index 5569a26b4..9e2606885 100755
+--- a/configure.ac
++++ b/configure.ac
+@@ -2766,7 +2766,7 @@ if test X"$OPT_LIBSSH2" != Xno; then
+     CURL_CHECK_PKGCONFIG(libssh2)
+ 
+     if test "$PKGCONFIG" != "no" ; then
+-      LIB_SSH2=`$PKGCONFIG --libs-only-l libssh2`
++      LIB_SSH2=`$PKGCONFIG --libs libssh2`
+       LD_SSH2=`$PKGCONFIG --libs-only-L libssh2`
+       CPP_SSH2=`$PKGCONFIG --cflags-only-I libssh2`
+       version=`$PKGCONFIG --modversion libssh2`
+-- 
+2.14.1
+
diff --git a/package/libcurl/libcurl.hash b/package/libcurl/libcurl.hash
index aec61e3f83..cb1e6e72f2 100644
--- a/package/libcurl/libcurl.hash
+++ b/package/libcurl/libcurl.hash
@@ -1,4 +1,4 @@
 # Locally calculated after checking pgp signature
-# https://curl.haxx.se/download/curl-7.59.0.tar.xz.asc
-sha256 e44eaabdf916407585bf5c7939ff1161e6242b6b015d3f2f5b758b2a330461fc  curl-7.59.0.tar.xz
+# https://curl.haxx.se/download/curl-7.60.0.tar.xz.asc
+sha256 8736ff8ded89ddf7e926eec7b16f82597d029fc1469f3a551f1fafaac164e6a0  curl-7.60.0.tar.xz
 sha256 5f3849ec38ddb927e79f514bf948890c41b8d1407286a49609b8fb1585931095  COPYING
diff --git a/package/libcurl/libcurl.mk b/package/libcurl/libcurl.mk
index c6289e05f4..c77ce79e58 100644
--- a/package/libcurl/libcurl.mk
+++ b/package/libcurl/libcurl.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-LIBCURL_VERSION = 7.59.0
+LIBCURL_VERSION = 7.60.0
 LIBCURL_SOURCE = curl-$(LIBCURL_VERSION).tar.xz
 LIBCURL_SITE = https://curl.haxx.se/download
 LIBCURL_DEPENDENCIES = host-pkgconf \
@@ -14,6 +14,8 @@ LIBCURL_DEPENDENCIES = host-pkgconf \
 LIBCURL_LICENSE = curl
 LIBCURL_LICENSE_FILES = COPYING
 LIBCURL_INSTALL_STAGING = YES
+# We're patching configure.ac
+LIBCURL_AUTORECONF = YES
 
 # We disable NTLM support because it uses fork(), which doesn't work
 # on non-MMU platforms. Moreover, this authentication method is
diff --git a/package/libgcrypt/libgcrypt.hash b/package/libgcrypt/libgcrypt.hash
index 736332d350..dce6522959 100644
--- a/package/libgcrypt/libgcrypt.hash
+++ b/package/libgcrypt/libgcrypt.hash
@@ -1,6 +1,6 @@
-# From https://www.gnupg.org/download/integrity_check.html
-sha1 ab8aae5d7a68f8e0988f90e11e7f6a4805af5c8d  libgcrypt-1.8.2.tar.bz2
+# From https://lists.gnupg.org/pipermail/gnupg-announce/2018q2/000426.html
+sha1 13bd2ce69e59ab538e959911dfae80ea309636e3  libgcrypt-1.8.3.tar.bz2
 # Locally calculated after checking signature
-# https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.2.tar.bz2.sig
-sha256  c8064cae7558144b13ef0eb87093412380efa16c4ee30ad12ecb54886a524c07  libgcrypt-1.8.2.tar.bz2
+# https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.3.tar.bz2.sig
+sha256  66ec90be036747602f2b48f98312361a9180c97c68a690a5f376fa0f67d0af7c  libgcrypt-1.8.3.tar.bz2
 sha256  ca0061fc1381a3ab242310e4b3f56389f28e3d460eb2fd822ed7a21c6f030532  COPYING.LIB
diff --git a/package/libgcrypt/libgcrypt.mk b/package/libgcrypt/libgcrypt.mk
index 00e864e836..f25944da64 100644
--- a/package/libgcrypt/libgcrypt.mk
+++ b/package/libgcrypt/libgcrypt.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-LIBGCRYPT_VERSION = 1.8.2
+LIBGCRYPT_VERSION = 1.8.3
 LIBGCRYPT_SOURCE = libgcrypt-$(LIBGCRYPT_VERSION).tar.bz2
 LIBGCRYPT_LICENSE = LGPL-2.1+
 LIBGCRYPT_LICENSE_FILES = COPYING.LIB
diff --git a/package/libjpeg/libjpeg.mk b/package/libjpeg/libjpeg.mk
index 95663a9e00..36f084bfb5 100644
--- a/package/libjpeg/libjpeg.mk
+++ b/package/libjpeg/libjpeg.mk
@@ -7,7 +7,7 @@
 LIBJPEG_VERSION = 9b
 LIBJPEG_SITE = http://www.ijg.org/files
 LIBJPEG_SOURCE = jpegsrc.v$(LIBJPEG_VERSION).tar.gz
-LIBJPEG_LICENSE = jpeg-license (BSD-3-Clause-like)
+LIBJPEG_LICENSE = IJG
 LIBJPEG_LICENSE_FILES = README
 LIBJPEG_INSTALL_STAGING = YES
 LIBJPEG_PROVIDES = jpeg
diff --git a/package/libnss/0004-Bug-1438426-Avoid-stringop-truncation-warning-r-fran.patch b/package/libnss/0004-Bug-1438426-Avoid-stringop-truncation-warning-r-fran.patch
new file mode 100644
index 0000000000..c14880b117
--- /dev/null
+++ b/package/libnss/0004-Bug-1438426-Avoid-stringop-truncation-warning-r-fran.patch
@@ -0,0 +1,33 @@
+From f0ce70989526fc9a0223398c99ea0d09777ea5df Mon Sep 17 00:00:00 2001
+From: Martin Thomson <martin.thomson@gmail.com>
+Date: Thu, 15 Feb 2018 16:34:02 +1100
+Subject: [PATCH] Bug 1438426 - Avoid stringop-truncation warning, r=franziskus
+
+--HG--
+extra : rebase_source : 4ea1630d0da0ce3523309e3da33ee50961682242
+
+Upstream-commit: https://github.com/nss-dev/nss/commit/f0ce70989526fc9a0223398c99ea0d09777ea5df
+[Thomas: edited after git format-patch to add the nss/ prefix needed
+for the patch to apply properly on the source code extracted by the
+tarball.]
+Signed-off-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ nss/coreconf/nsinstall/pathsub.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/nss/coreconf/nsinstall/pathsub.c b/nss/coreconf/nsinstall/pathsub.c
+index a42a9f30a..c31a946f0 100644
+--- a/nss/coreconf/nsinstall/pathsub.c
++++ b/nss/coreconf/nsinstall/pathsub.c
+@@ -212,7 +212,7 @@ reversepath(char *inpath, char *name, int len, char *outpath)
+ 	    xchdir("..");
+ 	} else {
+ 	    cp -= 3;
+-	    strncpy(cp, "../", 3);
++	    memcpy(cp, "../", 3);
+ 	    xchdir(buf);
+ 	}
+     }
+-- 
+2.14.3
+
diff --git a/package/libressl/libressl.hash b/package/libressl/libressl.hash
index 9d926c677b..555a75cf05 100644
--- a/package/libressl/libressl.hash
+++ b/package/libressl/libressl.hash
@@ -1,2 +1,2 @@
 # From https://ftp.openbsd.org/pub/OpenBSD/LibreSSL/SHA256
-sha256	638a20c2f9e99ee283a841cd787ab4d846d1880e180c4e96904fc327d419d11f	libressl-2.6.4.tar.gz
+sha256	859edfc71019d27c448fe148e679afdd972a0baa91b21f02b2b2f5f8a84ddd2a	libressl-2.6.5.tar.gz
diff --git a/package/libressl/libressl.mk b/package/libressl/libressl.mk
index 2467086161..466b0b831b 100644
--- a/package/libressl/libressl.mk
+++ b/package/libressl/libressl.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-LIBRESSL_VERSION = 2.6.4
+LIBRESSL_VERSION = 2.6.5
 LIBRESSL_SITE = https://ftp.openbsd.org/pub/OpenBSD/LibreSSL
 LIBRESSL_LICENSE = ISC (new additions), OpenSSL or SSLeay (original OpenSSL code)
 LIBRESSL_LICENSE_FILES = COPYING
diff --git a/package/libtirpc/0003-Add-rpcgen-program-from-nfs-utils-sources.patch b/package/libtirpc/0003-Add-rpcgen-program-from-nfs-utils-sources.patch
deleted file mode 100644
index f2b15fe2f1..0000000000
--- a/package/libtirpc/0003-Add-rpcgen-program-from-nfs-utils-sources.patch
+++ /dev/null
@@ -1,6508 +0,0 @@
-From 866b651bcb9f93f47582e5e2e4f1eb3155025298 Mon Sep 17 00:00:00 2001
-From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-Date: Sat, 10 Nov 2012 16:21:01 +0100
-Subject: [PATCH] Add rpcgen program from nfs-utils sources
-
-Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-[yann.morin.1998@free.fr: update for 0.3.1]
-Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
----
- Makefile.am          |    2 +-
- configure.ac         |   14 +-
- rpcgen/Makefile.am   |   22 ++
- rpcgen/rpc_clntout.c |  217 ++++++++++
- rpcgen/rpc_cout.c    |  706 +++++++++++++++++++++++++++++++++
- rpcgen/rpc_hout.c    |  490 +++++++++++++++++++++++
- rpcgen/rpc_main.c    | 1067 ++++++++++++++++++++++++++++++++++++++++++++++++++
- rpcgen/rpc_output.h  |   16 +
- rpcgen/rpc_parse.c   |  609 ++++++++++++++++++++++++++++
- rpcgen/rpc_parse.h   |  166 ++++++++
- rpcgen/rpc_sample.c  |  247 ++++++++++++
- rpcgen/rpc_scan.c    |  474 ++++++++++++++++++++++
- rpcgen/rpc_scan.h    |  103 +++++
- rpcgen/rpc_svcout.c  |  882 +++++++++++++++++++++++++++++++++++++++++
- rpcgen/rpc_tblout.c  |  165 ++++++++
- rpcgen/rpc_util.c    |  479 ++++++++++++++++++++++
- rpcgen/rpc_util.h    |  166 ++++++++
- rpcgen/rpcgen.1      |  521 ++++++++++++++++++++++++
- 18 files changed, 6344 insertions(+), 2 deletions(-)
- create mode 100644 rpcgen/Makefile.am
- create mode 100644 rpcgen/rpc_clntout.c
- create mode 100644 rpcgen/rpc_cout.c
- create mode 100644 rpcgen/rpc_hout.c
- create mode 100644 rpcgen/rpc_main.c
- create mode 100644 rpcgen/rpc_output.h
- create mode 100644 rpcgen/rpc_parse.c
- create mode 100644 rpcgen/rpc_parse.h
- create mode 100644 rpcgen/rpc_sample.c
- create mode 100644 rpcgen/rpc_scan.c
- create mode 100644 rpcgen/rpc_scan.h
- create mode 100644 rpcgen/rpc_svcout.c
- create mode 100644 rpcgen/rpc_tblout.c
- create mode 100644 rpcgen/rpc_util.c
- create mode 100644 rpcgen/rpc_util.h
- create mode 100644 rpcgen/rpcgen.1
-
-diff --git a/Makefile.am b/Makefile.am
-index 466b6dd..8558289 100644
---- a/Makefile.am
-+++ b/Makefile.am
-@@ -1,4 +1,4 @@
--SUBDIRS = src man doc
-+SUBDIRS = src man doc rpcgen
- ACLOCAL_AMFLAGS = -I m4
- 
- noinst_HEADERS	       = tirpc/reentrant.h \
-diff --git a/configure.ac b/configure.ac
-index e3cb8af..0ea2e6e 100644
---- a/configure.ac
-+++ b/configure.ac
-@@ -58,6 +58,18 @@ AC_CHECK_HEADERS([arpa/inet.h fcntl.h libintl.h limits.h locale.h netdb.h netine
- AC_CHECK_LIB([pthread], [pthread_create])
- AC_CHECK_FUNCS([getrpcbyname getrpcbynumber setrpcent endrpcent getrpcent])
- 
--AC_CONFIG_FILES([Makefile src/Makefile man/Makefile doc/Makefile])
-+AM_CONDITIONAL(CROSS_COMPILING, test $cross_compiling = yes)
-+
-+AC_MSG_CHECKING([for a C compiler for build tools])
-+if test $cross_compiling = yes; then
-+   AC_CHECK_PROGS(CC_FOR_BUILD, gcc cc)
-+else
-+   CC_FOR_BUILD=$CC
-+fi
-+AC_MSG_RESULT([$CC_FOR_BUILD])
-+AC_SUBST(CC_FOR_BUILD)
-+
-+AC_CONFIG_FILES([Makefile src/Makefile man/Makefile doc/Makefile rpcgen/Makefile])
-+
- AC_OUTPUT(libtirpc.pc)
- 
-diff --git a/rpcgen/Makefile.am b/rpcgen/Makefile.am
-new file mode 100644
-index 0000000..2277b6f
---- /dev/null
-+++ b/rpcgen/Makefile.am
-@@ -0,0 +1,22 @@
-+COMPILE = $(CC_FOR_BUILD) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) -I../tirpc $(AM_CPPFLAGS) \
-+	$(CPPFLAGS_FOR_BUILD) $(AM_CFLAGS) $(CFLAGS_FOR_BUILD)
-+LINK = $(CC_FOR_BUILD) $(AM_CFLAGS) $(CFLAGS_FOR_BUILD) $(AM_LDFLAGS) $(LDFLAGS_FOR_BUILD) -o $@
-+
-+noinst_PROGRAMS = rpcgen
-+
-+rpcgen_SOURCES = \
-+	rpc_clntout.c \
-+	rpc_cout.c \
-+	rpc_hout.c \
-+	rpc_main.c \
-+	rpc_parse.c \
-+	rpc_sample.c \
-+	rpc_scan.c \
-+	rpc_svcout.c \
-+	rpc_tblout.c \
-+	rpc_util.c \
-+	rpc_parse.h \
-+	rpc_scan.h \
-+	rpc_util.h
-+
-+dist_man1_MANS = rpcgen.1
-diff --git a/rpcgen/rpc_clntout.c b/rpcgen/rpc_clntout.c
-new file mode 100644
-index 0000000..e2f4382
---- /dev/null
-+++ b/rpcgen/rpc_clntout.c
-@@ -0,0 +1,217 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_clntout.c 1.11 89/02/22 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_clntout.c, Client-stub outputter for the RPC protocol compiler
-+ * Copyright (C) 1987, Sun Microsytsems, Inc.
-+ */
-+#include <stdio.h>
-+#include <string.h>
-+#include <rpc/types.h>
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+#include "rpc_output.h"
-+
-+/* extern pdeclaration(); */
-+/* void printarglist(); */
-+
-+#define DEFAULT_TIMEOUT 25	/* in seconds */
-+static char RESULT[] = "clnt_res";
-+
-+static void	write_program(definition *def);
-+static void	printbody(proc_list *proc);
-+
-+
-+void
-+write_stubs(void)
-+{
-+	list *l;
-+	definition *def;
-+
-+	f_print(fout, 
-+		"\n/* Default timeout can be changed using clnt_control() */\n");
-+	f_print(fout, "static struct timeval TIMEOUT = { %d, 0 };\n",
-+		DEFAULT_TIMEOUT);
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind == DEF_PROGRAM) {
-+			write_program(def);
-+		}
-+	}
-+}
-+
-+static void
-+write_program(definition *def)
-+{
-+	version_list   *vp;
-+	proc_list      *proc;
-+
-+	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+		for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+			f_print(fout, "\n");
-+			ptype(proc->res_prefix, proc->res_type, 1);
-+			f_print(fout, "*\n");
-+			pvname(proc->proc_name, vp->vers_num);
-+			printarglist(proc, "clnt", "CLIENT *");
-+			f_print(fout, "{\n");
-+			printbody(proc);
-+			f_print(fout, "}\n");
-+		}
-+	}
-+}
-+
-+/*
-+ * Writes out declarations of procedure's argument list.
-+ * In either ANSI C style, in one of old rpcgen style (pass by reference),
-+ * or new rpcgen style (multiple arguments, pass by value);
-+ */
-+
-+/* sample addargname = "clnt"; sample addargtype = "CLIENT * " */
-+
-+void
-+printarglist(proc_list *proc, char *addargname, char *addargtype)
-+{
-+
-+	decl_list      *l;
-+
-+	if (!newstyle) {	/* old style: always pass arg by reference */
-+		if (Cflag) {	/* C++ style heading */
-+			f_print(fout, "(");
-+			ptype(proc->args.decls->decl.prefix, proc->args.decls->decl.type, 1);
-+			f_print(fout, "*argp, %s%s)\n", addargtype, addargname);
-+		} else {
-+			f_print(fout, "(argp, %s)\n", addargname);
-+			f_print(fout, "\t");
-+			ptype(proc->args.decls->decl.prefix, proc->args.decls->decl.type, 1);
-+			f_print(fout, "*argp;\n");
-+		}
-+	} else if (streq(proc->args.decls->decl.type, "void")) {
-+		/* newstyle, 0 argument */
-+		if (Cflag)
-+			f_print(fout, "(%s%s)\n", addargtype, addargname);
-+		else
-+			f_print(fout, "(%s)\n", addargname);
-+	} else {
-+		/* new style, 1 or multiple arguments */
-+		if (!Cflag) {
-+			f_print(fout, "(");
-+			for (l = proc->args.decls; l != NULL; l = l->next)
-+				f_print(fout, "%s, ", l->decl.name);
-+			f_print(fout, "%s)\n", addargname);
-+			for (l = proc->args.decls; l != NULL; l = l->next) {
-+				pdeclaration(proc->args.argname, &l->decl, 1, ";\n");
-+			}
-+		} else {	/* C++ style header */
-+			f_print(fout, "(");
-+			for (l = proc->args.decls; l != NULL; l = l->next) {
-+				pdeclaration(proc->args.argname, &l->decl, 0, ", ");
-+			}
-+			f_print(fout, " %s%s)\n", addargtype, addargname);
-+		}
-+	}
-+
-+	if (!Cflag)
-+		f_print(fout, "\t%s%s;\n", addargtype, addargname);
-+}
-+
-+
-+
-+static char *
-+ampr(char *type)
-+{
-+	if (isvectordef(type, REL_ALIAS)) {
-+		return ("");
-+	} else {
-+		return ("&");
-+	}
-+}
-+
-+static void
-+printbody(proc_list *proc)
-+{
-+	decl_list      *l;
-+	bool_t          args2 = (proc->arg_num > 1);
-+
-+	/* For new style with multiple arguments, need a structure in which
-+         * to stuff the arguments. */
-+	if (newstyle && args2) {
-+		f_print(fout, "\t%s", proc->args.argname);
-+		f_print(fout, " arg;\n");
-+	}
-+	f_print(fout, "\tstatic ");
-+	if (streq(proc->res_type, "void")) {
-+		f_print(fout, "char ");
-+	} else {
-+		ptype(proc->res_prefix, proc->res_type, 0);
-+	}
-+	f_print(fout, "%s;\n", RESULT);
-+	f_print(fout, "\n");
-+	f_print(fout, "\tmemset((char *)%s%s, 0, sizeof(%s));\n",
-+		ampr(proc->res_type), RESULT, RESULT);
-+	if (newstyle && !args2 && (streq(proc->args.decls->decl.type, "void"))) {
-+		/* newstyle, 0 arguments */
-+		f_print(fout,
-+			"\tif (clnt_call(clnt, %s, (xdrproc_t) xdr_void, (caddr_t) NULL, "
-+			"(xdrproc_t) xdr_%s, (caddr_t) %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
-+			proc->proc_name,
-+			stringfix(proc->res_type), ampr(proc->res_type), RESULT);
-+
-+	} else if (newstyle && args2) {
-+		/* newstyle, multiple arguments:  stuff arguments into structure */
-+		for (l = proc->args.decls; l != NULL; l = l->next) {
-+			f_print(fout, "\targ.%s = %s;\n",
-+				l->decl.name, l->decl.name);
-+		}
-+		f_print(fout,
-+			"\tif (clnt_call(clnt, %s, (xdrproc_t) xdr_%s, (caddr_t) &arg, "
-+			"(xdrproc_t) xdr_%s, (caddr_t) %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
-+			proc->proc_name, proc->args.argname,
-+			stringfix(proc->res_type), ampr(proc->res_type), RESULT);
-+	} else {		/* single argument, new or old style */
-+		f_print(fout,
-+			"\tif (clnt_call(clnt, %s, (xdrproc_t) xdr_%s, "
-+			"(caddr_t) %s%s, (xdrproc_t) xdr_%s, (caddr_t) %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
-+			proc->proc_name,
-+			stringfix(proc->args.decls->decl.type),
-+			(newstyle ? "&" : ""),
-+			(newstyle ? proc->args.decls->decl.name : "argp"),
-+			stringfix(proc->res_type), ampr(proc->res_type), RESULT);
-+	}
-+	f_print(fout, "\t\treturn (NULL);\n");
-+	f_print(fout, "\t}\n");
-+	if (streq(proc->res_type, "void")) {
-+		f_print(fout, "\treturn ((void *)%s%s);\n",
-+			ampr(proc->res_type), RESULT);
-+	} else {
-+		f_print(fout, "\treturn (%s%s);\n", ampr(proc->res_type), RESULT);
-+	}
-+}
-diff --git a/rpcgen/rpc_cout.c b/rpcgen/rpc_cout.c
-new file mode 100644
-index 0000000..a61214f
---- /dev/null
-+++ b/rpcgen/rpc_cout.c
-@@ -0,0 +1,706 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_cout.c 1.13 89/02/22 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_cout.c, XDR routine outputter for the RPC protocol compiler 
-+ */
-+#include <stdio.h>
-+#include <string.h>
-+#include <stdlib.h>
-+#include <malloc.h>
-+#include <ctype.h>
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+
-+static int	findtype(definition *def, char *type);
-+static int	undefined(char *type);
-+static void	print_generic_header(char *procname, int pointerp);
-+static void	print_header(definition *def);
-+static void	print_prog_header(proc_list *plist);
-+static void	print_trailer(void);
-+static void	print_ifopen(int indent, char *name);
-+static void	print_ifarg(char *arg);
-+static void	print_ifsizeof(char *prefix, char *type);
-+static void	print_ifclose(int indent);
-+static void	print_ifstat(int indent, char *prefix, char *type, relation rel,
-+			char *amax, char *objname, char *name);
-+static void	emit_enum(definition *def);
-+static void	emit_program(definition *def);
-+static void	emit_union(definition *def);
-+static void	emit_struct(definition *def);
-+static void	emit_typedef(definition *def);
-+static void	print_stat(int indent, declaration *dec);
-+static void	emit_inline(declaration *decl, int flag);
-+static void	emit_single_in_line(declaration *decl, int flag, relation rel);
-+static char *	upcase(char *str);
-+
-+/*
-+ * Emit the C-routine for the given definition 
-+ */
-+void
-+emit(definition *def)
-+{
-+	if (def->def_kind == DEF_CONST) {
-+		return;
-+	}
-+	if (def->def_kind == DEF_PROGRAM) {
-+		emit_program(def);
-+		return;
-+	}
-+	if (def->def_kind == DEF_TYPEDEF) {
-+		/* now we need to handle declarations like
-+		 * struct typedef foo foo;
-+		 * since we dont want this to be expanded into 2 calls
-+		 * to xdr_foo */
-+
-+		if (strcmp(def->def.ty.old_type, def->def_name) == 0)
-+			return;
-+	};
-+
-+	print_header(def);
-+	switch (def->def_kind) {
-+	case DEF_UNION:
-+		emit_union(def);
-+		break;
-+	case DEF_ENUM:
-+		emit_enum(def);
-+		break;
-+	case DEF_STRUCT:
-+		emit_struct(def);
-+		break;
-+	case DEF_TYPEDEF:
-+		emit_typedef(def);
-+		break;
-+	default:
-+		break;
-+	}
-+	print_trailer();
-+}
-+
-+static int
-+findtype(definition *def, char *type)
-+{
-+
-+	if (def->def_kind == DEF_PROGRAM || def->def_kind == DEF_CONST) {
-+		return (0);
-+	} else {
-+		return (streq(def->def_name, type));
-+	}
-+}
-+
-+static int
-+undefined(char *type)
-+{
-+	definition     *def;
-+
-+	def = (definition *) FINDVAL(defined, type, findtype);
-+
-+	return (def == NULL);
-+}
-+
-+
-+static void
-+print_generic_header(char *procname, int pointerp)
-+{
-+	f_print(fout, "\n");
-+	f_print(fout, "bool_t\n");
-+	if (Cflag) {
-+		f_print(fout, "xdr_%s(", procname);
-+		f_print(fout, "XDR *xdrs, ");
-+		f_print(fout, "%s ", procname);
-+		if (pointerp)
-+			f_print(fout, "*");
-+		f_print(fout, "objp)\n{\n\n");
-+	} else {
-+		f_print(fout, "xdr_%s(xdrs, objp)\n", procname);
-+		f_print(fout, "\tXDR *xdrs;\n");
-+		f_print(fout, "\t%s ", procname);
-+		if (pointerp)
-+			f_print(fout, "*");
-+		f_print(fout, "objp;\n{\n\n");
-+	}
-+}
-+
-+static void
-+print_header(definition *def)
-+{
-+	print_generic_header(def->def_name,
-+		def->def_kind != DEF_TYPEDEF ||
-+		!isvectordef(def->def.ty.old_type, def->def.ty.rel));
-+
-+	/* Now add Inline support */
-+
-+
-+	if (Inline == 0)
-+		return;
-+}
-+
-+static void
-+print_prog_header(proc_list *plist)
-+{
-+	print_generic_header(plist->args.argname, 1);
-+}
-+
-+static void
-+print_trailer(void)
-+{
-+	f_print(fout, "\treturn (TRUE);\n");
-+	f_print(fout, "}\n");
-+}
-+
-+
-+static void
-+print_ifopen(int indent, char *name)
-+{
-+	tabify(fout, indent);
-+	f_print(fout, " if (!xdr_%s(xdrs", name);
-+}
-+
-+static void
-+print_ifarg(char *arg)
-+{
-+	f_print(fout, ", %s", arg);
-+}
-+
-+static void
-+print_ifsizeof(char *prefix, char *type)
-+{
-+	if (streq(type, "bool")) {
-+		f_print(fout, ", sizeof(bool_t), (xdrproc_t)xdr_bool");
-+	} else {
-+		f_print(fout, ", sizeof(");
-+		if (undefined(type) && prefix) {
-+			f_print(fout, "%s ", prefix);
-+		}
-+		f_print(fout, "%s), (xdrproc_t)xdr_%s", type, type);
-+	}
-+}
-+
-+static void
-+print_ifclose(int indent)
-+{
-+	f_print(fout, ")) {\n");
-+	tabify(fout, indent);
-+	f_print(fout, "\t return (FALSE);\n");
-+	tabify(fout, indent);
-+	f_print(fout, " }\n");
-+}
-+
-+static void
-+print_ifstat(int indent, char *prefix, char *type, relation rel,
-+			char *amax, char *objname, char *name)
-+{
-+	char *alt = NULL;
-+
-+	switch (rel) {
-+	case REL_POINTER:
-+		print_ifopen(indent, "pointer");
-+		print_ifarg("(char **)");
-+		f_print(fout, "%s", objname);
-+		print_ifsizeof(prefix, type);
-+		break;
-+	case REL_VECTOR:
-+		if (streq(type, "string")) {
-+			alt = "string";
-+		} else if (streq(type, "opaque")) {
-+			alt = "opaque";
-+		}
-+		if (alt) {
-+			print_ifopen(indent, alt);
-+			print_ifarg(objname);
-+		} else {
-+			print_ifopen(indent, "vector");
-+			print_ifarg("(char *)");
-+			f_print(fout, "%s", objname);
-+		}
-+		print_ifarg(amax);
-+		if (!alt) {
-+			print_ifsizeof(prefix, type);
-+		}
-+		break;
-+	case REL_ARRAY:
-+		if (streq(type, "string")) {
-+			alt = "string";
-+		} else if (streq(type, "opaque")) {
-+			alt = "bytes";
-+		}
-+		if (streq(type, "string")) {
-+			print_ifopen(indent, alt);
-+			print_ifarg(objname);
-+		} else {
-+			if (alt) {
-+				print_ifopen(indent, alt);
-+			} else {
-+				print_ifopen(indent, "array");
-+			}
-+			/* The (void*) avoids a gcc-4.1 warning */
-+			print_ifarg("(char **)(void*)");
-+			if (*objname == '&') {
-+				f_print(fout, "%s.%s_val, (u_int *)%s.%s_len",
-+					objname, name, objname, name);
-+			} else {
-+				f_print(fout, "&%s->%s_val, (u_int *)&%s->%s_len",
-+					objname, name, objname, name);
-+			}
-+		}
-+		print_ifarg(amax);
-+		if (!alt) {
-+			print_ifsizeof(prefix, type);
-+		}
-+		break;
-+	case REL_ALIAS:
-+		print_ifopen(indent, type);
-+		print_ifarg(objname);
-+		break;
-+	}
-+	print_ifclose(indent);
-+}
-+
-+static void
-+emit_enum(definition *def)
-+{
-+	print_ifopen(1, "enum");
-+	print_ifarg("(enum_t *)objp");
-+	print_ifclose(1);
-+}
-+
-+static void
-+emit_program(definition *def)
-+{
-+	decl_list      *dl;
-+	version_list   *vlist;
-+	proc_list      *plist;
-+
-+	for (vlist = def->def.pr.versions; vlist != NULL; vlist = vlist->next)
-+		for (plist = vlist->procs; plist != NULL; plist = plist->next) {
-+			if (!newstyle || plist->arg_num < 2)
-+				continue;/* old style, or single argument */
-+			print_prog_header(plist);
-+			for (dl = plist->args.decls; dl != NULL; dl = dl->next)
-+				print_stat(1, &dl->decl);
-+			print_trailer();
-+		}
-+}
-+
-+
-+static void
-+emit_union(definition *def)
-+{
-+  declaration *dflt;
-+  case_list *cl;
-+  declaration *cs;
-+  char *object;
-+  char *vecformat = "objp->%s_u.%s";
-+  char *format = "&objp->%s_u.%s";
-+
-+  print_stat(1,&def->def.un.enum_decl);
-+  f_print(fout, "\tswitch (objp->%s) {\n", def->def.un.enum_decl.name);
-+  for (cl = def->def.un.cases; cl != NULL; cl = cl->next) {
-+
-+    f_print(fout, "\tcase %s:\n", cl->case_name);
-+    if(cl->contflag == 1)	/* a continued case statement */
-+      continue;
-+    cs = &cl->case_decl;
-+    if (!streq(cs->type, "void")) {
-+      object = alloc(strlen(def->def_name) + strlen(format) +
-+		     strlen(cs->name) + 1);
-+      if (isvectordef (cs->type, cs->rel)) {
-+	s_print(object, vecformat, def->def_name, 
-+		cs->name);
-+      } else {
-+	s_print(object, format, def->def_name, 
-+		cs->name);
-+      }
-+      print_ifstat(2, cs->prefix, cs->type, cs->rel, cs->array_max,
-+		   object, cs->name);
-+      free(object);
-+    }
-+    f_print(fout, "\t\tbreak;\n");
-+  }
-+  dflt = def->def.un.default_decl;
-+  if (dflt != NULL) {
-+    if (!streq(dflt->type, "void")) {
-+      f_print(fout, "\tdefault:\n");
-+      object = alloc(strlen(def->def_name) + strlen(format) +
-+		     strlen(dflt->name) + 1);
-+      if (isvectordef (dflt->type, dflt->rel)) {
-+	s_print(object, vecformat, def->def_name, 
-+		dflt->name);
-+      } else {
-+	s_print(object, format, def->def_name, 
-+		dflt->name);
-+      }
-+
-+      print_ifstat(2, dflt->prefix, dflt->type, dflt->rel,
-+		   dflt->array_max, object, dflt->name);
-+      free(object);
-+      f_print(fout, "\t\tbreak;\n");
-+    } else {
-+      /* Avoid gcc warnings about `value not handled in switch' */
-+      f_print(fout, "\tdefault:\n");
-+      f_print(fout, "\t\tbreak;\n");
-+    }
-+  } else {
-+    f_print(fout, "\tdefault:\n");
-+    f_print(fout, "\t\treturn (FALSE);\n");
-+  }
-+
-+  f_print(fout, "\t}\n");
-+}
-+
-+static void
-+emit_struct(definition *def)
-+{
-+	decl_list      *dl;
-+	int             i, j, size, flag;
-+	decl_list      *cur = NULL, *psav;
-+	bas_type       *ptr;
-+	char           *sizestr, *plus;
-+	char            ptemp[256];
-+	int             can_inline;
-+	const char	*buf_declaration;
-+
-+
-+	if (Inline == 0) {
-+		for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
-+			print_stat(1, &dl->decl);
-+	} else {
-+		size = 0;
-+		can_inline = 0;
-+		for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
-+			if ((dl->decl.prefix == NULL) && ((ptr = find_type(dl->decl.type)) != NULL) && ((dl->decl.rel == REL_ALIAS) || (dl->decl.rel == REL_VECTOR))) {
-+
-+				if (dl->decl.rel == REL_ALIAS)
-+					size += ptr->length;
-+				else {
-+					can_inline = 1;
-+					break;	/* can be inlined */
-+				};
-+			} else {
-+				if (size >= Inline) {
-+					can_inline = 1;
-+					break;	/* can be inlined */
-+				}
-+				size = 0;
-+			}
-+		if (size > Inline)
-+			can_inline = 1;
-+
-+		if (can_inline == 0) {	/* can not inline, drop back to old mode */
-+			for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
-+				print_stat(1, &dl->decl);
-+			return;
-+		};
-+
-+
-+
-+
-+		flag = PUT;
-+		for (j = 0; j < 2; j++) {
-+
-+			if (flag == PUT)
-+				f_print(fout, "\n\t if (xdrs->x_op == XDR_ENCODE) {\n");
-+			else
-+				f_print(fout, "\n \t return (TRUE);\n\t} else if (xdrs->x_op == XDR_DECODE) {\n");
-+
-+
-+			i = 0;
-+			size = 0;
-+			sizestr = NULL;
-+			buf_declaration = "int32_t *";
-+			for (dl = def->def.st.decls; dl != NULL; dl = dl->next) {	/* xxx */
-+
-+				/* now walk down the list and check for basic types */
-+				if ((dl->decl.prefix == NULL) && ((ptr = find_type(dl->decl.type)) != NULL) && ((dl->decl.rel == REL_ALIAS) || (dl->decl.rel == REL_VECTOR))) {
-+					if (i == 0)
-+						cur = dl;
-+					i++;
-+
-+					if (dl->decl.rel == REL_ALIAS)
-+						size += ptr->length;
-+					else {
-+						/* this is required to handle arrays */
-+
-+						if (sizestr == NULL)
-+							plus = " ";
-+						else
-+							plus = "+";
-+
-+						if (ptr->length != 1)
-+							s_print(ptemp, " %s %s * %d", plus, dl->decl.array_max, ptr->length);
-+						else
-+							s_print(ptemp, " %s %s ", plus, dl->decl.array_max);
-+
-+						/*now concatenate to sizestr !!!! */
-+						if (sizestr == NULL)
-+							sizestr = strdup(ptemp);
-+						else {
-+							sizestr = realloc(sizestr, strlen(sizestr) + strlen(ptemp) + 1);
-+							if (sizestr == NULL) {
-+
-+								f_print(stderr, "Fatal error : no memory \n");
-+								crash();
-+							};
-+							sizestr = strcat(sizestr, ptemp);	/*build up length of array */
-+
-+						}
-+					}
-+
-+				} else {
-+					if (i > 0)
-+					    {
-+						if (sizestr == NULL && size < Inline) {
-+							/* don't expand into inline code if size < inline */
-+							while (cur != dl) {
-+								print_stat(1, &cur->decl);
-+								cur = cur->next;
-+							}
-+						} else {
-+
-+
-+
-+							/* were already looking at a xdr_inlineable structure */
-+							if (sizestr == NULL)
-+								f_print(fout, "\t %sbuf = XDR_INLINE(xdrs,%d * BYTES_PER_XDR_UNIT);",
-+									buf_declaration, size);
-+							else if (size == 0)
-+								f_print(fout,
-+									"\t %sbuf = XDR_INLINE(xdrs,%s * BYTES_PER_XDR_UNIT);",
-+									buf_declaration, sizestr);
-+							else
-+								f_print(fout,
-+									"\t %sbuf = XDR_INLINE(xdrs,(%d + %s)* BYTES_PER_XDR_UNIT);",
-+									buf_declaration, size, sizestr);
-+							buf_declaration = "";
-+
-+							f_print(fout, "\n\t   if (buf == NULL) {\n");
-+
-+							psav = cur;
-+							while (cur != dl) {
-+								print_stat(2, &cur->decl);
-+								cur = cur->next;
-+							}
-+
-+							f_print(fout, "\n\t  }\n\t  else {\n");
-+
-+							cur = psav;
-+							while (cur != dl) {
-+								emit_inline(&cur->decl, flag);
-+								cur = cur->next;
-+							}
-+
-+							f_print(fout, "\t  }\n");
-+						}
-+					    }
-+					size = 0;
-+					i = 0;
-+					sizestr = NULL;
-+					print_stat(1, &dl->decl);
-+				}
-+
-+			}
-+			if (i > 0)
-+			    {
-+				if (sizestr == NULL && size < Inline) {
-+					/* don't expand into inline code if size < inline */
-+					while (cur != dl) {
-+						print_stat(1, &cur->decl);
-+						cur = cur->next;
-+					}
-+				} else {
-+
-+					/* were already looking at a xdr_inlineable structure */
-+					if (sizestr == NULL)
-+						f_print(fout, "\t\t%sbuf = XDR_INLINE(xdrs,%d * BYTES_PER_XDR_UNIT);",
-+							buf_declaration, size);
-+					else if (size == 0)
-+						f_print(fout,
-+							"\t\t%sbuf = XDR_INLINE(xdrs,%s * BYTES_PER_XDR_UNIT);",
-+							buf_declaration, sizestr);
-+					else
-+						f_print(fout,
-+							"\t\t%sbuf = XDR_INLINE(xdrs,(%d + %s)* BYTES_PER_XDR_UNIT);",
-+							buf_declaration, size, sizestr);
-+					buf_declaration = "";
-+
-+					f_print(fout, "\n\t\tif (buf == NULL) {\n");
-+
-+					psav = cur;
-+					while (cur != NULL) {
-+						print_stat(2, &cur->decl);
-+						cur = cur->next;
-+					}
-+					f_print(fout, "\n\t  }\n\t  else {\n");
-+
-+					cur = psav;
-+					while (cur != dl) {
-+						emit_inline(&cur->decl, flag);
-+						cur = cur->next;
-+					}
-+
-+					f_print(fout, "\t  }\n");
-+
-+				}
-+			    }
-+			flag = GET;
-+		}
-+		f_print(fout, "\t return(TRUE);\n\t}\n\n");
-+
-+		/* now take care of XDR_FREE case */
-+
-+		for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
-+			print_stat(1, &dl->decl);
-+	}
-+}
-+ 
-+
-+
-+
-+static void
-+emit_typedef(definition *def)
-+{
-+	char *prefix = def->def.ty.old_prefix;
-+	char *type = def->def.ty.old_type;
-+	char *amax = def->def.ty.array_max;
-+	relation rel = def->def.ty.rel;
-+
-+
-+	  print_ifstat(1, prefix, type, rel, amax, "objp", def->def_name);
-+}
-+
-+static void
-+print_stat(int indent, declaration *dec)
-+{
-+	char *prefix = dec->prefix;
-+	char *type = dec->type;
-+	char *amax = dec->array_max;
-+	relation rel = dec->rel;
-+	char name[256];
-+
-+	if (isvectordef(type, rel)) {
-+		s_print(name, "objp->%s", dec->name);
-+	} else {
-+		s_print(name, "&objp->%s", dec->name);
-+	}
-+	print_ifstat(indent, prefix, type, rel, amax, name, dec->name);
-+}
-+
-+
-+static void
-+emit_inline(declaration *decl, int flag)
-+{
-+
-+	/*check whether an array or not */
-+
-+	switch (decl->rel) {
-+	case REL_ALIAS:
-+		emit_single_in_line(decl, flag, REL_ALIAS);
-+		break;
-+	case REL_VECTOR:
-+		f_print(fout, "\t\t{ register %s *genp; \n", decl->type);
-+		f_print(fout, "\t\t  int i;\n");
-+		f_print(fout, "\t\t  for ( i = 0,genp=objp->%s;\n \t\t\ti < %s; i++){\n\t\t",
-+			decl->name, decl->array_max);
-+		emit_single_in_line(decl, flag, REL_VECTOR);
-+		f_print(fout, "\t\t   }\n\t\t };\n");
-+		break;
-+	default:
-+		break;
-+	}
-+}
-+
-+static void
-+emit_single_in_line(declaration *decl, int flag, relation rel)
-+{
-+	char *upp_case;
-+	int freed=0;
-+
-+	if(flag == PUT)
-+		f_print(fout,"\t\t (void) IXDR_PUT_");
-+	else    
-+		if(rel== REL_ALIAS)
-+			f_print(fout,"\t\t objp->%s = IXDR_GET_",decl->name);
-+		else
-+			f_print(fout,"\t\t *genp++ = IXDR_GET_");
-+
-+	upp_case=upcase(decl->type);
-+
-+	/* hack  - XX */
-+	if(strcmp(upp_case,"INT") == 0)
-+	{
-+		free(upp_case);
-+		freed=1;
-+		upp_case="INT32";
-+	}
-+
-+	if(strcmp(upp_case,"U_INT") == 0)
-+	{
-+		free(upp_case);
-+		freed=1;
-+		upp_case="U_INT32";
-+	}
-+
-+
-+	if(flag == PUT) 
-+		if(rel== REL_ALIAS)
-+			f_print(fout,"%s(buf,objp->%s);\n",upp_case,decl->name);
-+		else
-+			f_print(fout,"%s(buf,*genp++);\n",upp_case);
-+
-+	else
-+		f_print(fout,"%s(buf);\n",upp_case);
-+	if(!freed)
-+		free(upp_case);
-+
-+}
-+
-+
-+static char *
-+upcase(char *str)
-+{
-+	char           *ptr, *hptr;
-+
-+
-+	ptr = (char *) malloc(strlen(str)+1);
-+	if (ptr == (char *) NULL) {
-+		f_print(stderr, "malloc failed \n");
-+		exit(1);
-+	};
-+
-+	hptr = ptr;
-+	while (*str != '\0')
-+		*ptr++ = toupper(*str++);
-+
-+	*ptr = '\0';
-+	return (hptr);
-+
-+}
-diff --git a/rpcgen/rpc_hout.c b/rpcgen/rpc_hout.c
-new file mode 100644
-index 0000000..ea1cb24
---- /dev/null
-+++ b/rpcgen/rpc_hout.c
-@@ -0,0 +1,490 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_hout.c 1.12 89/02/22 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_hout.c, Header file outputter for the RPC protocol compiler 
-+ */
-+#include <stdio.h>
-+#include <ctype.h>
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+#include "rpc_output.h"
-+
-+
-+static int	undefined2(char *type, char *stop);
-+static void	pxdrfuncdecl(char *name, int pointerp);
-+static void	pconstdef(definition *def);
-+static void	pargdef(definition *def);
-+static void	pstructdef(definition *def);
-+static void	puniondef(definition *def);
-+static void	pdefine(char *name, char *num);
-+static void	puldefine(char *name, char *num);
-+static int	define_printed(proc_list *stop, version_list *start);
-+static void	pprogramdef(definition *def);
-+static void	pprocdef(proc_list *proc, version_list *vp,
-+				char *addargtype, int server_p, int mode);
-+static void	parglist(proc_list *proc, char *addargtype);
-+static void	penumdef(definition *def);
-+static void	ptypedef(definition *def);
-+
-+/*
-+ * Print the C-version of an xdr definition 
-+ */
-+void
-+print_datadef(definition *def)
-+{
-+
-+	if (def->def_kind == DEF_PROGRAM )  /* handle data only */
-+	        return;
-+
-+	if (def->def_kind != DEF_CONST) {
-+		f_print(fout, "\n");
-+	}
-+	switch (def->def_kind) {
-+	case DEF_STRUCT:
-+		pstructdef(def);
-+		break;
-+	case DEF_UNION:
-+		puniondef(def);
-+		break;
-+	case DEF_ENUM:
-+		penumdef(def);
-+		break;
-+	case DEF_TYPEDEF:
-+		ptypedef(def);
-+		break;
-+	case DEF_PROGRAM:
-+		pprogramdef(def);
-+		break;
-+	case DEF_CONST:
-+		pconstdef(def);
-+		break;
-+	}
-+	if (def->def_kind != DEF_PROGRAM && def->def_kind != DEF_CONST) {
-+	  pxdrfuncdecl( def->def_name,
-+		       def->def_kind != DEF_TYPEDEF ||
-+		       !isvectordef(def->def.ty.old_type, def->def.ty.rel));
-+
-+	}
-+}
-+
-+
-+void
-+print_funcdef(definition *def)
-+{
-+	switch (def->def_kind) {
-+	case DEF_PROGRAM:
-+		f_print(fout, "\n");
-+		pprogramdef(def);
-+		break;
-+	default:
-+		break;
-+	}
-+}
-+
-+static void
-+pxdrfuncdecl(char *name, int pointerp)
-+{
-+	f_print(fout,
-+	"#ifdef __cplusplus \n"
-+	"extern \"C\" bool_t xdr_%s(XDR *, %s%s);\n"
-+	"#elif __STDC__ \n"
-+	"extern  bool_t xdr_%s(XDR *, %s%s);\n"
-+	"#else /* Old Style C */ \n"
-+	"bool_t xdr_%s();\n"
-+	"#endif /* Old Style C */ \n\n",
-+	name, name, pointerp ? "*" : "",
-+	name, name, pointerp ? "*" : "",
-+	name);
-+}
-+
-+
-+static void
-+pconstdef(definition *def)
-+{
-+	pdefine(def->def_name, def->def.co);
-+}
-+
-+/* print out the definitions for the arguments of functions in the 
-+   header file 
-+*/
-+static  void
-+pargdef(definition *def)
-+{
-+	decl_list *l;
-+	version_list *vers;
-+	char *name;
-+	proc_list *plist;
-+
-+	
-+	for (vers = def->def.pr.versions; vers != NULL; vers = vers->next) {
-+			for(plist = vers->procs; plist != NULL; 
-+			    plist = plist->next) {
-+				
-+				if (!newstyle || plist->arg_num < 2) {
-+					continue; /* old style or single args */
-+				}
-+				name = plist->args.argname;
-+				f_print(fout, "struct %s {\n", name);
-+				for (l = plist->args.decls; 
-+				     l != NULL; l = l->next) {
-+					pdeclaration(name, &l->decl, 1, ";\n" );
-+				}
-+				f_print(fout, "};\n");
-+				f_print(fout, "typedef struct %s %s;\n", name, name);
-+				pxdrfuncdecl(name, 0);
-+				f_print( fout, "\n" );
-+			}
-+		}
-+
-+}
-+
-+
-+static void
-+pstructdef(definition *def)
-+{
-+	decl_list *l;
-+	char *name = def->def_name;
-+
-+	f_print(fout, "struct %s {\n", name);
-+	for (l = def->def.st.decls; l != NULL; l = l->next) {
-+		pdeclaration(name, &l->decl, 1, ";\n");
-+	}
-+	f_print(fout, "};\n");
-+	f_print(fout, "typedef struct %s %s;\n", name, name);
-+}
-+
-+static void
-+puniondef(definition *def)
-+{
-+	case_list      *l;
-+	char           *name = def->def_name;
-+	declaration    *decl;
-+
-+	f_print(fout, "struct %s {\n", name);
-+	decl = &def->def.un.enum_decl;
-+	if (streq(decl->type, "bool")) {
-+		f_print(fout, "\tbool_t %s;\n", decl->name);
-+	} else {
-+		f_print(fout, "\t%s %s;\n", decl->type, decl->name);
-+	}
-+	f_print(fout, "\tunion {\n");
-+	for (l = def->def.un.cases; l != NULL; l = l->next) {
-+		if (l->contflag == 0)
-+			pdeclaration(name, &l->case_decl, 2, ";\n");
-+	}
-+	decl = def->def.un.default_decl;
-+	if (decl && !streq(decl->type, "void")) {
-+		pdeclaration(name, decl, 2, ";\n");
-+	}
-+	f_print(fout, "\t} %s_u;\n", name);
-+	f_print(fout, "};\n");
-+	f_print(fout, "typedef struct %s %s;\n", name, name);
-+}
-+
-+static void
-+pdefine(char *name, char *num)
-+{
-+	f_print(fout, "#define %s %s\n", name, num);
-+}
-+
-+static void
-+puldefine(char *name, char *num)
-+{
-+	f_print(fout, "#define %s ((u_int32_t)%s)\n", name, num);
-+}
-+
-+static int
-+define_printed(proc_list *stop, version_list *start)
-+{
-+	version_list *vers;
-+	proc_list *proc;
-+
-+	for (vers = start; vers != NULL; vers = vers->next) {
-+		for (proc = vers->procs; proc != NULL; proc = proc->next) {
-+			if (proc == stop) {
-+				return (0);
-+			} else if (streq(proc->proc_name, stop->proc_name)) {
-+				return (1);
-+			}
-+		}
-+	}
-+	abort();
-+	/* NOTREACHED */
-+}
-+
-+static void
-+pprogramdef(definition *def)
-+{
-+	version_list   *vers;
-+	proc_list      *proc;
-+	int             i;
-+	char           *ext;
-+
-+	pargdef(def);
-+
-+	puldefine(def->def_name, def->def.pr.prog_num);
-+	for (vers = def->def.pr.versions; vers != NULL; vers = vers->next) {
-+		if (tblflag) {
-+			f_print(fout, "extern struct rpcgen_table %s_%s_table[];\n",
-+				locase(def->def_name), vers->vers_num);
-+			f_print(fout, "extern %s_%s_nproc;\n",
-+				locase(def->def_name), vers->vers_num);
-+		}
-+		puldefine(vers->vers_name, vers->vers_num);
-+
-+		/*
-+		 * Print out 3 definitions, one for ANSI-C, another for C++,
-+		 * a third for old style C
-+		 */
-+
-+		for (i = 0; i < 3; i++) {
-+			if (i == 0) {
-+				f_print(fout, "\n#ifdef __cplusplus\n");
-+				ext = "extern \"C\" ";
-+			} else if (i == 1) {
-+				f_print(fout, "\n#elif __STDC__\n");
-+				ext = "extern  ";
-+			} else {
-+				f_print(fout, "\n#else /* Old Style C */ \n");
-+				ext = "extern  ";
-+			}
-+
-+
-+			for (proc = vers->procs; proc != NULL; proc = proc->next) {
-+				if (!define_printed(proc, def->def.pr.versions)) {
-+					puldefine(proc->proc_name, proc->proc_num);
-+				}
-+				f_print(fout, "%s", ext);
-+				pprocdef(proc, vers, "CLIENT *", 0, i);
-+				f_print(fout, "%s", ext);
-+				pprocdef(proc, vers, "struct svc_req *", 1, i);
-+
-+			}
-+
-+		}
-+		f_print(fout, "#endif /* Old Style C */ \n");
-+	}
-+}
-+
-+static void
-+pprocdef(proc_list *proc, version_list *vp, char *addargtype,
-+				int server_p, int mode)
-+{
-+	ptype(proc->res_prefix, proc->res_type, 1);
-+	f_print(fout, "* ");
-+	if (server_p)
-+		pvname_svc(proc->proc_name, vp->vers_num);
-+	else
-+		pvname(proc->proc_name, vp->vers_num);
-+
-+	/*
-+	 * mode  0 == cplusplus, mode  1 = ANSI-C, mode 2 = old style C
-+	 */
-+	if (mode == 0 || mode == 1)
-+		parglist(proc, addargtype);
-+	else
-+		f_print(fout, "();\n");
-+}
-+
-+
-+
-+/* print out argument list of procedure */
-+static void
-+parglist(proc_list *proc, char *addargtype)
-+{
-+	decl_list      *dl;
-+
-+	f_print(fout, "(");
-+
-+	if (proc->arg_num < 2 && newstyle &&
-+		streq(proc->args.decls->decl.type, "void")) {
-+		/* 0 argument in new style:  do nothing */
-+	} else {
-+		for (dl = proc->args.decls; dl != NULL; dl = dl->next) {
-+			ptype(dl->decl.prefix, dl->decl.type, 1);
-+			if (!newstyle)
-+				f_print(fout, "*");	/* old style passes by reference */
-+
-+			f_print(fout, ", ");
-+		}
-+	}
-+
-+	f_print(fout, "%s);\n", addargtype);
-+}
-+
-+static void
-+penumdef(definition *def)
-+{
-+	char *name = def->def_name;
-+	enumval_list *l;
-+	char *last = NULL;
-+	int count = 0;
-+
-+	f_print(fout, "enum %s {\n", name);
-+	for (l = def->def.en.vals; l != NULL; l = l->next) {
-+		f_print(fout, "\t%s", l->name);
-+		if (l->assignment) {
-+			f_print(fout, " = %s", l->assignment);
-+			last = l->assignment;
-+			count = 1;
-+		} else {
-+			if (last == NULL) {
-+				f_print(fout, " = %d", count++);
-+			} else {
-+				f_print(fout, " = %s + %d", last, count++);
-+			}
-+		}
-+		f_print(fout, ",\n");
-+	}
-+	f_print(fout, "};\n");
-+	f_print(fout, "typedef enum %s %s;\n", name, name);
-+}
-+
-+static void
-+ptypedef(definition *def)
-+{
-+	char *name = def->def_name;
-+	char *old = def->def.ty.old_type;
-+	char prefix[8];	/* enough to contain "struct ", including NUL */
-+	relation rel = def->def.ty.rel;
-+
-+
-+	if (!streq(name, old)) {
-+		if (streq(old, "string")) {
-+			old = "char";
-+			rel = REL_POINTER;
-+		} else if (streq(old, "opaque")) {
-+			old = "char";
-+		} else if (streq(old, "bool")) {
-+			old = "bool_t";
-+		}
-+		if (undefined2(old, name) && def->def.ty.old_prefix) {
-+			s_print(prefix, "%s ", def->def.ty.old_prefix);
-+		} else {
-+			prefix[0] = 0;
-+		}
-+		f_print(fout, "typedef ");
-+		switch (rel) {
-+		case REL_ARRAY:
-+			f_print(fout, "struct {\n");
-+			f_print(fout, "\tu_int %s_len;\n", name);
-+			f_print(fout, "\t%s%s *%s_val;\n", prefix, old, name);
-+			f_print(fout, "} %s", name);
-+			break;
-+		case REL_POINTER:
-+			f_print(fout, "%s%s *%s", prefix, old, name);
-+			break;
-+		case REL_VECTOR:
-+			f_print(fout, "%s%s %s[%s]", prefix, old, name,
-+				def->def.ty.array_max);
-+			break;
-+		case REL_ALIAS:
-+			f_print(fout, "%s%s %s", prefix, old, name);
-+			break;
-+		}
-+		f_print(fout, ";\n");
-+	}
-+}
-+
-+void
-+pdeclaration(char *name, declaration *dec, int tab, char *separator)
-+{
-+	char buf[8];	/* enough to hold "struct ", include NUL */
-+	char *prefix;
-+	char *type;
-+
-+	if (streq(dec->type, "void")) {
-+		return;
-+	}
-+	tabify(fout, tab);
-+	if (streq(dec->type, name) && !dec->prefix) {
-+		f_print(fout, "struct ");
-+	}
-+	if (streq(dec->type, "string")) {
-+		f_print(fout, "char *%s", dec->name);
-+	} else {
-+		prefix = "";
-+		if (streq(dec->type, "bool")) {
-+			type = "bool_t";
-+		} else if (streq(dec->type, "opaque")) {
-+			type = "char";
-+		} else {
-+			if (dec->prefix) {
-+				s_print(buf, "%s ", dec->prefix);
-+				prefix = buf;
-+			}
-+			type = dec->type;
-+		}
-+		switch (dec->rel) {
-+		case REL_ALIAS:
-+			f_print(fout, "%s%s %s", prefix, type, dec->name);
-+			break;
-+		case REL_VECTOR:
-+			f_print(fout, "%s%s %s[%s]", prefix, type, dec->name,
-+				dec->array_max);
-+			break;
-+		case REL_POINTER:
-+			f_print(fout, "%s%s *%s", prefix, type, dec->name);
-+			break;
-+		case REL_ARRAY:
-+			f_print(fout, "struct {\n");
-+			tabify(fout, tab);
-+			f_print(fout, "\tu_int %s_len;\n", dec->name);
-+			tabify(fout, tab);
-+			f_print(fout, "\t%s%s *%s_val;\n", prefix, type, dec->name);
-+			tabify(fout, tab);
-+			f_print(fout, "} %s", dec->name);
-+			break;
-+		}
-+	}
-+	f_print(fout, separator );
-+}
-+
-+static int
-+undefined2(char *type, char *stop)
-+{
-+	list *l;
-+	definition *def;
-+
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind != DEF_PROGRAM) {
-+			if (streq(def->def_name, stop)) {
-+				return (1);
-+			} else if (streq(def->def_name, type)) {
-+				return (0);
-+			}
-+		}
-+	}
-+	return (1);
-+}
-diff --git a/rpcgen/rpc_main.c b/rpcgen/rpc_main.c
-new file mode 100644
-index 0000000..28aa60c
---- /dev/null
-+++ b/rpcgen/rpc_main.c
-@@ -0,0 +1,1067 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_main.c 1.30 89/03/30 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_main.c, Top level of the RPC protocol compiler. 
-+ */
-+
-+#include <sys/types.h>
-+#include <sys/param.h>
-+#include <sys/file.h>
-+#include <sys/stat.h>
-+#include <stdio.h>
-+#include <string.h>
-+#include <stdlib.h>
-+#include <unistd.h>
-+#include <ctype.h>
-+#include <errno.h>
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+#include "rpc_scan.h"
-+
-+struct commandline {
-+	int cflag;		/* xdr C routines */
-+	int hflag;		/* header file */
-+	int lflag;		/* client side stubs */
-+	int mflag;		/* server side stubs */
-+	int nflag;		/* netid flag */
-+	int sflag;		/* server stubs for the given transport */
-+	int tflag;		/* dispatch Table file */
-+	int Ssflag;		/* produce server sample code */
-+	int Scflag;		/* produce client sample code */
-+	char *infile;		/* input module name */
-+	char *outfile;		/* output module name */
-+};
-+
-+static char *	extendfile(char *file, char *ext);
-+static void	open_output(char *infile, char *outfile);
-+static void	add_warning(void);
-+static void	clear_args(void);
-+static void	open_input(char *infile, char *define);
-+static int	check_nettype(char *name, char **list_to_check);
-+static void	c_output(char *infile, char *define, int extend, char *outfile);
-+static void	c_initialize(void);
-+static char *	generate_guard(char *pathname);
-+static void	h_output(char *infile, char *define, int extend, char *outfile);
-+static void	s_output(int argc, char **argv, char *infile,
-+			char *define, int extend, char *outfile,
-+			int nomain, int netflag);
-+static void	l_output(char *infile, char *define, int extend, char *outfile);
-+static void	t_output(char *infile, char *define, int extend, char *outfile);
-+static void	svc_output(char *, char *, int, char *);
-+static void	clnt_output(char *, char *, int, char *);
-+static int	do_registers(int argc, char **argv);
-+static void	addarg(char *cp);
-+static void	putarg(int where, char *cp);
-+static void	checkfiles(char *infile, char *outfile);
-+static int	parseargs(int argc, char **argv, struct commandline *cmd);
-+static void	usage(void);
-+static void	options_usage(void);
-+
-+/*
-+extern void  write_sample_svc();
-+int write_sample_clnt();
-+void write_sample_clnt_main();
-+
-+static svc_output();
-+ */
-+
-+#define EXTEND	1		/* alias for TRUE */
-+#define DONT_EXTEND	0		/* alias for FALSE */
-+
-+#define SVR4_CPP "/usr/ccs/lib/cpp"
-+#define SUNOS_CPP "/lib/cpp"
-+static int cppDefined = 0;          /* explicit path for C preprocessor */
-+
-+
-+static char *cmdname;
-+
-+static char *svcclosetime = "120";
-+static char *CPP = SVR4_CPP;
-+static char CPPFLAGS[] = "-C";
-+static char pathbuf[MAXPATHLEN + 1];
-+static char *allv[] = {
-+	"rpcgen", "-s", "udp", "-s", "tcp",
-+};
-+static int allc = sizeof(allv)/sizeof(allv[0]);
-+static char *allnv[] = {
-+	"rpcgen", "-s", "netpath",
-+};
-+static int allnc = sizeof(allnv)/sizeof(allnv[0]);
-+
-+/*
-+ * machinations for handling expanding argument list
-+ */
-+#if 0
-+static void addarg();		/* add another argument to the list */
-+static void putarg();		/* put argument at specified location  */
-+static void clear_args();	/* clear argument list */
-+static void checkfiles();	/* check if out file already exists */
-+#endif
-+
-+
-+
-+#define ARGLISTLEN	20
-+#define FIXEDARGS         2
-+
-+static char *arglist[ARGLISTLEN];
-+static int argcount = FIXEDARGS;
-+
-+
-+int nonfatalerrors;	/* errors */
-+int inetdflag/* = 1*/;	/* Support for inetd */ /* is now the default */
-+int pmflag;		/* Support for port monitors */
-+int logflag;		/* Use syslog instead of fprintf for errors */
-+int tblflag;		/* Support for dispatch table file */
-+
-+/* length at which to start doing an inline */
-+#define INLINE 3
-+
-+int Inline = INLINE;	/* length at which to start doing an inline. 3 = default
-+			 * if 0, no xdr_inline code */
-+
-+int indefinitewait;	/* If started by port monitors, hang till it wants */
-+int exitnow;		/* If started by port monitors, exit after the call */
-+int timerflag;		/* TRUE if !indefinite && !exitnow */
-+int newstyle;           /* newstyle of passing arguments (by value) */
-+int Cflag = 0 ;         /* ANSI C syntax */
-+static int allfiles;    /* generate all files */
-+#ifdef linux
-+int tirpcflag = 0;	/* no tirpc by default */
-+#else
-+int tirpcflag = 1;      /* generating code for tirpc, by default */
-+#endif
-+
-+int
-+main(int argc, char **argv)
-+{
-+	struct commandline cmd;
-+
-+	(void) memset((char *) &cmd, 0, sizeof(struct commandline));
-+	clear_args();
-+	if (!parseargs(argc, argv, &cmd))
-+		usage();
-+
-+	if (cmd.cflag || cmd.hflag || cmd.lflag || cmd.tflag || cmd.sflag ||
-+		cmd.mflag || cmd.nflag || cmd.Ssflag || cmd.Scflag) {
-+		checkfiles(cmd.infile, cmd.outfile);
-+	} else
-+		checkfiles(cmd.infile, NULL);
-+
-+	if (cmd.cflag) {
-+		c_output(cmd.infile, "-DRPC_XDR", DONT_EXTEND, cmd.outfile);
-+	} else if (cmd.hflag) {
-+		h_output(cmd.infile, "-DRPC_HDR", DONT_EXTEND, cmd.outfile);
-+	} else if (cmd.lflag) {
-+		l_output(cmd.infile, "-DRPC_CLNT", DONT_EXTEND, cmd.outfile);
-+	} else if (cmd.sflag || cmd.mflag || (cmd.nflag)) {
-+		s_output(argc, argv, cmd.infile, "-DRPC_SVC", DONT_EXTEND,
-+			cmd.outfile, cmd.mflag, cmd.nflag);
-+	} else if (cmd.tflag) {
-+		t_output(cmd.infile, "-DRPC_TBL", DONT_EXTEND, cmd.outfile);
-+	} else if (cmd.Ssflag) {
-+		svc_output(cmd.infile, "-DRPC_SERVER", DONT_EXTEND, cmd.outfile);
-+	} else if (cmd.Scflag) {
-+		clnt_output(cmd.infile, "-DRPC_CLIENT", DONT_EXTEND, cmd.outfile);
-+	} else {
-+		/* the rescans are required, since cpp may effect input */
-+		c_output(cmd.infile, "-DRPC_XDR", EXTEND, "_xdr.c");
-+		reinitialize();
-+		h_output(cmd.infile, "-DRPC_HDR", EXTEND, ".h");
-+		reinitialize();
-+		l_output(cmd.infile, "-DRPC_CLNT", EXTEND, "_clnt.c");
-+		reinitialize();
-+		if (inetdflag || !tirpcflag)
-+			s_output(allc, allv, cmd.infile, "-DRPC_SVC", EXTEND,
-+				"_svc.c", cmd.mflag, cmd.nflag);
-+		else
-+			s_output(allnc, allnv, cmd.infile, "-DRPC_SVC",
-+				EXTEND, "_svc.c", cmd.mflag, cmd.nflag);
-+		if (tblflag) {
-+			reinitialize();
-+			t_output(cmd.infile, "-DRPC_TBL", EXTEND, "_tbl.i");
-+		}
-+		if (allfiles) {
-+			reinitialize();
-+			svc_output(cmd.infile, "-DRPC_SERVER", EXTEND, "_server.c");
-+		}
-+		if (allfiles) {
-+			reinitialize();
-+			clnt_output(cmd.infile, "-DRPC_CLIENT", EXTEND, "_client.c");
-+		}
-+	}
-+	exit(nonfatalerrors);
-+	/* NOTREACHED */
-+}
-+
-+/*
-+ * add extension to filename 
-+ */
-+static char *
-+extendfile(char *file, char *ext)
-+{
-+	char *res;
-+	char *p;
-+
-+	res = alloc(strlen(file) + strlen(ext) + 1);
-+	if (res == NULL) {
-+		abort();
-+	}
-+	p = strrchr(file, '.');
-+	if (p == NULL) {
-+		p = file + strlen(file);
-+	}
-+	(void) strcpy(res, file);
-+	(void) strcpy(res + (p - file), ext);
-+	return (res);
-+}
-+
-+/*
-+ * Open output file with given extension 
-+ */
-+static void
-+open_output(char *infile, char *outfile)
-+{
-+
-+	if (outfile == NULL) {
-+		fout = stdout;
-+		return;
-+	}
-+
-+	if (infile != NULL && streq(outfile, infile)) {
-+		f_print(stderr, "%s: output would overwrite %s\n", cmdname,
-+			infile);
-+		crash();
-+	}
-+	fout = fopen(outfile, "w");
-+	if (fout == NULL) {
-+		f_print(stderr, "%s: unable to open ", cmdname);
-+		perror(outfile);
-+		crash();
-+	}
-+	record_open(outfile);
-+
-+}
-+
-+static void
-+add_warning(void)
-+{
-+	f_print(fout, "/*\n");
-+	f_print(fout, " * Please do not edit this file.\n");
-+	f_print(fout, " * It was generated using rpcgen.\n");
-+	f_print(fout, " */\n\n");
-+}
-+
-+/* clear list of arguments */
-+static void
-+clear_args(void)
-+{
-+  int i;
-+  for( i=FIXEDARGS; i<ARGLISTLEN; i++ )
-+    arglist[i] = NULL;
-+  argcount = FIXEDARGS;
-+}
-+
-+/*
-+ * Open input file with given define for C-preprocessor 
-+ */
-+static void
-+open_input(char *infile, char *define)
-+{
-+	int pd[2];
-+
-+	infilename = (infile == NULL) ? "<stdin>" : infile;
-+	(void) pipe(pd);
-+	switch (fork()) {
-+	case 0:
-+		putarg(0, "cpp");
-+		putarg(1, CPPFLAGS);
-+		addarg(define);
-+		addarg(infile);
-+		addarg((char *)NULL);
-+		(void) close(1);
-+		(void) dup2(pd[1], 1);
-+		(void) close(pd[0]);
-+		if (cppDefined)
-+			execv(CPP, arglist);
-+		else {
-+			execvp("cpp", arglist);
-+			if (errno == ENOENT)
-+				execvp(SVR4_CPP, arglist);
-+			if (errno == ENOENT)
-+				execvp(SUNOS_CPP, arglist);
-+		}
-+		perror("execv");
-+		exit(1);
-+	case -1:
-+		perror("fork");
-+		exit(1);
-+	}
-+	(void) close(pd[1]);
-+	fin = fdopen(pd[0], "r");
-+	if (fin == NULL) {
-+		f_print(stderr, "%s: ", cmdname);
-+		perror(infilename);
-+		crash();
-+	}
-+}
-+
-+/* valid tirpc nettypes */
-+static char*	valid_ti_nettypes[] =
-+{
-+	"netpath",
-+	"visible",
-+	"circuit_v",
-+	"datagram_v",
-+	"circuit_n",
-+	"datagram_n",
-+	"udp",
-+	"tcp",
-+	"raw",
-+	NULL
-+};
-+
-+/* valid inetd nettypes */
-+static char* valid_i_nettypes[] =
-+{
-+	"udp",
-+	"tcp",
-+	NULL
-+};
-+
-+static int
-+check_nettype(char *name, char **list_to_check)
-+{
-+  int i;
-+  for( i = 0; list_to_check[i] != NULL; i++ ) {
-+	  if( strcmp( name, list_to_check[i] ) == 0 ) {
-+	    return 1;
-+	  }
-+  }
-+  f_print( stderr, "illegal nettype :\'%s\'\n", name );
-+  return 0;
-+}
-+
-+/*
-+ * Compile into an XDR routine output file
-+ */
-+
-+static void
-+c_output(char *infile, char *define, int extend, char *outfile)
-+{
-+	definition *def;
-+	char *include;
-+	char *outfilename;
-+	long tell;
-+
-+	c_initialize();
-+	open_input(infile, define);	
-+	outfilename = extend ? extendfile(infile, outfile) : outfile;
-+	open_output(infile, outfilename);
-+	add_warning();
-+	if (infile && (include = extendfile(infile, ".h"))) {
-+		f_print(fout, "#include \"%s\"\n", include);
-+		free(include);
-+		/* .h file already contains rpc/rpc.h */
-+	} else
-+	  f_print(fout, "#include <rpc/rpc.h>\n");
-+	tell = ftell(fout);
-+	while ((def = get_definition()) != NULL) {
-+		emit(def);
-+	}
-+	if (extend && tell == ftell(fout)) {
-+		(void) unlink(outfilename);
-+	}
-+}
-+
-+
-+static void
-+c_initialize(void)
-+{
-+
-+  /* add all the starting basic types */
-+
-+  add_type(1,"int");
-+  add_type(1,"int32_t");
-+  add_type(1,"short");
-+  add_type(1,"bool");
-+
-+  add_type(1,"u_int");
-+  add_type(1,"u_int32_t");
-+  add_type(1,"u_short");
-+
-+}
-+
-+char rpcgen_table_dcl[] = "struct rpcgen_table {\n\
-+	char	*(*proc)();\n\
-+	xdrproc_t	xdr_arg;\n\
-+	unsigned	len_arg;\n\
-+	xdrproc_t	xdr_res;\n\
-+	unsigned	len_res;\n\
-+};\n";
-+
-+
-+static char *
-+generate_guard(char *pathname)
-+{
-+        char* filename, *guard, *tmp;
-+
-+	filename = strrchr(pathname, '/' );  /* find last component */
-+	filename = ((filename == 0) ? pathname : filename+1);
-+	guard = strdup(filename);
-+	/* convert to upper case */
-+	tmp = guard;
-+	while (*tmp) {
-+		if (islower(*tmp))
-+			*tmp = toupper(*tmp);
-+		tmp++;
-+	}
-+		
-+	guard = extendfile(guard, "_H_RPCGEN");
-+	return( guard );
-+}
-+
-+/*
-+ * Compile into an XDR header file
-+ */
-+static void
-+h_output(char *infile, char *define, int extend, char *outfile)
-+{
-+	definition *def;
-+	char *outfilename;
-+	long tell;
-+	char *guard;
-+	list *l;
-+
-+	open_input(infile, define);
-+	outfilename =  extend ? extendfile(infile, outfile) : outfile;
-+	open_output(infile, outfilename);
-+	add_warning();
-+	guard = generate_guard(  outfilename ? outfilename: infile );
-+
-+	f_print(fout,"#ifndef _%s\n#define _%s\n\n", guard,
-+		guard);
-+
-+	f_print(fout, "#include <rpc/rpc.h>\n\n");
-+
-+	f_print(fout, "#ifndef IXDR_GET_INT32\n");
-+	f_print(fout, "#define IXDR_GET_INT32(buf) IXDR_GET_LONG((buf))\n");
-+	f_print(fout, "#endif\n");
-+	f_print(fout, "#ifndef IXDR_PUT_INT32\n");
-+	f_print(fout, "#define IXDR_PUT_INT32(buf, v) IXDR_PUT_LONG((buf), (v))\n");
-+	f_print(fout, "#endif\n");
-+	f_print(fout, "#ifndef IXDR_GET_U_INT32\n");
-+	f_print(fout, "#define IXDR_GET_U_INT32(buf) IXDR_GET_U_LONG((buf))\n");
-+	f_print(fout, "#endif\n");
-+	f_print(fout, "#ifndef IXDR_PUT_U_INT32\n");
-+	f_print(fout, "#define IXDR_PUT_U_INT32(buf, v) IXDR_PUT_U_LONG((buf), (v))\n");
-+	f_print(fout, "#endif\n");
-+
-+	tell = ftell(fout);
-+	/* print data definitions */
-+	while ((def = get_definition()) != NULL) {
-+		print_datadef(def);
-+	}
-+
-+	/* print function declarations.  
-+	   Do this after data definitions because they might be used as
-+	   arguments for functions */
-+	for (l = defined; l != NULL; l = l->next) {
-+		print_funcdef(l->val);
-+	}
-+	if (extend && tell == ftell(fout)) {
-+		(void) unlink(outfilename);
-+	} else if (tblflag) {
-+		f_print(fout, rpcgen_table_dcl);
-+	}
-+	f_print(fout, "\n#endif /* !_%s */\n", guard);
-+}
-+
-+/*
-+ * Compile into an RPC service
-+ */
-+static void
-+s_output(int argc, char **argv, char *infile, char *define, int extend,
-+			char *outfile, int nomain, int netflag)
-+{
-+	char *include;
-+	definition *def;
-+	int foundprogram = 0;
-+	char *outfilename;
-+
-+	open_input(infile, define);
-+	outfilename = extend ? extendfile(infile, outfile) : outfile;
-+	open_output(infile, outfilename);
-+	add_warning();
-+	if (infile && (include = extendfile(infile, ".h"))) {
-+		f_print(fout, "#include \"%s\"\n", include);
-+		free(include);
-+	} else
-+	  f_print(fout, "#include <rpc/rpc.h>\n");
-+
-+	f_print(fout, "#include <stdio.h>\n");
-+	f_print(fout, "#include <stdlib.h>/* getenv, exit */\n"); 
-+	if (Cflag) {
-+		f_print (fout, "#include <rpc/pmap_clnt.h> /* for pmap_unset */\n");
-+		f_print (fout, "#include <string.h> /* strcmp */ \n"); 
-+	}
-+	if (strcmp(svcclosetime, "-1") == 0)
-+		indefinitewait = 1;
-+	else if (strcmp(svcclosetime, "0") == 0)
-+		exitnow = 1;
-+	else if (inetdflag || pmflag) {
-+		f_print(fout, "#include <signal.h>\n");
-+	  timerflag = 1;
-+	}
-+
-+#ifndef linux
-+	if( !tirpcflag && inetdflag )
-+	  f_print(fout, "#include <sys/ttycom.h>/* TIOCNOTTY */\n");
-+#else
-+	if( !tirpcflag )
-+	  f_print(fout, "#include <sys/ioctl.h>/* TIOCNOTTY */\n");
-+#endif
-+	if( Cflag && (inetdflag || pmflag ) ) {
-+	  f_print(fout, "#ifdef __cplusplus\n");
-+	  f_print(fout, "#include <sysent.h> /* getdtablesize, open */\n"); 
-+	  f_print(fout, "#endif /* __cplusplus */\n");
-+	  
-+	  if( tirpcflag )
-+	    f_print(fout, "#include <unistd.h> /* setsid */\n");
-+	}
-+	if( tirpcflag )
-+	  f_print(fout, "#include <sys/types.h>\n");
-+
-+	f_print(fout, "#include <memory.h>\n");
-+#ifndef linux
-+	f_print(fout, "#include <stropts.h>\n");
-+#endif
-+	if (inetdflag || !tirpcflag ) {
-+		f_print(fout, "#include <sys/socket.h>\n");
-+		f_print(fout, "#include <netinet/in.h>\n");
-+	} 
-+
-+	if ( (netflag || pmflag) && tirpcflag ) {
-+		f_print(fout, "#include <netconfig.h>\n");
-+	}
-+	if (/*timerflag &&*/ tirpcflag)
-+		f_print(fout, "#include <sys/resource.h> /* rlimit */\n");
-+	if (logflag || inetdflag || pmflag) {
-+#ifdef linux
-+		f_print(fout, "#include <syslog.h>\n");
-+#else
-+		f_print(fout, "#ifdef SYSLOG\n");
-+		f_print(fout, "#include <syslog.h>\n");
-+		f_print(fout, "#else\n");
-+		f_print(fout, "#define LOG_ERR 1\n");
-+		f_print(fout, "#define openlog(a, b, c)\n");
-+		f_print(fout, "#endif\n");
-+#endif
-+	}
-+
-+	/* for ANSI-C */
-+	f_print(fout, "\n#ifdef __STDC__\n#define SIG_PF void(*)(int)\n#endif\n");
-+
-+	f_print(fout, "\n#ifdef DEBUG\n#define RPC_SVC_FG\n#endif\n");
-+	if (timerflag)
-+		f_print(fout, "\n#define _RPCSVC_CLOSEDOWN %s\n", svcclosetime);
-+	while ((def = get_definition()) != NULL) {
-+		foundprogram |= (def->def_kind == DEF_PROGRAM);
-+	}
-+	if (extend && !foundprogram) {
-+		(void) unlink(outfilename);
-+		return;
-+	}
-+	write_most(infile, netflag, nomain);
-+	if (!nomain) {
-+		if( !do_registers(argc, argv) ) {
-+		  if (outfilename)
-+		    (void) unlink(outfilename);
-+		  usage();
-+		}
-+		write_rest();
-+	}
-+}
-+
-+/*
-+ * generate client side stubs
-+ */
-+static void
-+l_output(char *infile, char *define, int extend, char *outfile)
-+{
-+	char *include;
-+	definition *def;
-+	int foundprogram = 0;
-+	char *outfilename;
-+
-+	open_input(infile, define);
-+	outfilename = extend ? extendfile(infile, outfile) : outfile;
-+	open_output(infile, outfilename);
-+	add_warning();
-+	if (Cflag)
-+	  f_print (fout, "#include <memory.h> /* for memset */\n");
-+	if (infile && (include = extendfile(infile, ".h"))) {
-+		f_print(fout, "#include \"%s\"\n", include);
-+		free(include);
-+	} else
-+	  f_print(fout, "#include <rpc/rpc.h>\n");
-+	while ((def = get_definition()) != NULL) {
-+		foundprogram |= (def->def_kind == DEF_PROGRAM);
-+	}
-+	if (extend && !foundprogram) {
-+		(void) unlink(outfilename);
-+		return;
-+	}
-+	write_stubs();
-+}
-+
-+/*
-+ * generate the dispatch table
-+ */
-+static void
-+t_output(char *infile, char *define, int extend, char *outfile)
-+{
-+	definition *def;
-+	int foundprogram = 0;
-+	char *outfilename;
-+
-+	open_input(infile, define);
-+	outfilename = extend ? extendfile(infile, outfile) : outfile;
-+	open_output(infile, outfilename);
-+	add_warning();
-+	while ((def = get_definition()) != NULL) {
-+		foundprogram |= (def->def_kind == DEF_PROGRAM);
-+	}
-+	if (extend && !foundprogram) {
-+		(void) unlink(outfilename);
-+		return;
-+	}
-+	write_tables();
-+}
-+
-+/* sample routine for the server template */
-+static  void
-+svc_output(char *infile, char *define, int extend, char *outfile)
-+{
-+  definition *def;
-+  char *include;
-+  char *outfilename;
-+  long tell;
-+  
-+  open_input(infile, define);	
-+  outfilename = extend ? extendfile(infile, outfile) : outfile;
-+  checkfiles(infile,outfilename); /*check if outfile already exists.
-+				  if so, print an error message and exit*/
-+  open_output(infile, outfilename);
-+  add_sample_msg();
-+
-+  if (infile && (include = extendfile(infile, ".h"))) {
-+    f_print(fout, "#include \"%s\"\n", include);
-+    free(include);
-+  } else
-+    f_print(fout, "#include <rpc/rpc.h>\n");
-+
-+  tell = ftell(fout);
-+  while ((def = get_definition()) != NULL) {
-+	  write_sample_svc(def);
-+  }
-+  if (extend && tell == ftell(fout)) {
-+	  (void) unlink(outfilename);
-+  }
-+}
-+
-+
-+/* sample main routine for client */
-+static  void
-+clnt_output(char *infile, char *define, int extend, char *outfile)
-+{
-+	definition     *def;
-+	char           *include;
-+	char           *outfilename;
-+	long            tell;
-+	int             has_program = 0;
-+
-+	open_input(infile, define);
-+	outfilename = extend ? extendfile(infile, outfile) : outfile;
-+	checkfiles(infile, outfilename);	/*check if outfile already exists.
-+				  if so, print an error message and exit*/
-+
-+	open_output(infile, outfilename);
-+	add_sample_msg();
-+	if (infile && (include = extendfile(infile, ".h"))) {
-+		f_print(fout, "#include \"%s\"\n", include);
-+		free(include);
-+	} else
-+		f_print(fout, "#include <rpc/rpc.h>\n");
-+	tell = ftell(fout);
-+	while ((def = get_definition()) != NULL) {
-+		has_program += write_sample_clnt(def);
-+	}
-+
-+	if (has_program)
-+		write_sample_clnt_main();
-+
-+	if (extend && tell == ftell(fout)) {
-+		(void) unlink(outfilename);
-+	}
-+}
-+
-+/*
-+ * Perform registrations for service output 
-+ * Return 0 if failed; 1 otherwise.
-+ */
-+static int
-+do_registers(int argc, char **argv)
-+{
-+	int             i;
-+
-+	if (inetdflag || !tirpcflag) {
-+		for (i = 1; i < argc; i++) {
-+			if (streq(argv[i], "-s")) {
-+				if (!check_nettype(argv[i + 1], valid_i_nettypes))
-+					return 0;
-+				write_inetd_register(argv[i + 1]);
-+				i++;
-+			}
-+		}
-+	} else {
-+		for (i = 1; i < argc; i++)
-+			if (streq(argv[i], "-s")) {
-+				if (!check_nettype(argv[i + 1], valid_ti_nettypes))
-+					return 0;
-+				write_nettype_register(argv[i + 1]);
-+				i++;
-+			} else if (streq(argv[i], "-n")) {
-+				write_netid_register(argv[i + 1]);
-+				i++;
-+			}
-+	}
-+	return 1;
-+}
-+
-+/*
-+ * Add another argument to the arg list
-+ */
-+static void
-+addarg(char *cp)
-+{
-+	if (argcount >= ARGLISTLEN) {
-+		f_print(stderr, "rpcgen: too many defines\n");
-+		crash();
-+		/*NOTREACHED*/
-+	}
-+	arglist[argcount++] = cp;
-+
-+}
-+
-+static void
-+putarg(int where, char *cp)
-+{
-+	if (where >= ARGLISTLEN) {
-+		f_print(stderr, "rpcgen: arglist coding error\n");
-+		crash();
-+		/*NOTREACHED*/
-+	}
-+	arglist[where] = cp;
-+	
-+}
-+
-+/*
-+ * if input file is stdin and an output file is specified then complain
-+ * if the file already exists. Otherwise the file may get overwritten
-+ * If input file does not exist, exit with an error 
-+ */
-+
-+static void
-+checkfiles(char *infile, char *outfile) 
-+{
-+
-+  struct stat buf;
-+
-+  if(infile)			/* infile ! = NULL */
-+    if(stat(infile,&buf) < 0)
-+      {
-+	perror(infile);
-+	crash();
-+      };
-+  if (outfile) {
-+    if (stat(outfile, &buf) < 0) 
-+      return;			/* file does not exist */
-+    else {
-+      f_print(stderr, 
-+	      "file '%s' already exists and may be overwritten\n", outfile);
-+      crash();
-+    }
-+  }
-+}
-+
-+/*
-+ * Parse command line arguments 
-+ */
-+static int
-+parseargs(int argc, char **argv, struct commandline *cmd)
-+{
-+	int i;
-+	int j;
-+	char c;
-+	char flag[(1 << 8 * sizeof(char))];
-+	int nflags;
-+
-+	cmdname = argv[0];
-+	cmd->infile = cmd->outfile = NULL;
-+	if (argc < 2) {
-+		return (0);
-+	}
-+	allfiles = 0;
-+	flag['c'] = 0;
-+	flag['h'] = 0;
-+	flag['l'] = 0;
-+	flag['m'] = 0;
-+	flag['o'] = 0;
-+	flag['s'] = 0;
-+	flag['n'] = 0;
-+	flag['t'] = 0;
-+	flag['S'] = 0;
-+	flag['C'] = 0;
-+	for (i = 1; i < argc; i++) {
-+		if (argv[i][0] != '-') {
-+			if (cmd->infile) {
-+			        f_print( stderr, "Cannot specify more than one input file!\n");
-+
-+				return (0);
-+			}
-+			cmd->infile = argv[i];
-+		} else {
-+			for (j = 1; argv[i][j] != 0; j++) {
-+				c = argv[i][j];
-+				switch (c) {
-+				case 'a':
-+					allfiles = 1;
-+					break;
-+				case 'c':
-+				case 'h':
-+				case 'l':
-+				case 'm':
-+				case 't':
-+					if (flag[(int) c]) {
-+						return (0);
-+					}
-+					flag[(int) c] = 1;
-+					break;
-+				case 'S':  
-+					/* sample flag: Ss or Sc.
-+					   Ss means set flag['S'];
-+					   Sc means set flag['C']; */
-+					c = argv[i][++j];  /* get next char */
-+					if( c == 's' )
-+					  c = 'S';
-+					else if( c == 'c' )
-+					  c = 'C';
-+					else
-+					  return( 0 );
-+
-+					if (flag[(int) c]) {
-+						return (0);
-+					}
-+					flag[(int) c] = 1;
-+					break;
-+				case 'C':  /* ANSI C syntax */
-+					Cflag = 1;
-+					break;
-+
-+				case 'b':  /* turn TIRPC flag off for
-+					    generating backward compatible
-+					    */
-+					tirpcflag = 0;
-+					break;
-+
-+				case 'I':
-+					inetdflag = 1;
-+					break;
-+				case 'N':
-+					newstyle = 1;
-+					break;
-+				case 'L':
-+					logflag = 1;
-+					break;
-+				case 'K':
-+					if (++i == argc) {
-+						return (0);
-+					}
-+					svcclosetime = argv[i];
-+					goto nextarg;
-+				case 'T':
-+					tblflag = 1;
-+					break;
-+				case 'i' :
-+				  	if (++i == argc) {
-+						return (0);
-+					}
-+					Inline = atoi(argv[i]);
-+					goto nextarg;
-+				case 'n':
-+				case 'o':
-+				case 's':
-+					if (argv[i][j - 1] != '-' || 
-+					    argv[i][j + 1] != 0) {
-+						return (0);
-+					}
-+					flag[(int) c] = 1;
-+					if (++i == argc) {
-+						return (0);
-+					}
-+					if (c == 's') {
-+						if (!streq(argv[i], "udp") &&
-+						    !streq(argv[i], "tcp")) {
-+							return (0);
-+						}
-+					} else if (c == 'o') {
-+						if (cmd->outfile) {
-+							return (0);
-+						}
-+						cmd->outfile = argv[i];
-+					}
-+					goto nextarg;
-+				case 'D':
-+					if (argv[i][j - 1] != '-') {
-+						return (0);
-+					}
-+					(void) addarg(argv[i]);
-+					goto nextarg;
-+				case 'Y':
-+					if (++i == argc) {
-+						return (0);
-+					}
-+					(void) strcpy(pathbuf, argv[i]);
-+					(void) strcat(pathbuf, "/cpp");
-+					CPP = pathbuf;
-+					cppDefined = 1;
-+					goto nextarg;
-+
-+
-+
-+				default:
-+					return (0);
-+				}
-+			}
-+	nextarg:
-+			;
-+		}
-+	}
-+
-+	cmd->cflag = flag['c'];
-+	cmd->hflag = flag['h'];
-+	cmd->lflag = flag['l'];
-+	cmd->mflag = flag['m'];
-+	cmd->nflag = flag['n'];
-+	cmd->sflag = flag['s'];
-+	cmd->tflag = flag['t'];
-+	cmd->Ssflag = flag['S'];
-+	cmd->Scflag = flag['C'];
-+
-+	if( tirpcflag ) {
-+	  pmflag = inetdflag ? 0 : 1;	  /* pmflag or inetdflag is always TRUE */
-+	  if( (inetdflag && cmd->nflag)) { /* netid not allowed with inetdflag */
-+	    f_print(stderr, "Cannot use netid flag with inetd flag!\n");
-+	    return (0);
-+	  }
-+	} else {  /* 4.1 mode */
-+	  pmflag = 0;               /* set pmflag only in tirpcmode */
-+	  inetdflag = 1;            /* inetdflag is TRUE by default */
-+	  if( cmd->nflag ) {          /* netid needs TIRPC */
-+	    f_print( stderr, "Cannot use netid flag without TIRPC!\n");
-+	    return( 0 );
-+	  }
-+	}
-+
-+	if( newstyle && ( tblflag || cmd->tflag) ) {
-+	  f_print( stderr, "Cannot use table flags with newstyle!\n");
-+	  return( 0 );
-+	}
-+
-+	/* check no conflicts with file generation flags */
-+	nflags = cmd->cflag + cmd->hflag + cmd->lflag + cmd->mflag +
-+		cmd->sflag + cmd->nflag + cmd->tflag + cmd->Ssflag + cmd->Scflag;
-+
-+	if (nflags == 0) {
-+		if (cmd->outfile != NULL || cmd->infile == NULL) {
-+			return (0);
-+		}
-+	} else if (nflags > 1) {
-+	        f_print( stderr, "Cannot have more than one file generation flag!\n");
-+		return (0);
-+	}
-+	return (1);
-+}
-+
-+static void
-+usage(void)
-+{
-+	f_print(stderr, "usage:  %s infile\n", cmdname);
-+	f_print(stderr, "\t%s [-a][-b][-C][-Dname[=value]] -i size  [-I [-K seconds]] [-L][-N][-T] infile\n",
-+			cmdname);
-+	f_print(stderr, "\t%s [-c | -h | -l | -m | -t | -Sc | -Ss] [-o outfile] [infile]\n",
-+			cmdname);
-+	f_print(stderr, "\t%s [-s nettype]* [-o outfile] [infile]\n", cmdname);
-+	f_print(stderr, "\t%s [-n netid]* [-o outfile] [infile]\n", cmdname);
-+	options_usage();
-+	exit(1);
-+}
-+
-+static void
-+options_usage(void)
-+{
-+	f_print(stderr, "options:\n");
-+	f_print(stderr, "-a\t\tgenerate all files, including samples\n");
-+	f_print(stderr, "-b\t\tbackward compatibility mode (generates code for SunOS 4.1)\n");
-+	f_print(stderr, "-c\t\tgenerate XDR routines\n");
-+	f_print(stderr, "-C\t\tANSI C mode\n");
-+	f_print(stderr, "-Dname[=value]\tdefine a symbol (same as #define)\n");
-+	f_print(stderr, "-h\t\tgenerate header file\n");
-+	f_print(stderr, "-i size\t\tsize at which to start generating inline code\n");
-+	f_print(stderr, "-I\t\tgenerate code for inetd support in server (for SunOS 4.1)\n");
-+	f_print(stderr, "-K seconds\tserver exits after K seconds of inactivity\n");
-+	f_print(stderr, "-l\t\tgenerate client side stubs\n");
-+	f_print(stderr, "-L\t\tserver errors will be printed to syslog\n");
-+	f_print(stderr, "-m\t\tgenerate server side stubs\n");
-+	f_print(stderr, "-n netid\tgenerate server code that supports named netid\n");
-+	f_print(stderr, "-N\t\tsupports multiple arguments and call-by-value\n");
-+	f_print(stderr, "-o outfile\tname of the output file\n");
-+	f_print(stderr, "-s nettype\tgenerate server code that supports named nettype\n");
-+	f_print(stderr, "-Sc\t\tgenerate sample client code that uses remote procedures\n");
-+	f_print(stderr, "-Ss\t\tgenerate sample server code that defines remote procedures\n");
-+	f_print(stderr, "-t\t\tgenerate RPC dispatch table\n");
-+	f_print(stderr, "-T\t\tgenerate code to support RPC dispatch tables\n");
-+	f_print(stderr, "-Y path\t\tdirectory name to find C preprocessor (cpp)\n");
-+
-+	exit(1);
-+}
-diff --git a/rpcgen/rpc_output.h b/rpcgen/rpc_output.h
-new file mode 100644
-index 0000000..eb25a60
---- /dev/null
-+++ b/rpcgen/rpc_output.h
-@@ -0,0 +1,16 @@
-+/*
-+ * rpc_output.h
-+ *
-+ * Declarations for output functions
-+ *
-+ */
-+
-+#ifndef RPCGEN_NEW_OUTPUT_H
-+#define RPCGEN_NEW_OUTPUT_H
-+
-+void	write_msg_out(void);
-+int	nullproc(proc_list *);
-+void	printarglist(proc_list *, char *, char *);
-+void	pdeclaration(char *, declaration *, int, char *);
-+
-+#endif /* RPCGEN_NEW_OUTPUT_H */
-diff --git a/rpcgen/rpc_parse.c b/rpcgen/rpc_parse.c
-new file mode 100644
-index 0000000..b53a553
---- /dev/null
-+++ b/rpcgen/rpc_parse.c
-@@ -0,0 +1,609 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_parse.c 1.8 89/02/22 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_parse.c, Parser for the RPC protocol compiler 
-+ * Copyright (C) 1987 Sun Microsystems, Inc.
-+ */
-+#include <stdio.h>
-+#include <string.h>
-+#include "rpc/types.h"
-+#include "rpc_scan.h"
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+
-+#define ARGNAME "arg"
-+
-+/*
-+extern char *make_argname();
-+extern char *strdup();
-+ */
-+
-+static void	isdefined(definition *defp);
-+static void	def_struct(definition *defp);
-+static void	def_program(definition *defp);
-+static void	def_enum(definition *defp);
-+static void	def_const(definition *defp);
-+static void	def_union(definition *defp);
-+static void	check_type_name(char *name, int new_type);
-+static void	def_typedef(definition *defp);
-+static void	get_declaration(declaration *dec, defkind dkind);
-+static void	get_prog_declaration(declaration *dec, defkind dkind, int num);
-+static void	get_type(char **prefixp, char **typep, defkind dkind);
-+static void	unsigned_dec(char **typep);
-+
-+/*
-+ * return the next definition you see
-+ */
-+definition *
-+get_definition(void)
-+{
-+	definition *defp;
-+	token tok;
-+
-+	defp = ALLOC(definition);
-+	get_token(&tok);
-+	switch (tok.kind) {
-+	case TOK_STRUCT:
-+		def_struct(defp);
-+		break;
-+	case TOK_UNION:
-+		def_union(defp);
-+		break;
-+	case TOK_TYPEDEF:
-+		def_typedef(defp);
-+		break;
-+	case TOK_ENUM:
-+		def_enum(defp);
-+		break;
-+	case TOK_PROGRAM:
-+		def_program(defp);
-+		break;
-+	case TOK_CONST:
-+		def_const(defp);
-+		break;
-+	case TOK_EOF:
-+		free(defp);
-+		return (NULL);
-+	default:
-+		error("definition keyword expected");
-+	}
-+	scan(TOK_SEMICOLON, &tok);
-+	isdefined(defp);
-+	return (defp);
-+}
-+
-+static void
-+isdefined(definition *defp)
-+{
-+	STOREVAL(&defined, defp);
-+}
-+
-+static void
-+def_struct(definition *defp)
-+{
-+	token tok;
-+	declaration dec;
-+	decl_list *decls;
-+	decl_list **tailp;
-+
-+	defp->def_kind = DEF_STRUCT;
-+
-+	scan(TOK_IDENT, &tok);
-+	defp->def_name = tok.str;
-+	scan(TOK_LBRACE, &tok);
-+	tailp = &defp->def.st.decls;
-+	do {
-+		get_declaration(&dec, DEF_STRUCT);
-+		decls = ALLOC(decl_list);
-+		decls->decl = dec;
-+		*tailp = decls;
-+		tailp = &decls->next;
-+		scan(TOK_SEMICOLON, &tok);
-+		peek(&tok);
-+	} while (tok.kind != TOK_RBRACE);
-+	get_token(&tok);
-+	*tailp = NULL;
-+}
-+
-+static void
-+def_program(definition *defp)
-+{
-+	token tok;
-+	declaration dec;
-+	decl_list *decls;
-+	decl_list **tailp;
-+	version_list *vlist;
-+	version_list **vtailp;
-+	proc_list *plist;
-+	proc_list **ptailp;
-+	int num_args;
-+	bool_t isvoid = FALSE; /* whether first argument is void */
-+	defp->def_kind = DEF_PROGRAM;
-+	scan(TOK_IDENT, &tok);
-+	defp->def_name = tok.str;
-+	scan(TOK_LBRACE, &tok);
-+	vtailp = &defp->def.pr.versions;
-+	tailp = &defp->def.st.decls;
-+	scan(TOK_VERSION, &tok);
-+	do {
-+		scan(TOK_IDENT, &tok);
-+		vlist = ALLOC(version_list);
-+		vlist->vers_name = tok.str;
-+		scan(TOK_LBRACE, &tok);
-+		ptailp = &vlist->procs;
-+		do {
-+			/* get result type */
-+			plist = ALLOC(proc_list);
-+			get_type(&plist->res_prefix, &plist->res_type, 
-+				 DEF_PROGRAM);
-+			if (streq(plist->res_type, "opaque")) {
-+				error("illegal result type");
-+			}
-+			scan(TOK_IDENT, &tok);
-+			plist->proc_name = tok.str;
-+			scan(TOK_LPAREN, &tok);
-+			/* get args - first one*/
-+			num_args = 1;
-+			isvoid = FALSE;
-+			/* type of DEF_PROGRAM in the first 
-+			 * get_prog_declaration and DEF_STURCT in the next
-+			 * allows void as argument if it is the only argument
-+			 */
-+			get_prog_declaration(&dec, DEF_PROGRAM, num_args);
-+			if (streq(dec.type, "void"))
-+			  isvoid = TRUE;
-+			decls = ALLOC(decl_list);
-+			plist->args.decls = decls;
-+			decls->decl = dec;
-+			tailp = &decls->next;
-+			/* get args */
-+			while(peekscan(TOK_COMMA, &tok)) {
-+			  num_args++;
-+			  get_prog_declaration(&dec, DEF_STRUCT, 
-+					       num_args);
-+			  decls = ALLOC(decl_list);
-+			  decls->decl = dec;
-+			  *tailp = decls;
-+			  if (streq(dec.type, "void"))
-+			    isvoid = TRUE;
-+			  tailp = &decls->next;
-+			}
-+			/* multiple arguments are only allowed in newstyle */
-+			if( !newstyle && num_args > 1 ) {
-+			  error("only one argument is allowed" );
-+			}
-+			if (isvoid && num_args > 1) { 
-+			  error("illegal use of void in program definition");
-+			}
-+			*tailp = NULL;
-+			scan(TOK_RPAREN, &tok);
-+			scan(TOK_EQUAL, &tok);
-+			scan_num(&tok);
-+			scan(TOK_SEMICOLON, &tok);
-+			plist->proc_num = tok.str;
-+			plist->arg_num = num_args;
-+			*ptailp = plist;
-+			ptailp = &plist->next;
-+			peek(&tok);
-+		} while (tok.kind != TOK_RBRACE);
-+		*ptailp = NULL;
-+		*vtailp = vlist;
-+		vtailp = &vlist->next;
-+		scan(TOK_RBRACE, &tok);
-+		scan(TOK_EQUAL, &tok);
-+		scan_num(&tok);
-+		vlist->vers_num = tok.str;
-+		/* make the argument structure name for each arg*/
-+		for(plist = vlist->procs; plist != NULL; 
-+		    plist = plist->next) {
-+			plist->args.argname = make_argname(plist->proc_name,
-+							   vlist->vers_num); 
-+			/* free the memory ??*/
-+		}
-+		scan(TOK_SEMICOLON, &tok);
-+		scan2(TOK_VERSION, TOK_RBRACE, &tok);
-+	} while (tok.kind == TOK_VERSION);
-+	scan(TOK_EQUAL, &tok);
-+	scan_num(&tok);
-+	defp->def.pr.prog_num = tok.str;
-+	*vtailp = NULL;
-+}
-+
-+
-+static void
-+def_enum(definition *defp)
-+{
-+	token tok;
-+	enumval_list *elist;
-+	enumval_list **tailp;
-+
-+	defp->def_kind = DEF_ENUM;
-+	scan(TOK_IDENT, &tok);
-+	defp->def_name = tok.str;
-+	scan(TOK_LBRACE, &tok);
-+	tailp = &defp->def.en.vals;
-+	do {
-+		scan(TOK_IDENT, &tok);
-+		elist = ALLOC(enumval_list);
-+		elist->name = tok.str;
-+		elist->assignment = NULL;
-+		scan3(TOK_COMMA, TOK_RBRACE, TOK_EQUAL, &tok);
-+		if (tok.kind == TOK_EQUAL) {
-+			scan_num(&tok);
-+			elist->assignment = tok.str;
-+			scan2(TOK_COMMA, TOK_RBRACE, &tok);
-+		}
-+		*tailp = elist;
-+		tailp = &elist->next;
-+	} while (tok.kind != TOK_RBRACE);
-+	*tailp = NULL;
-+}
-+
-+static void
-+def_const(definition *defp)
-+{
-+	token tok;
-+
-+	defp->def_kind = DEF_CONST;
-+	scan(TOK_IDENT, &tok);
-+	defp->def_name = tok.str;
-+	scan(TOK_EQUAL, &tok);
-+	scan2(TOK_IDENT, TOK_STRCONST, &tok);
-+	defp->def.co = tok.str;
-+}
-+
-+static void
-+def_union(definition *defp)
-+{
-+  token tok;
-+  declaration dec;
-+  case_list *cases;
-+  case_list **tailp;
-+
-+  defp->def_kind = DEF_UNION;
-+  scan(TOK_IDENT, &tok);
-+  defp->def_name = tok.str;
-+  scan(TOK_SWITCH, &tok);
-+  scan(TOK_LPAREN, &tok);
-+  get_declaration(&dec, DEF_UNION);
-+  defp->def.un.enum_decl = dec;
-+  tailp = &defp->def.un.cases;
-+  scan(TOK_RPAREN, &tok);
-+  scan(TOK_LBRACE, &tok);
-+  scan(TOK_CASE, &tok);
-+  while (tok.kind == TOK_CASE) {
-+    scan2(TOK_IDENT, TOK_CHARCONST, &tok);
-+    cases = ALLOC(case_list);
-+    cases->case_name = tok.str;
-+    scan(TOK_COLON, &tok);
-+    /* now peek at next token */
-+    if(peekscan(TOK_CASE,&tok))
-+      {
-+
-+	do 
-+	  {
-+	    scan2(TOK_IDENT, TOK_CHARCONST, &tok);
-+	    cases->contflag=1;	/* continued case statement */
-+	    *tailp = cases;
-+	    tailp = &cases->next;
-+	    cases = ALLOC(case_list);
-+	    cases->case_name = tok.str;
-+	    scan(TOK_COLON, &tok);
-+      
-+	  }while(peekscan(TOK_CASE,&tok));
-+      }
-+
-+    get_declaration(&dec, DEF_UNION);
-+    cases->case_decl = dec;
-+    cases->contflag=0;		/* no continued case statement */
-+    *tailp = cases;
-+    tailp = &cases->next;
-+    scan(TOK_SEMICOLON, &tok);
-+
-+    scan3(TOK_CASE, TOK_DEFAULT, TOK_RBRACE, &tok);
-+  }
-+  *tailp = NULL;
-+  if (tok.kind == TOK_DEFAULT) {
-+    scan(TOK_COLON, &tok);
-+    get_declaration(&dec, DEF_UNION);
-+    defp->def.un.default_decl = ALLOC(declaration);
-+    *defp->def.un.default_decl = dec;
-+    scan(TOK_SEMICOLON, &tok);
-+    scan(TOK_RBRACE, &tok);
-+  } else {
-+    defp->def.un.default_decl = NULL;
-+  }
-+}
-+
-+static char* reserved_words[] =
-+{
-+  "array",
-+  "bytes",
-+  "destroy",
-+  "free",
-+  "getpos",
-+  "inline",
-+  "pointer",
-+  "reference",
-+  "setpos",
-+  "sizeof",
-+  "union",
-+  "vector",
-+  NULL
-+  };
-+
-+static char* reserved_types[] =
-+{
-+  "opaque",
-+  "string",
-+  NULL
-+  };
-+
-+/* check that the given name is not one that would eventually result in
-+   xdr routines that would conflict with internal XDR routines. */
-+static void
-+check_type_name(char *name, int new_type)
-+{
-+  int i;
-+  char tmp[100];
-+
-+  for( i = 0; reserved_words[i] != NULL; i++ ) {
-+    if( strcmp( name, reserved_words[i] ) == 0 ) {
-+      sprintf(tmp, 
-+	      "illegal (reserved) name :\'%s\' in type definition", name );
-+      error(tmp);
-+    }
-+  }
-+  if( new_type ) {
-+    for( i = 0; reserved_types[i] != NULL; i++ ) {
-+      if( strcmp( name, reserved_types[i] ) == 0 ) {
-+	sprintf(tmp, 
-+		"illegal (reserved) name :\'%s\' in type definition", name );
-+	error(tmp);
-+      }
-+    }
-+  }
-+}
-+
-+static void
-+def_typedef(definition *defp)
-+{
-+	declaration dec;
-+
-+	defp->def_kind = DEF_TYPEDEF;
-+	get_declaration(&dec, DEF_TYPEDEF);
-+	defp->def_name = dec.name;
-+	check_type_name( dec.name, 1 );
-+	defp->def.ty.old_prefix = dec.prefix;
-+	defp->def.ty.old_type = dec.type;
-+	defp->def.ty.rel = dec.rel;
-+	defp->def.ty.array_max = dec.array_max;
-+}
-+
-+static void
-+get_declaration(declaration *dec, defkind dkind)
-+{
-+	token tok;
-+
-+	get_type(&dec->prefix, &dec->type, dkind);
-+	dec->rel = REL_ALIAS;
-+	if (streq(dec->type, "void")) {
-+		return;
-+	}
-+
-+	check_type_name( dec->type, 0 );
-+
-+	scan2(TOK_STAR, TOK_IDENT, &tok);
-+	if (tok.kind == TOK_STAR) {
-+		dec->rel = REL_POINTER;
-+		scan(TOK_IDENT, &tok);
-+	}
-+	dec->name = tok.str;
-+	if (peekscan(TOK_LBRACKET, &tok)) {
-+		if (dec->rel == REL_POINTER) {
-+			error("no array-of-pointer declarations -- use typedef");
-+		}
-+		dec->rel = REL_VECTOR;
-+		scan_num(&tok);
-+		dec->array_max = tok.str;
-+		scan(TOK_RBRACKET, &tok);
-+	} else if (peekscan(TOK_LANGLE, &tok)) {
-+		if (dec->rel == REL_POINTER) {
-+			error("no array-of-pointer declarations -- use typedef");
-+		}
-+		dec->rel = REL_ARRAY;
-+		if (peekscan(TOK_RANGLE, &tok)) {
-+			dec->array_max = "~0";	/* unspecified size, use max */
-+		} else {
-+			scan_num(&tok);
-+			dec->array_max = tok.str;
-+			scan(TOK_RANGLE, &tok);
-+		}
-+	}
-+	if (streq(dec->type, "opaque")) {
-+		if (dec->rel != REL_ARRAY && dec->rel != REL_VECTOR) {
-+			error("array declaration expected");
-+		}
-+	} else if (streq(dec->type, "string")) {
-+		if (dec->rel != REL_ARRAY) {
-+			error("variable-length array declaration expected");
-+		}
-+	}
-+}
-+
-+
-+static void
-+get_prog_declaration(declaration *dec, defkind dkind, int num)
-+{
-+	token tok;
-+	char name[10]; /* argument name */
-+
-+	if (dkind == DEF_PROGRAM) { 
-+	  peek(&tok);
-+	  if (tok.kind == TOK_RPAREN) { /* no arguments */
-+	    	dec->rel = REL_ALIAS;
-+		dec->type = "void";
-+		dec->prefix = NULL;
-+		dec->name = NULL;
-+		return;
-+	      }
-+	}
-+	get_type(&dec->prefix, &dec->type, dkind);
-+	dec->rel = REL_ALIAS;
-+	if (peekscan(TOK_IDENT, &tok))  /* optional name of argument */
-+		strcpy(name, tok.str);
-+	else 
-+		sprintf(name, "%s%d", ARGNAME, num); /* default name of argument */
-+
-+	dec->name = (char *) strdup(name); 
-+	
-+	if (streq(dec->type, "void")) {
-+		return;
-+	}
-+
-+	if (streq(dec->type, "opaque")) {
-+		error("opaque -- illegal argument type");
-+	}
-+	if (peekscan(TOK_STAR, &tok)) { 
-+	  if (streq(dec->type, "string")) {
-+	    error("pointer to string not allowed in program arguments\n");
-+	  }
-+		dec->rel = REL_POINTER;
-+		if (peekscan(TOK_IDENT, &tok))  /* optional name of argument */
-+		  dec->name = strdup(tok.str);
-+      }
-+	  if (peekscan(TOK_LANGLE, &tok)) {
-+	    if (!streq(dec->type, "string")) {
-+	      error("arrays cannot be declared as arguments to procedures -- use typedef");
-+	    }
-+		dec->rel = REL_ARRAY;
-+		if (peekscan(TOK_RANGLE, &tok)) {
-+			dec->array_max = "~0";/* unspecified size, use max */
-+		} else {
-+			scan_num(&tok);
-+			dec->array_max = tok.str;
-+			scan(TOK_RANGLE, &tok);
-+		}
-+	}
-+	if (streq(dec->type, "string")) {
-+		if (dec->rel != REL_ARRAY) {  /* .x specifies just string as
-+					       * type of argument 
-+					       * - make it string<>
-+					       */
-+			dec->rel = REL_ARRAY;
-+			dec->array_max = "~0";/* unspecified size, use max */
-+		}
-+	}
-+}
-+
-+
-+
-+static void
-+get_type(char **prefixp, char **typep, defkind dkind)
-+{
-+	token tok;
-+
-+	*prefixp = NULL;
-+	get_token(&tok);
-+	switch (tok.kind) {
-+	case TOK_IDENT:
-+		*typep = tok.str;
-+		break;
-+	case TOK_STRUCT:
-+	case TOK_ENUM:
-+	case TOK_UNION:
-+		*prefixp = tok.str;
-+		scan(TOK_IDENT, &tok);
-+		*typep = tok.str;
-+		break;
-+	case TOK_UNSIGNED:
-+		unsigned_dec(typep);
-+		break;
-+	case TOK_SHORT:
-+		*typep = "short";
-+		(void) peekscan(TOK_INT, &tok);
-+		break;
-+	case TOK_INT32:
-+		*typep = "int32_t";
-+		(void) peekscan(TOK_INT, &tok);
-+		break;
-+	case TOK_VOID:
-+		if (dkind != DEF_UNION && dkind != DEF_PROGRAM) {
-+			error("voids allowed only inside union and program definitions with one argument");
-+		}
-+		*typep = tok.str;
-+		break;
-+	case TOK_STRING:
-+	case TOK_OPAQUE:
-+	case TOK_CHAR:
-+	case TOK_INT:
-+	case TOK_FLOAT:
-+	case TOK_DOUBLE:
-+	case TOK_BOOL:
-+		*typep = tok.str;
-+		break;
-+	default:
-+		error("expected type specifier");
-+	}
-+}
-+
-+static void
-+unsigned_dec(char **typep)
-+{
-+	token tok;
-+
-+	peek(&tok);
-+	switch (tok.kind) {
-+	case TOK_CHAR:
-+		get_token(&tok);
-+		*typep = "u_char";
-+		break;
-+	case TOK_SHORT:
-+		get_token(&tok);
-+		*typep = "u_short";
-+		(void) peekscan(TOK_INT, &tok);
-+		break;
-+	case TOK_INT32:
-+		get_token(&tok);
-+		*typep = "u_int32_";
-+		(void) peekscan(TOK_INT, &tok);
-+		break;
-+	case TOK_INT:
-+		get_token(&tok);
-+		*typep = "u_int";
-+		break;
-+	default:
-+		*typep = "u_int";
-+		break;
-+	}
-+}
-diff --git a/rpcgen/rpc_parse.h b/rpcgen/rpc_parse.h
-new file mode 100644
-index 0000000..2afae10
---- /dev/null
-+++ b/rpcgen/rpc_parse.h
-@@ -0,0 +1,166 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+/*      @(#)rpc_parse.h  1.3  90/08/29  (C) 1987 SMI   */
-+
-+/*
-+ * rpc_parse.h, Definitions for the RPCL parser 
-+ */
-+
-+enum defkind {
-+	DEF_CONST,
-+	DEF_STRUCT,
-+	DEF_UNION,
-+	DEF_ENUM,
-+	DEF_TYPEDEF,
-+	DEF_PROGRAM
-+};
-+typedef enum defkind defkind;
-+
-+typedef char *const_def;
-+
-+enum relation {
-+	REL_VECTOR,	/* fixed length array */
-+	REL_ARRAY,	/* variable length array */
-+	REL_POINTER,	/* pointer */
-+	REL_ALIAS,	/* simple */
-+};
-+typedef enum relation relation;
-+
-+struct typedef_def {
-+	char *old_prefix;
-+	char *old_type;
-+	relation rel;
-+	char *array_max;
-+};
-+typedef struct typedef_def typedef_def;
-+
-+struct enumval_list {
-+	char *name;
-+	char *assignment;
-+	struct enumval_list *next;
-+};
-+typedef struct enumval_list enumval_list;
-+
-+struct enum_def {
-+	enumval_list *vals;
-+};
-+typedef struct enum_def enum_def;
-+
-+struct declaration {
-+	char *prefix;
-+	char *type;
-+	char *name;
-+	relation rel;
-+	char *array_max;
-+};
-+typedef struct declaration declaration;
-+
-+struct decl_list {
-+	declaration decl;
-+	struct decl_list *next;
-+};
-+typedef struct decl_list decl_list;
-+
-+struct struct_def {
-+	decl_list *decls;
-+};
-+typedef struct struct_def struct_def;
-+
-+struct case_list {
-+	char *case_name;
-+	int contflag;
-+	declaration case_decl;
-+	struct case_list *next;
-+};
-+typedef struct case_list case_list;
-+
-+struct union_def {
-+	declaration enum_decl;
-+	case_list *cases;
-+	declaration *default_decl;
-+};
-+typedef struct union_def union_def;
-+
-+struct arg_list {
-+	char *argname; /* name of struct for arg*/
-+	decl_list *decls;
-+};
-+	
-+typedef struct arg_list arg_list;
-+
-+struct proc_list {
-+	char *proc_name;
-+	char *proc_num;
-+	arg_list args;
-+	int arg_num;
-+	char *res_type;
-+	char *res_prefix;
-+	struct proc_list *next;
-+};
-+typedef struct proc_list proc_list;
-+
-+struct version_list {
-+	char *vers_name;
-+	char *vers_num;
-+	proc_list *procs;
-+	struct version_list *next;
-+};
-+typedef struct version_list version_list;
-+
-+struct program_def {
-+	char *prog_num;
-+	version_list *versions;
-+};
-+typedef struct program_def program_def;
-+
-+struct definition {
-+	char *def_name;
-+	defkind def_kind;
-+	union {
-+		const_def co;
-+		struct_def st;
-+		union_def un;
-+		enum_def en;
-+		typedef_def ty;
-+		program_def pr;
-+	} def;
-+};
-+typedef struct definition definition;
-+
-+definition *get_definition();
-+
-+
-+struct bas_type
-+{
-+  char *name;
-+  int length;
-+  struct bas_type *next;
-+};
-+
-+typedef struct bas_type bas_type;
-diff --git a/rpcgen/rpc_sample.c b/rpcgen/rpc_sample.c
-new file mode 100644
-index 0000000..2b5c81b
---- /dev/null
-+++ b/rpcgen/rpc_sample.c
-@@ -0,0 +1,247 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_sample.c  1.1  90/08/30  (C) 1987 SMI";
-+
-+#endif
-+
-+/*
-+ * rpc_sample.c, Sample client-server code outputter for the RPC protocol compiler
-+ */
-+
-+#include <stdio.h>
-+#include <string.h>
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+
-+
-+static char RQSTP[] = "rqstp";
-+
-+static void	write_sample_client(char *program_name, version_list *vp);
-+static void	write_sample_server(definition * def);
-+static void	return_type(proc_list *plist);
-+
-+void
-+write_sample_svc(definition *def)
-+{
-+	if (def->def_kind != DEF_PROGRAM)
-+		return;
-+	write_sample_server(def);
-+}
-+
-+
-+int
-+write_sample_clnt(definition *def)
-+{
-+	version_list   *vp;
-+	int             count = 0;
-+
-+	if (def->def_kind != DEF_PROGRAM)
-+		return (0);
-+	/* generate sample code for each version */
-+	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+		write_sample_client(def->def_name, vp);
-+		++count;
-+	}
-+	return (count);
-+}
-+
-+
-+static void
-+write_sample_client(char *program_name, version_list *vp)
-+{
-+	proc_list      *proc;
-+	int             i;
-+	decl_list      *l;
-+
-+	f_print(fout, "\n\nvoid\n");
-+	pvname(program_name, vp->vers_num);
-+	if (Cflag)
-+		f_print(fout, "( char* host )\n{\n");
-+	else
-+		f_print(fout, "(host)\nchar *host;\n{\n");
-+	f_print(fout, "\tCLIENT *clnt;\n");
-+
-+	i = 0;
-+	for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+		f_print(fout, "\t");
-+		ptype(proc->res_prefix, proc->res_type, 1);
-+		f_print(fout, " *result_%d;\n", ++i);
-+		/* print out declarations for arguments */
-+		if (proc->arg_num < 2 && !newstyle) {
-+			f_print(fout, "\t");
-+			if (!streq(proc->args.decls->decl.type, "void"))
-+				ptype(proc->args.decls->decl.prefix, proc->args.decls->decl.type, 1);
-+			else
-+				f_print(fout, "char* ");	/* cannot have "void" type */
-+			f_print(fout, " ");
-+			pvname(proc->proc_name, vp->vers_num);
-+			f_print(fout, "_arg;\n");
-+		} else if (!streq(proc->args.decls->decl.type, "void")) {
-+			for (l = proc->args.decls; l != NULL; l = l->next) {
-+				f_print(fout, "\t");
-+				ptype(l->decl.prefix, l->decl.type, 1);
-+				f_print(fout, " ");
-+				pvname(proc->proc_name, vp->vers_num);
-+				f_print(fout, "_%s;\n", l->decl.name);
-+				/*	  pdeclaration(proc->args.argname, &l->decl, 1, ";\n" );*/
-+			}
-+		}
-+	}
-+
-+	/* generate creation of client handle */
-+	f_print(fout, "\tclnt = clnt_create(host, %s, %s, \"%s\");\n",
-+		program_name, vp->vers_name, tirpcflag ? "netpath" : "udp");
-+	f_print(fout, "\tif (clnt == NULL) {\n");
-+	f_print(fout, "\t\tclnt_pcreateerror(host);\n");
-+	f_print(fout, "\t\texit(1);\n\t}\n");
-+
-+	/* generate calls to procedures */
-+	i = 0;
-+	for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+		f_print(fout, "\tresult_%d = ", ++i);
-+		pvname(proc->proc_name, vp->vers_num);
-+		if (proc->arg_num < 2 && !newstyle) {
-+			f_print(fout, "(");
-+			if (streq(proc->args.decls->decl.type, "void"))	/* cast to void* */
-+				f_print(fout, "(void*)");
-+			f_print(fout, "&");
-+			pvname(proc->proc_name, vp->vers_num);
-+			f_print(fout, "_arg, clnt);\n");
-+		} else if (streq(proc->args.decls->decl.type, "void")) {
-+			f_print(fout, "(clnt);\n");
-+		} else {
-+			f_print(fout, "(");
-+			for (l = proc->args.decls; l != NULL; l = l->next) {
-+				pvname(proc->proc_name, vp->vers_num);
-+				f_print(fout, "_%s, ", l->decl.name);
-+			}
-+			f_print(fout, "clnt);\n");
-+		}
-+		f_print(fout, "\tif (result_%d == NULL) {\n", i);
-+		f_print(fout, "\t\tclnt_perror(clnt, \"call failed:\");\n");
-+		f_print(fout, "\t}\n");
-+	}
-+
-+	f_print(fout, "\tclnt_destroy( clnt );\n");
-+	f_print(fout, "}\n");
-+}
-+
-+static void
-+write_sample_server(definition * def)
-+{
-+	version_list   *vp;
-+	proc_list      *proc;
-+
-+	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+		for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+			f_print(fout, "\n");
-+			/*			if( Cflag )
-+			  f_print( fout, "extern \"C\"{\n");
-+*/
-+			return_type(proc);
-+			f_print(fout, "* \n");
-+			if (Cflag)
-+				pvname_svc(proc->proc_name, vp->vers_num);
-+			else
-+				pvname(proc->proc_name, vp->vers_num);
-+			printarglist(proc, RQSTP, "struct svc_req *");
-+
-+			f_print(fout, "{\n");
-+			f_print(fout, "\n\tstatic ");
-+			if (!streq(proc->res_type, "void"))
-+				return_type(proc);
-+			else
-+				f_print(fout, "char*");	/* cannot have void type */
-+			/* f_print(fout, " result;\n", proc->res_type); */
-+			f_print(fout, " result;\n");
-+			f_print(fout,
-+				"\n\t/*\n\t * insert server code here\n\t */\n\n");
-+			if (!streq(proc->res_type, "void"))
-+				f_print(fout, "\treturn(&result);\n}\n");
-+			else	/* cast back to void * */
-+				f_print(fout, "\treturn((void*) &result);\n}\n");
-+			/*			if( Cflag)
-+			  f_print( fout, "};\n");
-+*/
-+
-+		}
-+	}
-+}
-+
-+
-+
-+static void
-+return_type(proc_list *plist)
-+{
-+	ptype( plist->res_prefix, plist->res_type, 1 );
-+}
-+
-+void
-+add_sample_msg(void)
-+{
-+	f_print(fout, "/*\n");
-+	f_print(fout, " * This is sample code generated by rpcgen.\n");
-+	f_print(fout, " * These are only templates and you can use them\n");
-+	f_print(fout, " * as a guideline for developing your own functions.\n");
-+	f_print(fout, " */\n\n");
-+}
-+
-+void
-+write_sample_clnt_main(void)
-+{
-+  list *l;
-+  definition *def;
-+  version_list *vp;
-+
-+  f_print(fout, "\n\n" );
-+  if( Cflag )
-+    f_print(fout,"main( int argc, char* argv[] )\n{\n" );
-+  else
-+    f_print(fout, "main(argc, argv)\nint argc;\nchar *argv[];\n{\n" );
-+
-+  f_print(fout, "\tchar *host;");
-+  f_print(fout, "\n\n\tif(argc < 2) {");
-+  f_print(fout, "\n\t\tprintf(\"usage: %%s server_host\\n\", argv[0]);\n" );
-+  f_print(fout, "\t\texit(1);\n\t}");
-+  f_print(fout, "\n\thost = argv[1];\n");
-+
-+  for (l = defined; l != NULL; l = l->next) {
-+		def = l->val;
-+		if (def->def_kind != DEF_PROGRAM) {
-+			continue;
-+		}
-+		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+		        f_print( fout, "\t" );
-+			pvname(def->def_name, vp->vers_num);
-+			f_print( fout, "( host );\n" );
-+		      }
-+		}
-+  f_print(fout, "}\n");
-+}
-diff --git a/rpcgen/rpc_scan.c b/rpcgen/rpc_scan.c
-new file mode 100644
-index 0000000..f58fa9f
---- /dev/null
-+++ b/rpcgen/rpc_scan.c
-@@ -0,0 +1,474 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_scan.c 1.11 89/02/22 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_scan.c, Scanner for the RPC protocol compiler 
-+ * Copyright (C) 1987, Sun Microsystems, Inc. 
-+ */
-+#include <stdio.h>
-+#include <ctype.h>
-+#include <string.h>
-+#include "rpc_scan.h"
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+
-+static void	unget_token(token *tokp);
-+static void	findstrconst(char **str, char **val);
-+static void	findchrconst(char **str, char **val);
-+static void	findconst(char **str, char **val);
-+static void	findkind(char **mark, token *tokp);
-+static int	cppline(char *line);
-+static int	directive(char *line);
-+static void	printdirective(char *line);
-+static void	docppline(char *line, int *lineno, char **fname);
-+
-+#define startcomment(where) (where[0] == '/' && where[1] == '*')
-+#define endcomment(where) (where[-1] == '*' && where[0] == '/')
-+
-+static int pushed = 0;	/* is a token pushed */
-+static token lasttok;	/* last token, if pushed */
-+
-+/*
-+ * scan expecting 1 given token 
-+ */
-+void
-+scan(tok_kind expect, token *tokp)
-+{
-+	get_token(tokp);
-+	if (tokp->kind != expect) {
-+		expected1(expect);
-+	}
-+}
-+
-+/*
-+ * scan expecting any of the 2 given tokens 
-+ */
-+void
-+scan2(tok_kind expect1, tok_kind expect2, token *tokp)
-+{
-+	get_token(tokp);
-+	if (tokp->kind != expect1 && tokp->kind != expect2) {
-+		expected2(expect1, expect2);
-+	}
-+}
-+
-+/*
-+ * scan expecting any of the 3 given token 
-+ */
-+void
-+scan3(tok_kind expect1, tok_kind expect2, tok_kind expect3, token *tokp)
-+{
-+	get_token(tokp);
-+	if (tokp->kind != expect1 && tokp->kind != expect2
-+	    && tokp->kind != expect3) {
-+		expected3(expect1, expect2, expect3);
-+	}
-+}
-+
-+/*
-+ * scan expecting a constant, possibly symbolic 
-+ */
-+void
-+scan_num(token *tokp)
-+{
-+	get_token(tokp);
-+	switch (tokp->kind) {
-+	case TOK_IDENT:
-+		break;
-+	default:
-+		error("constant or identifier expected");
-+	}
-+}
-+
-+/*
-+ * Peek at the next token 
-+ */
-+void
-+peek(token *tokp)
-+{
-+	get_token(tokp);
-+	unget_token(tokp);
-+}
-+
-+/*
-+ * Peek at the next token and scan it if it matches what you expect 
-+ */
-+int
-+peekscan(tok_kind expect, token *tokp)
-+{
-+	peek(tokp);
-+	if (tokp->kind == expect) {
-+		get_token(tokp);
-+		return (1);
-+	}
-+	return (0);
-+}
-+
-+/*
-+ * Get the next token, printing out any directive that are encountered. 
-+ */
-+void
-+get_token(token *tokp)
-+{
-+	int commenting;
-+
-+	if (pushed) {
-+		pushed = 0;
-+		*tokp = lasttok;
-+		return;
-+	}
-+	commenting = 0;
-+	for (;;) {
-+		if (*where == 0) {
-+			for (;;) {
-+				if (!fgets(curline, MAXLINESIZE, fin)) {
-+					tokp->kind = TOK_EOF;
-+					*where = 0;
-+					return;
-+				}
-+				linenum++;
-+				if (commenting) {
-+					break;
-+				} else if (cppline(curline)) {
-+					docppline(curline, &linenum, 
-+						  &infilename);
-+				} else if (directive(curline)) {
-+					printdirective(curline);
-+				} else {
-+					break;
-+				}
-+			}
-+			where = curline;
-+		} else if (isspace(*where)) {
-+			while (isspace(*where)) {
-+				where++;	/* eat */
-+			}
-+		} else if (commenting) {
-+			for (where++; *where; where++) {
-+				if (endcomment(where)) {
-+					where++;
-+					commenting--;
-+					break;
-+				}
-+			}
-+		} else if (startcomment(where)) {
-+			where += 2;
-+			commenting++;
-+		} else {
-+			break;
-+		}
-+	}
-+
-+	/*
-+	 * 'where' is not whitespace, comment or directive Must be a token! 
-+	 */
-+	switch (*where) {
-+	case ':':
-+		tokp->kind = TOK_COLON;
-+		where++;
-+		break;
-+	case ';':
-+		tokp->kind = TOK_SEMICOLON;
-+		where++;
-+		break;
-+	case ',':
-+		tokp->kind = TOK_COMMA;
-+		where++;
-+		break;
-+	case '=':
-+		tokp->kind = TOK_EQUAL;
-+		where++;
-+		break;
-+	case '*':
-+		tokp->kind = TOK_STAR;
-+		where++;
-+		break;
-+	case '[':
-+		tokp->kind = TOK_LBRACKET;
-+		where++;
-+		break;
-+	case ']':
-+		tokp->kind = TOK_RBRACKET;
-+		where++;
-+		break;
-+	case '{':
-+		tokp->kind = TOK_LBRACE;
-+		where++;
-+		break;
-+	case '}':
-+		tokp->kind = TOK_RBRACE;
-+		where++;
-+		break;
-+	case '(':
-+		tokp->kind = TOK_LPAREN;
-+		where++;
-+		break;
-+	case ')':
-+		tokp->kind = TOK_RPAREN;
-+		where++;
-+		break;
-+	case '<':
-+		tokp->kind = TOK_LANGLE;
-+		where++;
-+		break;
-+	case '>':
-+		tokp->kind = TOK_RANGLE;
-+		where++;
-+		break;
-+
-+	case '"':
-+		tokp->kind = TOK_STRCONST;
-+		findstrconst(&where, &tokp->str);
-+		break;
-+	case '\'':
-+		tokp->kind = TOK_CHARCONST;
-+		findchrconst(&where, &tokp->str);
-+		break;
-+
-+	case '-':
-+	case '0':
-+	case '1':
-+	case '2':
-+	case '3':
-+	case '4':
-+	case '5':
-+	case '6':
-+	case '7':
-+	case '8':
-+	case '9':
-+		tokp->kind = TOK_IDENT;
-+		findconst(&where, &tokp->str);
-+		break;
-+
-+	default:
-+		if (!(isalpha(*where) || *where == '_')) {
-+			char buf[100];
-+			char *p;
-+
-+			s_print(buf, "illegal character in file: ");
-+			p = buf + strlen(buf);
-+			if (isprint(*where)) {
-+				s_print(p, "%c", *where);
-+			} else {
-+				s_print(p, "%d", *where);
-+			}
-+			error(buf);
-+		}
-+		findkind(&where, tokp);
-+		break;
-+	}
-+}
-+
-+static void
-+unget_token(token *tokp)
-+{
-+	lasttok = *tokp;
-+	pushed = 1;
-+}
-+
-+static void
-+findstrconst(char **str, char **val)
-+{
-+	char *p;
-+	int size;
-+
-+	p = *str;
-+	do {
-+		*p++;
-+	} while (*p && *p != '"');
-+	if (*p == 0) {
-+		error("unterminated string constant");
-+	}
-+	p++;
-+	size = p - *str;
-+	*val = alloc(size + 1);
-+	(void) strncpy(*val, *str, size);
-+	(*val)[size] = 0;
-+	*str = p;
-+}
-+
-+static void
-+findchrconst(char **str, char **val)
-+{
-+	char *p;
-+	int size;
-+
-+	p = *str;
-+	do {
-+		*p++;
-+	} while (*p && *p != '\'');
-+	if (*p == 0) {
-+		error("unterminated string constant");
-+	}
-+	p++;
-+	size = p - *str;
-+	if (size != 3) {
-+		error("empty char string");
-+	}
-+	*val = alloc(size + 1);
-+	(void) strncpy(*val, *str, size);
-+	(*val)[size] = 0;
-+	*str = p;
-+}
-+
-+static void
-+findconst(char **str, char **val)
-+{
-+	char *p;
-+	int size;
-+
-+	p = *str;
-+	if (*p == '0' && *(p + 1) == 'x') {
-+		p++;
-+		do {
-+			p++;
-+		} while (isxdigit(*p));
-+	} else {
-+		do {
-+			p++;
-+		} while (isdigit(*p));
-+	}
-+	size = p - *str;
-+	*val = alloc(size + 1);
-+	(void) strncpy(*val, *str, size);
-+	(*val)[size] = 0;
-+	*str = p;
-+}
-+
-+static token symbols[] = {
-+			  {TOK_CONST, "const"},
-+			  {TOK_UNION, "union"},
-+			  {TOK_SWITCH, "switch"},
-+			  {TOK_CASE, "case"},
-+			  {TOK_DEFAULT, "default"},
-+			  {TOK_STRUCT, "struct"},
-+			  {TOK_TYPEDEF, "typedef"},
-+			  {TOK_ENUM, "enum"},
-+			  {TOK_OPAQUE, "opaque"},
-+			  {TOK_BOOL, "bool"},
-+			  {TOK_VOID, "void"},
-+			  {TOK_CHAR, "char"},
-+			  {TOK_INT, "int"},
-+			  {TOK_UNSIGNED, "unsigned"},
-+			  {TOK_SHORT, "short"},
-+			  {TOK_INT32, "int32"},
-+			  {TOK_FLOAT, "float"},
-+			  {TOK_DOUBLE, "double"},
-+			  {TOK_STRING, "string"},
-+			  {TOK_PROGRAM, "program"},
-+			  {TOK_VERSION, "version"},
-+			  {TOK_EOF, "??????"},
-+};
-+
-+static void
-+findkind(char **mark, token *tokp)
-+{
-+	int len;
-+	token *s;
-+	char *str;
-+
-+	str = *mark;
-+	for (s = symbols; s->kind != TOK_EOF; s++) {
-+		len = strlen(s->str);
-+		if (strncmp(str, s->str, len) == 0) {
-+			if (!isalnum(str[len]) && str[len] != '_') {
-+				tokp->kind = s->kind;
-+				tokp->str = s->str;
-+				*mark = str + len;
-+				return;
-+			}
-+		}
-+	}
-+	tokp->kind = TOK_IDENT;
-+	for (len = 0; isalnum(str[len]) || str[len] == '_'; len++);
-+	tokp->str = alloc(len + 1);
-+	(void) strncpy(tokp->str, str, len);
-+	tokp->str[len] = 0;
-+	*mark = str + len;
-+}
-+
-+static int
-+cppline(char *line)
-+{
-+	return (line == curline && *line == '#');
-+}
-+
-+static int
-+directive(char *line)
-+{
-+	return (line == curline && *line == '%');
-+}
-+
-+static void
-+printdirective(char *line)
-+{
-+	f_print(fout, "%s", line + 1);
-+}
-+
-+static void
-+docppline(char *line, int *lineno, char **fname)
-+{
-+	char *file;
-+	int num;
-+	char *p;
-+
-+	line++;
-+	while (isspace(*line)) {
-+		line++;
-+	}
-+	num = atoi(line);
-+	while (isdigit(*line)) {
-+		line++;
-+	}
-+	while (isspace(*line)) {
-+		line++;
-+	}
-+	if (*line != '"') {
-+		error("preprocessor error");
-+	}
-+	line++;
-+	p = file = alloc(strlen(line) + 1);
-+	while (*line && *line != '"') {
-+		*p++ = *line++;
-+	}
-+	if (*line == 0) {
-+		error("preprocessor error");
-+	}
-+	*p = 0;
-+	if (*file == 0) {
-+		*fname = NULL;
-+		free(file);
-+	} else {
-+		*fname = file;
-+	}
-+	*lineno = num - 1;
-+}
-diff --git a/rpcgen/rpc_scan.h b/rpcgen/rpc_scan.h
-new file mode 100644
-index 0000000..16f688c
---- /dev/null
-+++ b/rpcgen/rpc_scan.h
-@@ -0,0 +1,103 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+/*      @(#)rpc_scan.h  1.3  90/08/29  (C) 1987 SMI   */
-+
-+/*
-+ * rpc_scan.h, Definitions for the RPCL scanner 
-+ */
-+
-+/*
-+ * kinds of tokens 
-+ */
-+enum tok_kind {
-+	TOK_IDENT,
-+	TOK_CHARCONST,
-+	TOK_STRCONST,
-+	TOK_LPAREN,
-+	TOK_RPAREN,
-+	TOK_LBRACE,
-+	TOK_RBRACE,
-+	TOK_LBRACKET,
-+	TOK_RBRACKET,
-+	TOK_LANGLE,
-+	TOK_RANGLE,
-+	TOK_STAR,
-+	TOK_COMMA,
-+	TOK_EQUAL,
-+	TOK_COLON,
-+	TOK_SEMICOLON,
-+	TOK_CONST,
-+	TOK_STRUCT,
-+	TOK_UNION,
-+	TOK_SWITCH,
-+	TOK_CASE,
-+	TOK_DEFAULT,
-+	TOK_ENUM,
-+	TOK_TYPEDEF,
-+	TOK_INT,
-+	TOK_SHORT,
-+	TOK_INT32,
-+	TOK_UNSIGNED,
-+	TOK_FLOAT,
-+	TOK_DOUBLE,
-+	TOK_OPAQUE,
-+	TOK_CHAR,
-+	TOK_STRING,
-+	TOK_BOOL,
-+	TOK_VOID,
-+	TOK_PROGRAM,
-+	TOK_VERSION,
-+	TOK_EOF
-+};
-+typedef enum tok_kind tok_kind;
-+
-+/*
-+ * a token 
-+ */
-+struct token {
-+	tok_kind kind;
-+	char *str;
-+};
-+typedef struct token token;
-+
-+
-+/*
-+ * routine interface 
-+ */
-+void            scan();
-+void            scan2();
-+void            scan3();
-+void            scan_num();
-+void            peek();
-+int             peekscan();
-+void            get_token();
-+void            expected1(tok_kind);
-+void            expected2(tok_kind, tok_kind);
-+void            expected3(tok_kind, tok_kind, tok_kind);
-+
-diff --git a/rpcgen/rpc_svcout.c b/rpcgen/rpc_svcout.c
-new file mode 100644
-index 0000000..284a529
---- /dev/null
-+++ b/rpcgen/rpc_svcout.c
-@@ -0,0 +1,882 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+ static char sccsid[] = "@(#)rpc_svcout.c 1.29 89/03/30 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_svcout.c, Server-skeleton outputter for the RPC protocol compiler
-+ */
-+#include <stdio.h>
-+#include <string.h>
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+#include "rpc_output.h"
-+
-+static void	write_real_program(definition *def);
-+static void	write_program(definition *def, char *storage);
-+static void	printerr(char *err, char *transp);
-+static void	printif(char *proc, char *transp, char *prefix, char *arg);
-+static void	write_inetmost(char *infile);
-+static void	print_return(char *space);
-+static void	print_pmapunset(char *space);
-+static void	print_err_message(char *space);
-+static void	write_timeout_func(void);
-+static void	write_pm_most(char *infile, int netflag);
-+static void	write_rpc_svc_fg(char *infile, char *sp);
-+static void	open_log_file(char *infile, char *sp);
-+
-+static char RQSTP[] = "rqstp";
-+static char TRANSP[] = "transp";
-+static char ARG[] = "argument";
-+static char RESULT[] = "result";
-+static char ROUTINE[] = "local";
-+
-+char _errbuf[256];	/* For all messages */
-+
-+static void
-+p_xdrfunc(char *rname, char *typename)
-+{
-+	if (Cflag)
-+		f_print(fout, "\t\txdr_%s = (xdrproc_t) xdr_%s;\n", rname,
-+			stringfix(typename));
-+	else
-+		f_print(fout, "\t\txdr_%s = xdr_%s;\n", rname, stringfix(typename));
-+}
-+
-+void
-+internal_proctype(proc_list *plist)
-+{
-+	f_print(fout, "static ");
-+	ptype( plist->res_prefix, plist->res_type, 1 );
-+	f_print( fout, "*" );
-+}
-+
-+
-+/*
-+ * write most of the service, that is, everything but the registrations. 
-+ */
-+void
-+write_most(char *infile, int netflag, int nomain)
-+{
-+	if (inetdflag || pmflag) {
-+	        char* var_type;
-+		var_type = (nomain? "extern" : "static");
-+		f_print(fout, "%s int _rpcpmstart;", var_type );
-+		f_print(fout, "\t\t/* Started by a port monitor ? */\n"); 
-+		f_print(fout, "%s int _rpcfdtype;", var_type );
-+		f_print(fout, "\t\t/* Whether Stream or Datagram ? */\n");
-+		if (timerflag) {
-+			f_print(fout, "%s int _rpcsvcdirty;", var_type );
-+			f_print(fout, "\t/* Still serving ? */\n");
-+		}
-+		write_svc_aux( nomain );
-+	}
-+	/* write out dispatcher and stubs */
-+	write_programs( nomain? (char *)NULL : "static" );
-+
-+        if( nomain ) 
-+	  return;
-+
-+	f_print(fout, "\nmain()\n");
-+	f_print(fout, "{\n");
-+	if (inetdflag) {
-+		write_inetmost(infile); /* Includes call to write_rpc_svc_fg() */
-+	} else {
-+	  if( tirpcflag ) {
-+		if (netflag) {
-+			f_print(fout, "\tregister SVCXPRT *%s;\n", TRANSP);
-+			f_print(fout, "\tstruct netconfig *nconf = NULL;\n");
-+		}
-+		f_print(fout, "\tpid_t pid;\n");
-+		f_print(fout, "\tint i;\n");
-+		f_print(fout, "\tchar mname[FMNAMESZ + 1];\n\n");
-+		write_pm_most(infile, netflag);
-+		f_print(fout, "\telse {\n");
-+		write_rpc_svc_fg(infile, "\t\t");
-+		f_print(fout, "\t}\n");
-+	      } else {
-+		f_print(fout, "\tregister SVCXPRT *%s;\n", TRANSP);
-+		f_print(fout, "\n");
-+		print_pmapunset("\t");
-+	      }
-+	}
-+
-+	if (logflag && !inetdflag) {
-+		open_log_file(infile, "\t");
-+	}
-+}
-+
-+/*
-+ * write a registration for the given transport 
-+ */
-+void
-+write_netid_register(char *transp)
-+{
-+	list *l;
-+	definition *def;
-+	version_list *vp;
-+	char *sp;
-+	char tmpbuf[32];
-+
-+	sp = "";
-+	f_print(fout, "\n");
-+	f_print(fout, "%s\tnconf = getnetconfigent(\"%s\");\n", sp, transp);
-+	f_print(fout, "%s\tif (nconf == NULL) {\n", sp);
-+	(void) sprintf(_errbuf, "cannot find %s netid.", transp);
-+	sprintf(tmpbuf, "%s\t\t", sp);
-+	print_err_message(tmpbuf);
-+	f_print(fout, "%s\t\texit(1);\n", sp);
-+	f_print(fout, "%s\t}\n", sp);
-+	f_print(fout, "%s\t%s = svc_tli_create(RPC_ANYFD, nconf, 0, 0, 0);\n",
-+			sp, TRANSP);
-+	f_print(fout, "%s\tif (%s == NULL) {\n", sp, TRANSP);
-+	(void) sprintf(_errbuf, "cannot create %s service.", transp);
-+	print_err_message(tmpbuf);
-+	f_print(fout, "%s\t\texit(1);\n", sp);
-+	f_print(fout, "%s\t}\n", sp);
-+
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind != DEF_PROGRAM) {
-+			continue;
-+		}
-+		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+			f_print(fout,
-+				"%s\t(void) rpcb_unset(%s, %s, nconf);\n",
-+				sp, def->def_name, vp->vers_name);
-+			f_print(fout,
-+				"%s\tif (!svc_reg(%s, %s, %s, ",
-+				sp, TRANSP, def->def_name, vp->vers_name);
-+			pvname(def->def_name, vp->vers_num);
-+			f_print(fout, ", nconf)) {\n");
-+			(void) sprintf(_errbuf, "unable to register (%s, %s, %s).",
-+					def->def_name, vp->vers_name, transp);
-+			print_err_message(tmpbuf);
-+			f_print(fout, "%s\t\texit(1);\n", sp);
-+			f_print(fout, "%s\t}\n", sp);
-+		}
-+	}
-+	f_print(fout, "%s\tfreenetconfigent(nconf);\n", sp);
-+}
-+
-+/*
-+ * write a registration for the given transport for TLI
-+ */
-+void
-+write_nettype_register(char *transp)
-+{
-+	list *l;
-+	definition *def;
-+	version_list *vp;
-+
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind != DEF_PROGRAM) {
-+			continue;
-+		}
-+		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+			f_print(fout, "\tif (!svc_create(");
-+			pvname(def->def_name, vp->vers_num);
-+			f_print(fout, ", %s, %s, \"%s\")) {\n ",
-+				def->def_name, vp->vers_name, transp);
-+			(void) sprintf(_errbuf,
-+				"unable to create (%s, %s) for %s.",
-+					def->def_name, vp->vers_name, transp);
-+			print_err_message("\t\t");
-+			f_print(fout, "\t\texit(1);\n");
-+			f_print(fout, "\t}\n");
-+		}
-+	}
-+}
-+
-+/*
-+ * write the rest of the service 
-+ */
-+void
-+write_rest(void)
-+{
-+	f_print(fout, "\n");
-+	if (inetdflag) {
-+		f_print(fout, "\tif (%s == (SVCXPRT *)NULL) {\n", TRANSP);
-+		(void) sprintf(_errbuf, "could not create a handle");
-+		print_err_message("\t\t");
-+		f_print(fout, "\t\texit(1);\n");
-+		f_print(fout, "\t}\n");
-+		if (timerflag) {
-+			f_print(fout, "\tif (_rpcpmstart) {\n");
-+			f_print(fout, 
-+				"\t\t(void) signal(SIGALRM, %s closedown);\n",
-+				Cflag? "(SIG_PF)" : "(void(*)())" );
-+			f_print(fout, "\t\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
-+			f_print(fout, "\t}\n");
-+		}
-+	}
-+	f_print(fout, "\tsvc_run();\n");
-+	(void) sprintf(_errbuf, "svc_run returned");
-+	print_err_message("\t");
-+	f_print(fout, "\texit(1);\n");
-+	f_print(fout, "\t/* NOTREACHED */\n");
-+	f_print(fout, "}\n");
-+}
-+
-+void
-+write_programs(char *storage)
-+{
-+	list *l;
-+	definition *def;
-+
-+	/* write out stubs for procedure  definitions */
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind == DEF_PROGRAM) {
-+			write_real_program(def);
-+		}
-+	}
-+
-+	/* write out dispatcher for each program */
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind == DEF_PROGRAM) {
-+			write_program(def, storage);
-+		}
-+	}
-+
-+
-+}
-+
-+/* write out definition of internal function (e.g. _printmsg_1(...))
-+   which calls server's defintion of actual function (e.g. printmsg_1(...)).
-+   Unpacks single user argument of printmsg_1 to call-by-value format
-+   expected by printmsg_1. */
-+static void
-+write_real_program(definition *def)
-+{
-+	version_list *vp;
-+	proc_list *proc;
-+	decl_list *l;
-+
-+	if( !newstyle ) return;  /* not needed for old style */
-+	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+		for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+			f_print(fout, "\n");
-+			internal_proctype(proc);
-+			f_print(fout, "\n_");
-+			pvname(proc->proc_name, vp->vers_num);
-+			if( Cflag ) {
-+			  f_print(fout, "(" );
-+			  /* arg name */
-+			  if (proc->arg_num > 1)
-+			    f_print(fout, proc->args.argname);
-+			  else
-+			    ptype(proc->args.decls->decl.prefix, 
-+				  proc->args.decls->decl.type, 0);
-+			  f_print(fout, " *argp, struct svc_req *%s)\n", 
-+				  RQSTP);
-+			} else {
-+			  f_print(fout, "(argp, %s)\n", RQSTP );
-+			  /* arg name */
-+			  if (proc->arg_num > 1)
-+			    f_print(fout, "\t%s *argp;\n", proc->args.argname);
-+			  else {
-+			    f_print(fout, "\t");
-+			    ptype(proc->args.decls->decl.prefix, 
-+				  proc->args.decls->decl.type, 0);
-+			    f_print(fout, " *argp;\n");
-+			  }
-+			  f_print(fout, "	struct svc_req *%s;\n", RQSTP);
-+			}
-+
-+			f_print(fout, "{\n");
-+			f_print(fout, "\treturn(");
-+			if( Cflag )
-+			  pvname_svc(proc->proc_name, vp->vers_num);
-+			else
-+			  pvname(proc->proc_name, vp->vers_num);
-+			f_print(fout, "(");
-+			if (proc->arg_num < 2) { /* single argument */
-+			  if (!streq( proc->args.decls->decl.type, "void"))
-+			    f_print(fout, "*argp, ");  /* non-void */
-+			} else {
-+			  for (l = proc->args.decls;  l != NULL; l = l->next) 
-+			    f_print(fout, "argp->%s, ", l->decl.name);
-+			}
-+			f_print(fout, "%s));\n}\n", RQSTP);
-+		} 		
-+	}
-+}
-+
-+static void
-+write_program(definition *def, char *storage)
-+{
-+	version_list *vp;
-+	proc_list *proc;
-+	int filled;
-+
-+	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+		f_print(fout, "\n");
-+		if (storage != NULL) {
-+			f_print(fout, "%s ", storage);
-+		}
-+		f_print(fout, "void\n");
-+		pvname(def->def_name, vp->vers_num);
-+
-+		if (Cflag) {
-+		   f_print(fout, "(struct svc_req *%s, ", RQSTP);
-+		   f_print(fout, "register SVCXPRT *%s)\n", TRANSP);
-+		} else {
-+		   f_print(fout, "(%s, %s)\n", RQSTP, TRANSP);
-+		   f_print(fout, "	struct svc_req *%s;\n", RQSTP);
-+		   f_print(fout, "	register SVCXPRT *%s;\n", TRANSP);
-+		}
-+
-+		f_print(fout, "{\n");
-+
-+		filled = 0;
-+		f_print(fout, "\tunion {\n");
-+		for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+			if (proc->arg_num < 2) { /* single argument */
-+				if (streq(proc->args.decls->decl.type, 
-+					  "void")) {
-+					continue;
-+				}
-+				filled = 1;
-+				f_print(fout, "\t\t");
-+				ptype(proc->args.decls->decl.prefix, 
-+				      proc->args.decls->decl.type, 0);
-+				pvname(proc->proc_name, vp->vers_num);
-+				f_print(fout, "_arg;\n");
-+
-+			}
-+			else {
-+				filled = 1;
-+				f_print(fout, "\t\t%s", proc->args.argname);
-+				f_print(fout, " ");
-+				pvname(proc->proc_name, vp->vers_num);
-+				f_print(fout, "_arg;\n");
-+			}
-+		}
-+		if (!filled) {
-+			f_print(fout, "\t\tint fill;\n");
-+		}
-+		f_print(fout, "\t} %s;\n", ARG);
-+		f_print(fout, "\tchar *%s;\n", RESULT);
-+
-+		if (Cflag) {
-+		    f_print(fout, "\txdrproc_t xdr_%s, xdr_%s;\n", ARG, RESULT);
-+		    f_print(fout,
-+			    "\tchar *(*%s)(char *, struct svc_req *);\n",
-+			    ROUTINE);
-+		} else {
-+		    f_print(fout, "\tbool_t (*xdr_%s)(), (*xdr_%s)();\n", ARG, RESULT);
-+		    f_print(fout, "\tchar *(*%s)();\n", ROUTINE);
-+		}
-+
-+		f_print(fout, "\n");
-+
-+		if (timerflag)
-+			f_print(fout, "\t_rpcsvcdirty = 1;\n");
-+		f_print(fout, "\tswitch (%s->rq_proc) {\n", RQSTP);
-+		if (!nullproc(vp->procs)) {
-+			f_print(fout, "\tcase NULLPROC:\n");
-+			f_print(fout,
-+			"\t\t(void) svc_sendreply(%s, (xdrproc_t) xdr_void, (char *)NULL);\n",
-+					TRANSP);
-+			print_return("\t\t");
-+			f_print(fout, "\n");
-+		}
-+		for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+			f_print(fout, "\tcase %s:\n", proc->proc_name);
-+			if (proc->arg_num < 2) { /* single argument */
-+			  p_xdrfunc( ARG, proc->args.decls->decl.type);
-+			} else {
-+			  p_xdrfunc( ARG, proc->args.argname);
-+			}
-+			p_xdrfunc( RESULT, proc->res_type);
-+			if( Cflag )
-+			    f_print(fout,
-+				    "\t\t%s = (char *(*)(char *, struct svc_req *)) ",
-+				    ROUTINE);
-+			else
-+			    f_print(fout, "\t\t%s = (char *(*)()) ", ROUTINE);
-+
-+			if (newstyle) { /* new style: calls internal routine */
-+				f_print(fout,"_");
-+			}
-+			/* Not sure about the following...
-+			 * rpc_hout always generates foobar_1_svc for
-+			 * the service procedure, so why should we use
-+			 * foobar_1 here?! --okir */
-+#if 0
-+			if( Cflag && !newstyle )
-+			  pvname_svc(proc->proc_name, vp->vers_num);
-+			else
-+			  pvname(proc->proc_name, vp->vers_num);
-+#else
-+			pvname_svc(proc->proc_name, vp->vers_num);
-+#endif
-+			f_print(fout, ";\n");
-+			f_print(fout, "\t\tbreak;\n\n");
-+		}
-+		f_print(fout, "\tdefault:\n");
-+		printerr("noproc", TRANSP);
-+		print_return("\t\t");
-+		f_print(fout, "\t}\n");
-+
-+		f_print(fout, "\t(void) memset((char *)&%s, 0, sizeof (%s));\n", ARG, ARG);
-+		if (Cflag)
-+		    printif("getargs", TRANSP, "(caddr_t) &", ARG);
-+		else
-+		    printif("getargs", TRANSP, "&", ARG);
-+		printerr("decode", TRANSP);
-+		print_return("\t\t");
-+		f_print(fout, "\t}\n");
-+
-+		if (Cflag)
-+		    f_print(fout, "\t%s = (*%s)((char *)&%s, %s);\n",
-+			    RESULT, ROUTINE, ARG, RQSTP);
-+		else
-+		    f_print(fout, "\t%s = (*%s)(&%s, %s);\n",
-+			    RESULT, ROUTINE, ARG, RQSTP);
-+		f_print(fout, 
-+			"\tif (%s != NULL && !svc_sendreply(%s, "
-+			"(xdrproc_t) xdr_%s, %s)) {\n",
-+			RESULT, TRANSP, RESULT, RESULT);
-+		printerr("systemerr", TRANSP);
-+		f_print(fout, "\t}\n");
-+
-+		if (Cflag)
-+		    printif("freeargs", TRANSP, "(caddr_t) &", ARG);
-+		else
-+		    printif("freeargs", TRANSP, "&", ARG);
-+		(void) sprintf(_errbuf, "unable to free arguments");
-+		print_err_message("\t\t");
-+		f_print(fout, "\t\texit(1);\n");
-+		f_print(fout, "\t}\n");
-+		print_return("\t");
-+		f_print(fout, "}\n");
-+	}
-+}
-+
-+static void
-+printerr(char *err, char *transp)
-+{
-+	f_print(fout, "\t\tsvcerr_%s(%s);\n", err, transp);
-+}
-+
-+static void
-+printif(char *proc, char *transp, char *prefix, char *arg)
-+{
-+	f_print(fout, "\tif (!svc_%s(%s, (xdrproc_t) xdr_%s, (caddr_t) %s%s)) {\n",
-+		proc, transp, arg, prefix, arg);
-+}
-+
-+int
-+nullproc(proc_list *proc)
-+{
-+	for (; proc != NULL; proc = proc->next) {
-+		if (streq(proc->proc_num, "0")) {
-+			return (1);
-+		}
-+	}
-+	return (0);
-+}
-+
-+static void
-+write_inetmost(char *infile)
-+{
-+	f_print(fout, "\tregister SVCXPRT *%s;\n", TRANSP);
-+	f_print(fout, "\tint sock;\n");
-+	f_print(fout, "\tint proto;\n");
-+	f_print(fout, "\tstruct sockaddr_in saddr;\n");
-+	f_print(fout, "\tint asize = sizeof (saddr);\n");
-+	f_print(fout, "\n");
-+	f_print(fout, 
-+	"\tif (getsockname(0, (struct sockaddr *)&saddr, &asize) == 0) {\n");
-+	f_print(fout, "\t\tint ssize = sizeof (int);\n\n");
-+	f_print(fout, "\t\tif (saddr.sin_family != AF_INET)\n");
-+	f_print(fout, "\t\t\texit(1);\n");
-+	f_print(fout, "\t\tif (getsockopt(0, SOL_SOCKET, SO_TYPE,\n");
-+	f_print(fout, "\t\t\t\t(char *)&_rpcfdtype, &ssize) == -1)\n");
-+	f_print(fout, "\t\t\texit(1);\n");
-+	f_print(fout, "\t\tsock = 0;\n");
-+	f_print(fout, "\t\t_rpcpmstart = 1;\n");
-+	f_print(fout, "\t\tproto = 0;\n");
-+	open_log_file(infile, "\t\t");
-+	f_print(fout, "\t} else {\n");
-+	write_rpc_svc_fg(infile, "\t\t");
-+	f_print(fout, "\t\tsock = RPC_ANYSOCK;\n");
-+	print_pmapunset("\t\t");
-+	f_print(fout, "\t}\n");
-+}
-+
-+static void
-+print_return(char *space)
-+{
-+	if (exitnow)
-+		f_print(fout, "%sexit(0);\n", space);
-+	else {
-+		if (timerflag)
-+			f_print(fout, "%s_rpcsvcdirty = 0;\n", space);
-+		f_print(fout, "%sreturn;\n", space);
-+	}
-+}
-+
-+static void
-+print_pmapunset(char *space)
-+{
-+	list *l;
-+	definition *def;
-+	version_list *vp;
-+
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind == DEF_PROGRAM) {
-+			for (vp = def->def.pr.versions; vp != NULL;
-+					vp = vp->next) {
-+				f_print(fout, "%s(void) pmap_unset(%s, %s);\n",
-+					space, def->def_name, vp->vers_name);
-+			}
-+		}
-+	}
-+}
-+
-+static void
-+print_err_message(char *space)
-+{
-+	if (logflag)
-+		f_print(fout, "%ssyslog(LOG_ERR, \"%s\");\n", space, _errbuf);
-+	else if (inetdflag || pmflag)
-+		f_print(fout, "%s_msgout(\"%s\");\n", space, _errbuf);
-+	else
-+		f_print(fout, "%sfprintf(stderr, \"%s\");\n", space, _errbuf);
-+}
-+
-+/*
-+ * Write the server auxiliary function ( _msgout, timeout)
-+ */
-+void
-+write_svc_aux(int nomain)
-+{
-+	if (!logflag)
-+		write_msg_out();
-+	if( !nomain )
-+	  write_timeout_func();
-+}
-+
-+/*
-+ * Write the _msgout function
-+ */
-+void
-+write_msg_out(void)
-+{
-+	f_print(fout, "\n");
-+	f_print(fout, "static\n");
-+	if( !Cflag ) {
-+	  f_print(fout, "void _msgout(msg)\n");
-+	  f_print(fout, "\tchar *msg;\n");
-+	} else {
-+	  f_print(fout, "void _msgout(char* msg)\n");
-+	}
-+	f_print(fout, "{\n");
-+	f_print(fout, "#ifdef RPC_SVC_FG\n");
-+	if (inetdflag || pmflag)
-+		f_print(fout, "\tif (_rpcpmstart)\n");
-+	f_print(fout, "\t\tsyslog(LOG_ERR, \"%%s\", msg);\n");
-+	f_print(fout, "\telse\n");
-+	f_print(fout, "\t\t(void) fprintf(stderr, \"%%s\\n\", msg);\n");
-+	f_print(fout, "#else\n");
-+	f_print(fout, "\tsyslog(LOG_ERR, \"%%s\", msg);\n");
-+	f_print(fout, "#endif\n");
-+	f_print(fout, "}\n");
-+}
-+
-+/*
-+ * Write the timeout function
-+ */
-+static void
-+write_timeout_func(void)
-+{
-+	if (!timerflag)
-+		return;
-+	f_print(fout, "\n");
-+	f_print(fout, "static void\n");
-+	f_print(fout, "closedown()\n");
-+	f_print(fout, "{\n");
-+	f_print(fout, "\tif (_rpcsvcdirty == 0) {\n");
-+	f_print(fout, "\t\tstatic int size;\n");
-+	f_print(fout, "\t\tint i, openfd;\n");
-+	if (tirpcflag && pmflag) {
-+		f_print(fout, "\t\tstruct t_info tinfo;\n\n");
-+		f_print(fout, "\t\tif (!t_getinfo(0, &tinfo) && (tinfo.servtype == T_CLTS))\n");
-+	} else {
-+		f_print(fout, "\n\t\tif (_rpcfdtype == SOCK_DGRAM)\n");
-+	}
-+	f_print(fout, "\t\t\texit(0);\n");
-+	f_print(fout, "\t\tif (size == 0) {\n");
-+	if( tirpcflag ) {
-+	  f_print(fout, "\t\t\tstruct rlimit rl;\n\n");
-+	  f_print(fout, "\t\t\trl.rlim_max = 0;\n");
-+	  f_print(fout, "\t\t\tgetrlimit(RLIMIT_NOFILE, &rl);\n");
-+	  f_print(fout, "\t\t\tif ((size = rl.rlim_max) == 0)\n");
-+	  f_print(fout, "\t\t\t\treturn;\n");
-+	} else {
-+	  f_print(fout, "\t\t\tsize = getdtablesize();\n");
-+	}
-+	f_print(fout, "\t\t}\n");
-+	f_print(fout, "\t\tfor (i = 0, openfd = 0; i < size && openfd < 2; i++)\n");
-+	f_print(fout, "\t\t\tif (FD_ISSET(i, &svc_fdset))\n");
-+	f_print(fout, "\t\t\t\topenfd++;\n");
-+	f_print(fout, "\t\tif (openfd <= 1)\n");
-+	f_print(fout, "\t\t\texit(0);\n");
-+	f_print(fout, "\t}\n");
-+	f_print(fout, "\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
-+	f_print(fout, "}\n");
-+}
-+
-+/*
-+ * Write the most of port monitor support
-+ */
-+static void
-+write_pm_most(char *infile, int netflag)
-+{
-+	list *l;
-+	definition *def;
-+	version_list *vp;
-+
-+	f_print(fout, "\tif (!ioctl(0, I_LOOK, mname) &&\n");
-+	f_print(fout, "\t\t(!strcmp(mname, \"sockmod\") ||");
-+	f_print(fout, " !strcmp(mname, \"timod\"))) {\n");
-+	f_print(fout, "\t\tchar *netid;\n");
-+	if (!netflag) {	/* Not included by -n option */
-+		f_print(fout, "\t\tstruct netconfig *nconf = NULL;\n");
-+		f_print(fout, "\t\tSVCXPRT *%s;\n", TRANSP);
-+	}
-+	if( timerflag )
-+	  f_print(fout, "\t\tint pmclose;\n");
-+/* not necessary, defined in /usr/include/stdlib */
-+/*	f_print(fout, "\t\textern char *getenv();\n");*/
-+	f_print(fout, "\n");
-+	f_print(fout, "\t\t_rpcpmstart = 1;\n");
-+	if (logflag)
-+		open_log_file(infile, "\t\t");
-+	f_print(fout, "\t\tif ((netid = getenv(\"NLSPROVIDER\")) == NULL) {\n");
-+	sprintf(_errbuf, "cannot get transport name");
-+	print_err_message("\t\t\t");
-+	f_print(fout, "\t\t} else if ((nconf = getnetconfigent(netid)) == NULL) {\n");
-+	sprintf(_errbuf, "cannot get transport info");
-+	print_err_message("\t\t\t");
-+	f_print(fout, "\t\t}\n");
-+	/*
-+	 * A kludgy support for inetd services. Inetd only works with
-+	 * sockmod, and RPC works only with timod, hence all this jugglery
-+	 */
-+	f_print(fout, "\t\tif (strcmp(mname, \"sockmod\") == 0) {\n");
-+	f_print(fout, "\t\t\tif (ioctl(0, I_POP, 0) || ioctl(0, I_PUSH, \"timod\")) {\n");
-+	sprintf(_errbuf, "could not get the right module");
-+	print_err_message("\t\t\t\t");
-+	f_print(fout, "\t\t\t\texit(1);\n");
-+	f_print(fout, "\t\t\t}\n");
-+	f_print(fout, "\t\t}\n");
-+	if( timerflag )
-+	  f_print(fout, "\t\tpmclose = (t_getstate(0) != T_DATAXFER);\n");
-+	f_print(fout, "\t\tif ((%s = svc_tli_create(0, nconf, NULL, 0, 0)) == NULL) {\n",
-+			TRANSP);
-+	sprintf(_errbuf, "cannot create server handle");
-+	print_err_message("\t\t\t");
-+	f_print(fout, "\t\t\texit(1);\n");
-+	f_print(fout, "\t\t}\n");
-+	f_print(fout, "\t\tif (nconf)\n");
-+	f_print(fout, "\t\t\tfreenetconfigent(nconf);\n");
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind != DEF_PROGRAM) {
-+			continue;
-+		}
-+		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+			f_print(fout,
-+				"\t\tif (!svc_reg(%s, %s, %s, ",
-+				TRANSP, def->def_name, vp->vers_name);
-+			pvname(def->def_name, vp->vers_num);
-+			f_print(fout, ", 0)) {\n");
-+			(void) sprintf(_errbuf, "unable to register (%s, %s).",
-+					def->def_name, vp->vers_name);
-+			print_err_message("\t\t\t");
-+			f_print(fout, "\t\t\texit(1);\n");
-+			f_print(fout, "\t\t}\n");
-+		}
-+	}
-+	if (timerflag) {
-+		f_print(fout, "\t\tif (pmclose) {\n");
-+		f_print(fout, "\t\t\t(void) signal(SIGALRM, %s closedown);\n",
-+				Cflag? "(SIG_PF)" : "(void(*)())" );
-+		f_print(fout, "\t\t\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
-+		f_print(fout, "\t\t}\n");
-+	}
-+	f_print(fout, "\t\tsvc_run();\n");
-+	f_print(fout, "\t\texit(1);\n");
-+	f_print(fout, "\t\t/* NOTREACHED */\n");
-+	f_print(fout, "\t}\n");
-+}
-+
-+/*
-+ * Support for backgrounding the server if self started.
-+ */
-+static void
-+write_rpc_svc_fg(char *infile, char *sp)
-+{
-+	f_print(fout, "#ifndef RPC_SVC_FG\n");
-+	f_print(fout, "%sint size;\n", sp);
-+	if( tirpcflag )
-+	        f_print(fout, "%sstruct rlimit rl;\n", sp);
-+	if (inetdflag)
-+		f_print(fout, "%sint pid, i;\n\n", sp);
-+	f_print(fout, "%spid = fork();\n", sp);
-+	f_print(fout, "%sif (pid < 0) {\n", sp);
-+	f_print(fout, "%s\tperror(\"cannot fork\");\n", sp);
-+	f_print(fout, "%s\texit(1);\n", sp);
-+	f_print(fout, "%s}\n", sp);
-+	f_print(fout, "%sif (pid)\n", sp);
-+	f_print(fout, "%s\texit(0);\n", sp);
-+	/* get number of file descriptors */
-+	if( tirpcflag ) {
-+	  f_print(fout, "%srl.rlim_max = 0;\n", sp);
-+	  f_print(fout, "%sgetrlimit(RLIMIT_NOFILE, &rl);\n", sp);
-+	  f_print(fout, "%sif ((size = rl.rlim_max) == 0)\n", sp);
-+	  f_print(fout, "%s\texit(1);\n", sp);
-+	} else {
-+	  f_print(fout, "%ssize = getdtablesize();\n", sp);
-+	}
-+
-+	f_print(fout, "%sfor (i = 0; i < size; i++)\n", sp);
-+	f_print(fout, "%s\t(void) close(i);\n", sp);
-+	/* Redirect stderr and stdout to console */
-+	f_print(fout, "%si = open(\"/dev/console\", 2);\n", sp);
-+	f_print(fout, "%s(void) dup2(i, 1);\n", sp);
-+	f_print(fout, "%s(void) dup2(i, 2);\n", sp);
-+	/* This removes control of the controlling terminal */
-+	if( tirpcflag )
-+	  f_print(fout, "%ssetsid();\n", sp);
-+	else {
-+	  f_print(fout, "%si = open(\"/dev/tty\", 2);\n", sp);
-+	  f_print(fout, "%sif (i >= 0) {\n", sp);
-+	  f_print(fout, "%s\t(void) ioctl(i, TIOCNOTTY, (char *)NULL);\n", sp);;
-+	  f_print(fout, "%s\t(void) close(i);\n", sp);
-+	  f_print(fout, "%s}\n", sp);
-+	}
-+	if (!logflag)
-+		open_log_file(infile, sp);
-+	f_print(fout, "#endif\n");
-+	if (logflag)
-+		open_log_file(infile, sp);
-+}
-+
-+static void
-+open_log_file(char *infile, char *sp)
-+{
-+	char *s;
-+
-+	s = strrchr(infile, '.');
-+	if (s) 
-+		*s = '\0';
-+	f_print(fout,"%sopenlog(\"%s\", LOG_PID, LOG_DAEMON);\n", sp, infile);
-+	if (s)
-+		*s = '.';
-+}
-+
-+
-+
-+
-+/*
-+ * write a registration for the given transport for Inetd
-+ */
-+void
-+write_inetd_register(char *transp)
-+{
-+	list *l;
-+	definition *def;
-+	version_list *vp;
-+	char *sp;
-+	int isudp;
-+	char tmpbuf[32];
-+
-+	if (inetdflag)
-+		sp = "\t";
-+	else
-+		sp = "";
-+	if (streq(transp, "udp"))
-+		isudp = 1;
-+	else
-+		isudp = 0;
-+	f_print(fout, "\n");
-+	if (inetdflag) {
-+		f_print(fout, "\tif ((_rpcfdtype == 0) || (_rpcfdtype == %s)) {\n",
-+				isudp ? "SOCK_DGRAM" : "SOCK_STREAM");
-+	}
-+	f_print(fout, "%s\t%s = svc%s_create(%s",
-+		sp, TRANSP, transp, inetdflag? "sock": "RPC_ANYSOCK");
-+	if (!isudp)
-+		f_print(fout, ", 0, 0");
-+	f_print(fout, ");\n");
-+	f_print(fout, "%s\tif (%s == NULL) {\n", sp, TRANSP);
-+	(void) sprintf(_errbuf, "cannot create %s service.", transp);
-+	(void) sprintf(tmpbuf, "%s\t\t", sp);
-+	print_err_message(tmpbuf);
-+	f_print(fout, "%s\t\texit(1);\n", sp);
-+	f_print(fout, "%s\t}\n", sp);
-+
-+	if (inetdflag) {
-+		f_print(fout, "%s\tif (!_rpcpmstart)\n\t", sp);
-+		f_print(fout, "%s\tproto = IPPROTO_%s;\n",
-+				sp, isudp ? "UDP": "TCP");
-+	}
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind != DEF_PROGRAM) {
-+			continue;
-+		}
-+		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+			f_print(fout, "%s\tif (!svc_register(%s, %s, %s, ",
-+				sp, TRANSP, def->def_name, vp->vers_name);
-+			pvname(def->def_name, vp->vers_num);
-+			if (inetdflag)
-+				f_print(fout, ", proto)) {\n");
-+			else 
-+				f_print(fout, ", IPPROTO_%s)) {\n",
-+					isudp ? "UDP": "TCP");
-+			(void) sprintf(_errbuf, "unable to register (%s, %s, %s).",
-+					def->def_name, vp->vers_name, transp);
-+			print_err_message(tmpbuf);
-+			f_print(fout, "%s\t\texit(1);\n", sp);
-+			f_print(fout, "%s\t}\n", sp);
-+		}
-+	}
-+	if (inetdflag)
-+		f_print(fout, "\t}\n");
-+}
-diff --git a/rpcgen/rpc_tblout.c b/rpcgen/rpc_tblout.c
-new file mode 100644
-index 0000000..ae002f7
---- /dev/null
-+++ b/rpcgen/rpc_tblout.c
-@@ -0,0 +1,165 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_tblout.c 1.4 89/02/22 (C) 1988 SMI";
-+#endif
-+
-+/*
-+ * rpc_tblout.c, Dispatch table outputter for the RPC protocol compiler
-+ */
-+#include <stdio.h>
-+#include <string.h>
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+#include "rpc_output.h"
-+
-+static void	write_table(definition *def);
-+static void	printit(char *prefix, char *type);
-+
-+#define TABSIZE		8
-+#define TABCOUNT	5
-+#define TABSTOP		(TABSIZE*TABCOUNT)
-+
-+static char tabstr[TABCOUNT+1] = "\t\t\t\t\t";
-+
-+static char tbl_hdr[] = "struct rpcgen_table %s_table[] = {\n";
-+static char tbl_end[] = "};\n";
-+
-+static char null_entry[] = "\n\t(char *(*)())0,\n\
-+ \t(xdrproc_t) xdr_void,\t\t\t0,\n\
-+ \t(xdrproc_t) xdr_void,\t\t\t0,\n";
-+
-+
-+static char tbl_nproc[] = "int %s_nproc =\n\tsizeof(%s_table)/sizeof(%s_table[0]);\n\n";
-+
-+void
-+write_tables(void)
-+{
-+	list *l;
-+	definition *def;
-+
-+	f_print(fout, "\n");
-+	for (l = defined; l != NULL; l = l->next) {
-+		def = (definition *) l->val;
-+		if (def->def_kind == DEF_PROGRAM) {
-+			write_table(def);
-+		}
-+	}
-+}
-+
-+static void
-+write_table(definition *def)
-+{
-+	version_list *vp;
-+	proc_list *proc;
-+	int current;
-+	int expected;
-+	char progvers[100];
-+	int warning;
-+
-+	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
-+		warning = 0;
-+		s_print(progvers, "%s_%s",
-+		    locase(def->def_name), vp->vers_num);
-+		/* print the table header */
-+		f_print(fout, tbl_hdr, progvers);
-+
-+		if (nullproc(vp->procs)) {
-+			expected = 0;
-+		} else {
-+			expected = 1;
-+			f_print(fout, null_entry);
-+		}
-+		for (proc = vp->procs; proc != NULL; proc = proc->next) {
-+			current = atoi(proc->proc_num);
-+			if (current != expected++) {
-+				f_print(fout,
-+			"\n/*\n * WARNING: table out of order\n */\n");
-+				if (warning == 0) {
-+					f_print(stderr,
-+				    "WARNING %s table is out of order\n",
-+					    progvers);
-+					warning = 1;
-+					nonfatalerrors = 1;
-+				}
-+				expected = current + 1;
-+			}
-+			f_print(fout, "\n\t(char *(*)())RPCGEN_ACTION(");
-+
-+			/* routine to invoke */
-+			if( Cflag && !newstyle )
-+			  pvname_svc(proc->proc_name, vp->vers_num);
-+			else {
-+			  if( newstyle )
-+			    f_print( fout, "_");   /* calls internal func */
-+			  pvname(proc->proc_name, vp->vers_num);
-+			}
-+			f_print(fout, "),\n");
-+
-+			/* argument info */
-+			if( proc->arg_num > 1 )
-+			  printit((char*) NULL, proc->args.argname );
-+			else  
-+			  /* do we have to do something special for newstyle */
-+			  printit( proc->args.decls->decl.prefix,
-+				  proc->args.decls->decl.type );
-+			/* result info */
-+			printit(proc->res_prefix, proc->res_type);
-+		}
-+
-+		/* print the table trailer */
-+		f_print(fout, tbl_end);
-+		f_print(fout, tbl_nproc, progvers, progvers, progvers);
-+	}
-+}
-+
-+static void
-+printit(char *prefix, char *type)
-+{
-+	int len;
-+	int tabs;
-+
-+
-+ 	len = fprintf(fout, "\txdr_%s,", stringfix(type));
-+	/* account for leading tab expansion */
-+	len += TABSIZE - 1;
-+	/* round up to tabs required */
-+	tabs = (TABSTOP - len + TABSIZE - 1)/TABSIZE;
-+	f_print(fout, "%s", &tabstr[TABCOUNT-tabs]);
-+
-+	if (streq(type, "void")) {
-+		f_print(fout, "0");
-+	} else {
-+		f_print(fout, "sizeof ( ");
-+		/* XXX: should "follow" be 1 ??? */
-+		ptype(prefix, type, 0);
-+		f_print(fout, ")");
-+	}
-+	f_print(fout, ",\n");
-+}
-diff --git a/rpcgen/rpc_util.c b/rpcgen/rpc_util.c
-new file mode 100644
-index 0000000..b67be57
---- /dev/null
-+++ b/rpcgen/rpc_util.c
-@@ -0,0 +1,479 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+#if 0
-+static char sccsid[] = "@(#)rpc_util.c 1.11 89/02/22 (C) 1987 SMI";
-+#endif
-+
-+/*
-+ * rpc_util.c, Utility routines for the RPC protocol compiler 
-+ */
-+#include <stdio.h>
-+#include <memory.h>
-+#include <ctype.h>
-+#include <unistd.h>
-+#include "rpc_scan.h"
-+#include "rpc_parse.h"
-+#include "rpc_util.h"
-+
-+static void	printwhere(void);
-+
-+
-+#define ARGEXT "argument"
-+
-+char curline[MAXLINESIZE];	/* current read line */
-+char *where = curline;		/* current point in line */
-+int linenum = 0;		/* current line number */
-+
-+char *infilename;		/* input filename */
-+
-+#define NFILES 7
-+char *outfiles[NFILES];		/* output file names */
-+int nfiles;
-+
-+FILE *fout;			/* file pointer of current output */
-+FILE *fin;			/* file pointer of current input */
-+
-+list *defined;			/* list of defined things */
-+
-+/*
-+ * Reinitialize the world 
-+ */
-+void
-+reinitialize(void)
-+{
-+	memset(curline, 0, MAXLINESIZE);
-+	where = curline;
-+	linenum = 0;
-+	defined = NULL;
-+}
-+
-+/*
-+ * string equality 
-+ */
-+int
-+streq(char *a, char *b)
-+{
-+	return (strcmp(a, b) == 0);
-+}
-+
-+/*
-+ * find a value in a list 
-+ */
-+definition *
-+findval(list *lst, char *val, int (*cmp)(definition *, char *))
-+{
-+         
-+	for (; lst != NULL; lst = lst->next) {
-+		if ((*cmp) (lst->val, val)) {
-+			return (lst->val);
-+		}
-+	}
-+	return (NULL);
-+}
-+
-+/*
-+ * store a value in a list 
-+ */
-+void
-+storeval(lstp, val)
-+	list **lstp;
-+	definition *val;
-+{
-+	list **l;
-+	list *lst;
-+
-+	
-+	for (l = lstp; *l != NULL; l = (list **) & (*l)->next);
-+	lst = ALLOC(list);
-+	lst->val = val;
-+	lst->next = NULL;
-+	*l = lst;
-+}
-+
-+static int
-+findit(definition *def, char *type)
-+{
-+	return (streq(def->def_name, type));
-+}
-+
-+static char *
-+fixit(char *type, char *orig)
-+{
-+	definition *def;
-+
-+	def = (definition *) FINDVAL(defined, type, findit);
-+	if (def == NULL || def->def_kind != DEF_TYPEDEF) {
-+		return (orig);
-+	}
-+	switch (def->def.ty.rel) {
-+	case REL_VECTOR:
-+		return (def->def.ty.old_type);
-+	case REL_ALIAS:
-+		return (fixit(def->def.ty.old_type, orig));
-+	default:
-+		return (orig);
-+	}
-+}
-+
-+char *
-+fixtype(char *type)
-+{
-+	return (fixit(type, type));
-+}
-+
-+char *
-+stringfix(char *type)
-+{
-+	if (streq(type, "string")) {
-+		return ("wrapstring");
-+	} else {
-+		return (type);
-+	}
-+}
-+
-+void
-+ptype(char *prefix, char *type, int follow)
-+{
-+	if (prefix != NULL) {
-+		if (streq(prefix, "enum")) {
-+			f_print(fout, "enum ");
-+		} else {
-+			f_print(fout, "struct ");
-+		}
-+	}
-+	if (streq(type, "bool")) {
-+		f_print(fout, "bool_t ");
-+	} else if (streq(type, "string")) {
-+		f_print(fout, "char *");
-+	} else {
-+		f_print(fout, "%s ", follow ? fixtype(type) : type);
-+	}
-+}
-+
-+static int
-+typedefed(definition *def, char *type)
-+{
-+	if (def->def_kind != DEF_TYPEDEF || def->def.ty.old_prefix != NULL) {
-+		return (0);
-+	} else {
-+		return (streq(def->def_name, type));
-+	}
-+}
-+
-+int
-+isvectordef(char *type, relation rel)
-+{
-+	definition *def;
-+
-+	for (;;) {
-+		switch (rel) {
-+		case REL_VECTOR:
-+			return (!streq(type, "string"));
-+		case REL_ARRAY:
-+			return (0);
-+		case REL_POINTER:
-+			return (0);
-+		case REL_ALIAS:
-+			def = (definition *) FINDVAL(defined, type, typedefed);
-+			if (def == NULL) {
-+				return (0);
-+			}
-+			type = def->def.ty.old_type;
-+			rel = def->def.ty.rel;
-+		}
-+	}
-+}
-+
-+char *
-+locase(char *str)
-+{
-+	char c;
-+	static char buf[100];
-+	char *p = buf;
-+
-+	while ((c = *str++) != '\0') {
-+		*p++ = (c >= 'A' && c <= 'Z') ? (c - 'A' + 'a') : c;
-+	}
-+	*p = 0;
-+	return (buf);
-+}
-+
-+void
-+pvname_svc(char *pname, char *vnum)
-+{
-+	f_print(fout, "%s_%s_svc", locase(pname), vnum);
-+}
-+
-+void
-+pvname(char *pname, char *vnum)
-+{
-+	f_print(fout, "%s_%s", locase(pname), vnum);
-+}
-+
-+/*
-+ * print a useful (?) error message, and then die 
-+ */
-+void
-+error(char *msg)
-+{
-+	printwhere();
-+	f_print(stderr, "%s, line %d: ", infilename, linenum);
-+	f_print(stderr, "%s\n", msg);
-+	crash();
-+}
-+
-+/*
-+ * Something went wrong, unlink any files that we may have created and then
-+ * die. 
-+ */
-+void
-+crash(void)
-+{
-+	int i;
-+
-+	for (i = 0; i < nfiles; i++) {
-+		(void) unlink(outfiles[i]);
-+	}
-+	exit(1);
-+}
-+
-+void
-+record_open(char *file)
-+{
-+	if (nfiles < NFILES) {
-+		outfiles[nfiles++] = file;
-+	} else {
-+		f_print(stderr, "too many files!\n");
-+		crash();
-+	}
-+}
-+
-+static char expectbuf[100];
-+static char *toktostr();
-+
-+/*
-+ * error, token encountered was not the expected one 
-+ */
-+void
-+expected1(exp1)
-+	tok_kind exp1;
-+{
-+	s_print(expectbuf, "expected '%s'",
-+		toktostr(exp1));
-+	error(expectbuf);
-+}
-+
-+/*
-+ * error, token encountered was not one of two expected ones 
-+ */
-+void
-+expected2(exp1, exp2)
-+	tok_kind exp1, exp2;
-+{
-+	s_print(expectbuf, "expected '%s' or '%s'",
-+		toktostr(exp1),
-+		toktostr(exp2));
-+	error(expectbuf);
-+}
-+
-+/*
-+ * error, token encountered was not one of 3 expected ones 
-+ */
-+void
-+expected3(exp1, exp2, exp3)
-+	tok_kind exp1, exp2, exp3;
-+{
-+	s_print(expectbuf, "expected '%s', '%s' or '%s'",
-+		toktostr(exp1),
-+		toktostr(exp2),
-+		toktostr(exp3));
-+	error(expectbuf);
-+}
-+
-+void
-+tabify(f, tab)
-+	FILE *f;
-+	int tab;
-+{
-+	while (tab--) {
-+		(void) fputc('\t', f);
-+	}
-+}
-+
-+
-+static token tokstrings[] = {
-+			     {TOK_IDENT, "identifier"},
-+			     {TOK_CONST, "const"},
-+			     {TOK_RPAREN, ")"},
-+			     {TOK_LPAREN, "("},
-+			     {TOK_RBRACE, "}"},
-+			     {TOK_LBRACE, "{"},
-+			     {TOK_LBRACKET, "["},
-+			     {TOK_RBRACKET, "]"},
-+			     {TOK_STAR, "*"},
-+			     {TOK_COMMA, ","},
-+			     {TOK_EQUAL, "="},
-+			     {TOK_COLON, ":"},
-+			     {TOK_SEMICOLON, ";"},
-+			     {TOK_UNION, "union"},
-+			     {TOK_STRUCT, "struct"},
-+			     {TOK_SWITCH, "switch"},
-+			     {TOK_CASE, "case"},
-+			     {TOK_DEFAULT, "default"},
-+			     {TOK_ENUM, "enum"},
-+			     {TOK_TYPEDEF, "typedef"},
-+			     {TOK_INT, "int"},
-+			     {TOK_SHORT, "short"},
-+			     {TOK_INT32, "int32"},
-+			     {TOK_UNSIGNED, "unsigned"},
-+			     {TOK_DOUBLE, "double"},
-+			     {TOK_FLOAT, "float"},
-+			     {TOK_CHAR, "char"},
-+			     {TOK_STRING, "string"},
-+			     {TOK_OPAQUE, "opaque"},
-+			     {TOK_BOOL, "bool"},
-+			     {TOK_VOID, "void"},
-+			     {TOK_PROGRAM, "program"},
-+			     {TOK_VERSION, "version"},
-+			     {TOK_EOF, "??????"}
-+};
-+
-+static char *
-+toktostr(kind)
-+	tok_kind kind;
-+{
-+	token *sp;
-+
-+	for (sp = tokstrings; sp->kind != TOK_EOF && sp->kind != kind; sp++);
-+	return (sp->str);
-+}
-+
-+static void
-+printbuf(void)
-+{
-+	char c;
-+	int i;
-+	int cnt;
-+
-+#	define TABSIZE 4
-+
-+	for (i = 0; (c = curline[i]) != '\0'; i++) {
-+		if (c == '\t') {
-+			cnt = 8 - (i % TABSIZE);
-+			c = ' ';
-+		} else {
-+			cnt = 1;
-+		}
-+		while (cnt--) {
-+			(void) fputc(c, stderr);
-+		}
-+	}
-+}
-+
-+static void
-+printwhere(void)
-+{
-+	int i;
-+	char c;
-+	int cnt;
-+
-+	printbuf();
-+	for (i = 0; i < where - curline; i++) {
-+		c = curline[i];
-+		if (c == '\t') {
-+			cnt = 8 - (i % TABSIZE);
-+		} else {
-+			cnt = 1;
-+		}
-+		while (cnt--) {
-+			(void) fputc('^', stderr);
-+		}
-+	}
-+	(void) fputc('\n', stderr);
-+}
-+
-+char * 
-+make_argname(char *pname, char *vname) 
-+{
-+	char *name;
-+	
-+	name = malloc(strlen(pname) + strlen(vname) + strlen(ARGEXT) + 3);
-+	if (!name) {
-+		fprintf(stderr, "failed in malloc");
-+		exit(1);
-+	}
-+	sprintf(name, "%s_%s_%s", locase(pname), vname, ARGEXT);
-+	return(name);
-+}
-+
-+bas_type *typ_list_h;
-+bas_type *typ_list_t;
-+
-+void
-+add_type(int len, char *type)
-+{
-+	bas_type       *ptr;
-+
-+
-+	if ((ptr = (bas_type *) malloc(sizeof(bas_type))) == (bas_type *) NULL) {
-+		fprintf(stderr, "failed in malloc");
-+		exit(1);
-+	}
-+	ptr->name = type;
-+	ptr->length = len;
-+	ptr->next = NULL;
-+	if (typ_list_t == NULL) {
-+
-+		typ_list_t = ptr;
-+		typ_list_h = ptr;
-+	} else {
-+
-+		typ_list_t->next = ptr;
-+		typ_list_t = ptr;
-+	}
-+}
-+
-+
-+bas_type *
-+find_type(char *type)
-+{
-+	bas_type       *ptr;
-+
-+	ptr = typ_list_h;
-+
-+
-+	while (ptr != NULL) {
-+		if (strcmp(ptr->name, type) == 0)
-+			return (ptr);
-+		else
-+			ptr = ptr->next;
-+	};
-+	return (NULL);
-+}
-+
-diff --git a/rpcgen/rpc_util.h b/rpcgen/rpc_util.h
-new file mode 100644
-index 0000000..fa115be
---- /dev/null
-+++ b/rpcgen/rpc_util.h
-@@ -0,0 +1,166 @@
-+/*
-+ * Copyright (c) 2009, Sun Microsystems, Inc.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without
-+ * modification, are permitted provided that the following conditions are met:
-+ * - Redistributions of source code must retain the above copyright notice,
-+ *   this list of conditions and the following disclaimer.
-+ * - Redistributions in binary form must reproduce the above copyright notice,
-+ *   this list of conditions and the following disclaimer in the documentation
-+ *   and/or other materials provided with the distribution.
-+ * - Neither the name of Sun Microsystems, Inc. nor the names of its
-+ *   contributors may be used to endorse or promote products derived
-+ *   from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-+ * POSSIBILITY OF SUCH DAMAGE.
-+ */
-+
-+/*      @(#)rpc_util.h  1.5  90/08/29  (C) 1987 SMI   */
-+
-+/*
-+ * rpc_util.h, Useful definitions for the RPC protocol compiler 
-+ */
-+
-+#include <stdlib.h>
-+
-+#define alloc(size)		malloc((unsigned)(size))
-+#define ALLOC(object)   (object *) malloc(sizeof(object))
-+
-+#define s_print	(void) sprintf
-+#define f_print (void) fprintf
-+
-+struct list {
-+	definition *val;
-+	struct list *next;
-+};
-+typedef struct list list;
-+
-+#define PUT 1
-+#define GET 2
-+
-+/*
-+ * Global variables 
-+ */
-+#define MAXLINESIZE 1024
-+extern char curline[MAXLINESIZE];
-+extern char *where;
-+extern int linenum;
-+
-+extern char *infilename;
-+extern FILE *fout;
-+extern FILE *fin;
-+
-+extern list *defined;
-+
-+
-+extern bas_type *typ_list_h;
-+extern bas_type *typ_list_t;
-+
-+/*
-+ * All the option flags
-+ */
-+extern int inetdflag;
-+extern int pmflag;   
-+extern int tblflag;
-+extern int logflag;
-+extern int newstyle;
-+extern int Cflag;	/* C++ flag */
-+extern int tirpcflag;	/* flag for generating tirpc code */
-+extern int Inline;	/* if this is 0, then do not generate inline code */
-+
-+/*
-+ * Other flags related with inetd jumpstart.
-+ */
-+extern int indefinitewait;
-+extern int exitnow;
-+extern int timerflag;
-+
-+extern int nonfatalerrors;
-+
-+/*
-+ * rpc_util routines 
-+ */
-+void storeval();
-+
-+#define STOREVAL(list,item)	\
-+	storeval(list,item)
-+
-+definition *findval();
-+
-+#define FINDVAL(list,item,finder) \
-+	findval(list, item, finder)
-+
-+
-+/*
-+ * rpc_cout routines
-+ */
-+void            cprint(void);
-+void            emit(definition *);
-+
-+/*
-+ * rpc_hout routines
-+ */
-+void            print_datadef(definition *);
-+void            print_funcdef(definition *);
-+
-+/*
-+ * rpc_svcout routines
-+ */
-+void            write_most(char *, int, int);
-+void            write_register(void);
-+void		write_netid_register(char *);
-+void		write_nettype_register(char *);
-+void		write_inetd_register(char *);
-+void            write_rest(void);
-+void            write_programs(char *);
-+void            write_svc_aux(int);
-+
-+/*
-+ * rpc_clntout routines
-+ */
-+void            write_stubs(void);
-+void		printarglist(proc_list *, char *, char *);
-+
-+/*
-+ * rpc_tblout routines
-+ */
-+void            write_tables(void);
-+
-+/*
-+ * rpc_util
-+ */
-+void            pvname_svc(char *, char *);
-+void            pvname(char *, char *);
-+void            ptype(char *, char *, int);
-+char *		make_argname(char *, char *);
-+void		add_type(int, char *);
-+void		reinitialize(void);
-+void		crash(void);
-+void		error(char *);
-+char           *fixtype(char *);
-+char           *stringfix(char *);
-+char           *locase(char *);
-+int             isvectordef(char *, relation);
-+int             streq(char *, char *);
-+void            tabify(FILE *, int);
-+void            record_open(char *);
-+bas_type       *find_type(char *type);
-+
-+/*
-+ * rpc_sample
-+ */
-+void		write_sample_svc(definition *);
-+int		write_sample_clnt(definition *);
-+void		write_sample_clnt_main(void);
-+void		add_sample_msg(void);
-diff --git a/rpcgen/rpcgen.1 b/rpcgen/rpcgen.1
-new file mode 100644
-index 0000000..89df7ed
---- /dev/null
-+++ b/rpcgen/rpcgen.1
-@@ -0,0 +1,521 @@
-+.\" @(#)rpcgen.1 1.35 93/06/02 SMI
-+.\" $FreeBSD: src/usr.bin/rpcgen/rpcgen.1,v 1.12.2.4 2002/06/21 15:28:50 charnier Exp $
-+.\" Copyright 1985-1993 Sun Microsystems, Inc.
-+.Dd March 28, 1993
-+.Dt RPCGEN 1
-+.Os
-+.Sh NAME
-+.Nm rpcgen
-+.Nd an RPC protocol compiler
-+.Sh SYNOPSIS
-+.Nm
-+.Ar infile
-+.Nm
-+.Op Fl a
-+.Op Fl b
-+.Op Fl C
-+.Oo
-+.Fl D Ns Ar name Ns Op Ar =value
-+.Oc
-+.Op Fl i Ar size
-+.Op Fl I Op Fl K Ar seconds
-+.Op Fl L
-+.Op Fl M
-+.Op Fl N
-+.Op Fl T
-+.Op Fl Y Ar pathname
-+.Ar infile
-+.Nm
-+.Oo
-+.Fl c |
-+.Fl h |
-+.Fl l |
-+.Fl m |
-+.Fl t |
-+.Fl \&Sc |
-+.Fl \&Ss |
-+.Fl \&Sm
-+.Oc
-+.Op Fl o Ar outfile
-+.Op Ar infile
-+.Nm
-+.Op Fl s Ar nettype
-+.Op Fl o Ar outfile
-+.Op Ar infile
-+.Nm
-+.Op Fl n Ar netid
-+.Op Fl o Ar outfile
-+.Op Ar infile
-+.\" .SH AVAILABILITY
-+.\" .LP
-+.\" SUNWcsu
-+.Sh DESCRIPTION
-+The
-+.Nm
-+utility is a tool that generates C code to implement an
-+.Tn RPC
-+protocol.
-+The input to
-+.Nm
-+is a language similar to C known as
-+.Tn RPC
-+Language (Remote Procedure Call Language).
-+.Pp
-+The
-+.Nm
-+utility is normally used as in the first synopsis where
-+it takes an input file and generates three output files.
-+If the
-+.Ar infile
-+is named
-+.Pa proto.x ,
-+then
-+.Nm
-+generates a header in
-+.Pa proto.h ,
-+XDR routines in
-+.Pa proto_xdr.c ,
-+server-side stubs in
-+.Pa proto_svc.c ,
-+and client-side stubs in
-+.Pa proto_clnt.c .
-+With the
-+.Fl T
-+option,
-+it also generates the
-+.Tn RPC
-+dispatch table in
-+.Pa proto_tbl.i .
-+.Pp
-+The
-+.Nm
-+utility can also generate sample client and server files
-+that can be customized to suit a particular application.
-+The
-+.Fl \&Sc ,
-+.Fl \&Ss
-+and
-+.Fl \&Sm
-+options generate sample client, server and makefile, respectively.
-+The
-+.Fl a
-+option generates all files, including sample files.
-+If the
-+.Ar infile
-+is
-+.Pa proto.x ,
-+then the client side sample file is written to
-+.Pa proto_client.c ,
-+the server side sample file to
-+.Pa proto_server.c
-+and the sample makefile to
-+.Pa makefile.proto .
-+.Pp
-+The server created can be started both by the port monitors
-+(for example,
-+.Xr inetd 8 )
-+or by itself.
-+When it is started by a port monitor,
-+it creates servers only for the transport for which
-+the file descriptor
-+.Em 0
-+was passed.
-+The name of the transport must be specified
-+by setting up the environment variable
-+.Ev PM_TRANSPORT .
-+When the server generated by
-+.Nm
-+is executed,
-+it creates server handles for all the transports
-+specified in
-+.Ev NETPATH
-+environment variable,
-+or if it is unset,
-+it creates server handles for all the visible transports from
-+.Pa /etc/netconfig
-+file.
-+Note:
-+the transports are chosen at run time and not at compile time.
-+When the server is self-started,
-+it backgrounds itself by default.
-+A special define symbol
-+.Em RPC_SVC_FG
-+can be used to run the server process in foreground.
-+.Pp
-+The second synopsis provides special features which allow
-+for the creation of more sophisticated
-+.Tn RPC
-+servers.
-+These features include support for user provided
-+.Em #defines
-+and
-+.Tn RPC
-+dispatch tables.
-+The entries in the
-+.Tn RPC
-+dispatch table contain:
-+.Bl -bullet -offset indent -compact
-+.It
-+pointers to the service routine corresponding to that procedure,
-+.It
-+a pointer to the input and output arguments,
-+.It
-+the size of these routines.
-+.El
-+A server can use the dispatch table to check authorization
-+and then to execute the service routine;
-+a client library may use it to deal with the details of storage
-+management and XDR data conversion.
-+.Pp
-+The other three synopses shown above are used when
-+one does not want to generate all the output files,
-+but only a particular one.
-+See the
-+.Sx EXAMPLES
-+section below for examples of
-+.Nm
-+usage.
-+When
-+.Nm
-+is executed with the
-+.Fl s
-+option,
-+it creates servers for that particular class of transports.
-+When
-+executed with the
-+.Fl n
-+option,
-+it creates a server for the transport specified by
-+.Ar netid .
-+If
-+.Ar infile
-+is not specified,
-+.Nm
-+accepts the standard input.
-+.Pp
-+The C preprocessor,
-+.Em cc -E
-+is run on the input file before it is actually interpreted by
-+.Nm .
-+For each type of output file,
-+.Nm
-+defines a special preprocessor symbol for use by the
-+.Nm
-+programmer:
-+.Bl -tag -width indent
-+.It RPC_HDR
-+defined when compiling into headers
-+.It RPC_XDR
-+defined when compiling into XDR routines
-+.It RPC_SVC
-+defined when compiling into server-side stubs
-+.It RPC_CLNT
-+defined when compiling into client-side stubs
-+.It RPC_TBL
-+defined when compiling into RPC dispatch tables
-+.El
-+.Pp
-+Any line beginning with
-+.Dq %
-+is passed directly into the output file,
-+uninterpreted by
-+.Nm .
-+To specify the path name of the C preprocessor use
-+.Fl Y
-+flag.
-+.Pp
-+For every data type referred to in
-+.Ar infile ,
-+.Nm
-+assumes that there exists a
-+routine with the string
-+.Em xdr_
-+prepended to the name of the data type.
-+If this routine does not exist in the
-+.Tn RPC/XDR
-+library, it must be provided.
-+Providing an undefined data type
-+allows customization of
-+.Xr xdr 3
-+routines.
-+.Sh OPTIONS
-+The following options are available:
-+.Bl -tag -width indent
-+.It Fl a
-+Generate all files, including sample files.
-+.It Fl b
-+Backward compatibility mode.
-+Generate transport specific
-+.Tn RPC
-+code for older versions
-+of the operating system.
-+.Pp
-+Note: in
-+.Fx ,
-+this compatibility flag is turned on by
-+default since
-+.Fx
-+supports only the older
-+.Tn ONC RPC
-+library.
-+.It Fl c
-+Compile into
-+.Tn XDR
-+routines.
-+.It Fl C
-+Generate header and stub files which can be used with
-+.Tn ANSI
-+C compilers.  Headers generated with this flag can also be
-+used with C++ programs.
-+.It Fl D Ns Ar name
-+.It Fl D Ns Ar name=value
-+.\".It Fl D Ns Ar name Ns Op Ar =value
-+Define a symbol
-+.Ar name .
-+Equivalent to the
-+.Em #define
-+directive in the source.
-+If no
-+.Ar value
-+is given,
-+.Ar value
-+is defined as
-+.Em 1 .
-+This option may be specified more than once.
-+.It Fl h
-+Compile into C data-definitions (a header).
-+.Fl T
-+option can be used in conjunction to produce a
-+header which supports
-+.Tn RPC
-+dispatch tables.
-+.It Fl i Ar size
-+Size at which to start generating inline code.
-+This option is useful for optimization.
-+The default size is 5.
-+.Pp
-+Note: in order to provide backwards compatibility with the older
-+.Nm
-+on the
-+.Fx
-+platform, the default is actually 0 (which means
-+that inline code generation is disabled by default). You must specify
-+a non-zero value explicitly to override this default.
-+.It Fl I
-+Compile support for
-+.Xr inetd 8
-+in the server side stubs.
-+Such servers can be self-started or can be started by
-+.Nm inetd .
-+When the server is self-started, it backgrounds itself by default.
-+A special define symbol
-+.Em RPC_SVC_FG
-+can be used to run the
-+server process in foreground, or the user may simply compile without
-+the
-+.Fl I
-+option.
-+.Pp
-+If there are no pending client requests, the
-+.Nm inetd
-+servers exit after 120 seconds (default).
-+The default can be changed with the
-+.Fl K
-+option.
-+All the error messages for
-+.Nm inetd
-+servers
-+are always logged with
-+.Xr syslog 3 .
-+.\" .IP
-+.\" Note:
-+.\" this option is supported for backward compatibility only.
-+.\" By default,
-+.\" .B rpcgen
-+.\" generates servers that can be invoked through portmonitors.
-+.Pp
-+.It Fl K Ar seconds
-+By default, services created using
-+.Nm
-+and invoked through
-+port monitors wait 120 seconds
-+after servicing a request before exiting.
-+That interval can be changed using the
-+.Fl K
-+flag.
-+To create a server that exits immediately upon servicing a request,
-+use
-+.Fl K Ar 0 .
-+To create a server that never exits, the appropriate argument is
-+.Fl k Ar -1 .
-+.Pp
-+When monitoring for a server,
-+some portmonitors
-+.Em always
-+spawn a new process in response to a service request.
-+If it is known that a server will be used with such a monitor, the
-+server should exit immediately on completion.
-+For such servers,
-+.Nm
-+should be used with
-+.Fl K Ar 0 .
-+.It Fl l
-+Compile into client-side stubs.
-+.It Fl L
-+When the servers are started in foreground, use
-+.Xr syslog 3
-+to log the server errors instead of printing them on the standard
-+error.
-+.It Fl m
-+Compile into server-side stubs,
-+but do not generate a
-+.Qq main
-+routine.
-+This option is useful for doing callback-routines
-+and for users who need to write their own
-+.Qq main
-+routine to do initialization.
-+.It Fl M
-+Generate multithread-safe stubs for passing arguments and results between
-+rpcgen generated code and user written code.
-+This option is useful
-+for users who want to use threads in their code.
-+However, the
-+.Xr rpc_svc_calls 3
-+functions are not yet MT-safe, which means that rpcgen generated server-side
-+code will not be MT-safe.
-+.It Fl N
-+This option allows procedures to have multiple arguments.
-+It also uses the style of parameter passing that closely resembles C.
-+So, when passing an argument to a remote procedure, you do not have to
-+pass a pointer to the argument, but can pass the argument itself.
-+This behavior is different from the old style of
-+.Nm
-+generated code.
-+To maintain backward compatibility,
-+this option is not the default.
-+.It Fl n Ar netid
-+Compile into server-side stubs for the transport
-+specified by
-+.Ar netid .
-+There should be an entry for
-+.Ar netid
-+in the
-+netconfig database.
-+This option may be specified more than once,
-+so as to compile a server that serves multiple transports.
-+.It Fl o Ar outfile
-+Specify the name of the output file.
-+If none is specified,
-+standard output is used
-+(
-+.Fl c ,
-+.Fl h ,
-+.Fl l ,
-+.Fl m ,
-+.Fl n ,
-+.Fl s ,
-+.Fl \&Sc ,
-+.Fl \&Sm ,
-+.Fl \&Ss ,
-+and
-+.Fl t
-+modes only).
-+.It Fl s Ar nettype
-+Compile into server-side stubs for all the
-+transports belonging to the class
-+.Ar nettype .
-+The supported classes are
-+.Em netpath ,
-+.Em visible ,
-+.Em circuit_n ,
-+.Em circuit_v ,
-+.Em datagram_n ,
-+.Em datagram_v ,
-+.Em tcp ,
-+and
-+.Em udp
-+(see
-+.Xr rpc 3
-+for the meanings associated with these classes).
-+This option may be specified more than once.
-+Note:
-+the transports are chosen at run time and not at compile time.
-+.It Fl \&Sc
-+Generate sample client code that uses remote procedure calls.
-+.It Fl \&Sm
-+Generate a sample
-+.Pa Makefile
-+which can be used for compiling the application.
-+.It Fl \&Ss
-+Generate sample server code that uses remote procedure calls.
-+.It Fl t
-+Compile into
-+.Tn RPC
-+dispatch table.
-+.It Fl T
-+Generate the code to support
-+.Tn RPC
-+dispatch tables.
-+.Pp
-+The options
-+.Fl c ,
-+.Fl h ,
-+.Fl l ,
-+.Fl m ,
-+.Fl s ,
-+.Fl \&Sc ,
-+.Fl \&Sm ,
-+.Fl \&Ss ,
-+and
-+.Fl t
-+are used exclusively to generate a particular type of file,
-+while the options
-+.Fl D
-+and
-+.Fl T
-+are global and can be used with the other options.
-+.It Fl Y Ar pathname
-+Give the name of the directory where
-+.Nm
-+will start looking for the C-preprocessor.
-+.El
-+.Sh EXAMPLES
-+The following example:
-+.Dl example% rpcgen -T prot.x
-+.Pp
-+generates all the five files:
-+.Pa prot.h ,
-+.Pa prot_clnt.c ,
-+.Pa prot_svc.c ,
-+.Pa prot_xdr.c
-+and
-+.Pa prot_tbl.i .
-+.Pp
-+The following example sends the C data-definitions (header)
-+to the standard output.
-+.Dl example% rpcgen -h prot.x
-+.Pp
-+To send the test version of the
-+.Fl D Ns Ar TEST ,
-+server side stubs for
-+all the transport belonging to the class
-+.Ar datagram_n
-+to standard output, use:
-+.Dl example% rpcgen -s datagram_n -DTEST prot.x
-+.Pp
-+To create the server side stubs for the transport indicated
-+by
-+.Ar netid
-+tcp,
-+use:
-+.Dl example% rpcgen -n tcp -o prot_svc.c prot.x
-+.Sh SEE ALSO
-+.Xr cc 1 ,
-+.Xr rpc 3 ,
-+.Xr syslog 3 ,
-+.Xr inetd 8
-+.\" .BR rpc_svc_calls (3)
-+.Rs
-+.%T The rpcgen chapter in the NETP manual
-+.Re
--- 
-1.9.1
-
diff --git a/package/libtirpc/0004-Automatically-generate-XDR-header-files-from-.x-sour.patch b/package/libtirpc/0003-Automatically-generate-XDR-header-files-from-.x-sour.patch
similarity index 98%
rename from package/libtirpc/0004-Automatically-generate-XDR-header-files-from-.x-sour.patch
rename to package/libtirpc/0003-Automatically-generate-XDR-header-files-from-.x-sour.patch
index e302c5d1ce..2712f53c38 100644
--- a/package/libtirpc/0004-Automatically-generate-XDR-header-files-from-.x-sour.patch
+++ b/package/libtirpc/0003-Automatically-generate-XDR-header-files-from-.x-sour.patch
@@ -1,4 +1,4 @@
-From eba198c27f2b8d3f0b27ea4a42f3dc79d397440c Mon Sep 17 00:00:00 2001
+From 001e3f26dc80b8f21bed7d9b5872fe10e8b4af04 Mon Sep 17 00:00:00 2001
 From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
 Date: Sat, 10 Nov 2012 17:29:53 +0100
 Subject: [PATCH] Automatically generate XDR header files from .x sources using
@@ -8,21 +8,23 @@ Subject: [PATCH] Automatically generate XDR header files from .x sources using
 Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
 [yann.morin.1998@free.fr: update for 0.3.1]
 Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
+[baruch: use external rpcgen]
+Signed-off-by: Baruch Siach <baruch@tkos.co.il>
 ---
- Makefile.am           |  19 +-
+ Makefile.am           |  16 +-
  src/Makefile.am       |   2 +-
- tirpc/rpc/rpcb_prot.h | 797 --------------------------------------------------
- tirpc/rpcsvc/crypt.h  | 109 -------
- 4 files changed, 17 insertions(+), 910 deletions(-)
+ tirpc/rpc/rpcb_prot.h | 797 ------------------------------------------
+ tirpc/rpcsvc/crypt.h  | 109 ------
+ 4 files changed, 14 insertions(+), 910 deletions(-)
  delete mode 100644 tirpc/rpc/rpcb_prot.h
  delete mode 100644 tirpc/rpcsvc/crypt.h
 
 diff --git a/Makefile.am b/Makefile.am
-index 8558289..aa5908e 100644
+index 3f6063771faf..368fb8a1aed2 100644
 --- a/Makefile.am
 +++ b/Makefile.am
 @@ -1,6 +1,9 @@
- SUBDIRS = src man doc rpcgen
+ SUBDIRS = src man doc
  ACLOCAL_AMFLAGS = -I m4
  
 +GENFILES	       = tirpc/rpcsvc/crypt.h \
@@ -39,7 +41,7 @@ index 8558289..aa5908e 100644
  			 tirpc/rpc/xdr.h \
  			 tirpc/rpc/types.h \
  			 tirpc/rpc/svc_soc.h \
-@@ -20,7 +22,6 @@ nobase_include_HEADERS = tirpc/netconfig.h \
+@@ -21,7 +23,6 @@ nobase_include_HEADERS = tirpc/netconfig.h \
  			 tirpc/rpc/rpcent.h \
  			 tirpc/rpc/rpc_com.h \
  			 tirpc/rpc/rpcb_prot.x \
@@ -47,7 +49,7 @@ index 8558289..aa5908e 100644
  			 tirpc/rpc/rpcb_clnt.h \
  			 tirpc/rpc/raw.h \
  			 tirpc/rpc/pmap_rmt.h \
-@@ -51,5 +52,17 @@ endif
+@@ -48,5 +49,14 @@ endif
  pkgconfigdir=$(libdir)/pkgconfig
  pkgconfig_DATA = libtirpc.pc
  
@@ -55,19 +57,16 @@ index 8558289..aa5908e 100644
 +nobase_nodist_include_HEADERS = $(GENFILES)
 +BUILT_SOURCES = $(GENFILES)
 +
-+$(GENFILES): %.h: %.x $(top_builddir)/rpcgen/rpcgen
++$(GENFILES): %.h: %.x
 +	mkdir -p $(dir $@)
-+	$(top_builddir)/rpcgen/rpcgen -h -o $@ $<
-+
-+$(top_builddir)/rpcgen/rpcgen: force
-+	cd rpcgen && $(MAKE)
++	rpcgen -h -o $@ $<
 +
 +force:
 +
 +CLEANFILES	       = cscope.* *~ $(GENFILES)
  DISTCLEANFILES	       = Makefile.in libtirpc*.tar.gz
 diff --git a/src/Makefile.am b/src/Makefile.am
-index 7428e92..0356171 100644
+index 2af40f16d03a..0b7e23835c36 100644
 --- a/src/Makefile.am
 +++ b/src/Makefile.am
 @@ -8,7 +8,7 @@
@@ -81,7 +80,7 @@ index 7428e92..0356171 100644
  
 diff --git a/tirpc/rpc/rpcb_prot.h b/tirpc/rpc/rpcb_prot.h
 deleted file mode 100644
-index 7ae48b8..0000000
+index 7ae48b805370..000000000000
 --- a/tirpc/rpc/rpcb_prot.h
 +++ /dev/null
 @@ -1,797 +0,0 @@
@@ -884,7 +883,7 @@ index 7ae48b8..0000000
 -#endif /* !_RPCB_PROT_H_RPCGEN */
 diff --git a/tirpc/rpcsvc/crypt.h b/tirpc/rpcsvc/crypt.h
 deleted file mode 100644
-index da1f9cc..0000000
+index da1f9ccb56ea..000000000000
 --- a/tirpc/rpcsvc/crypt.h
 +++ /dev/null
 @@ -1,109 +0,0 @@
@@ -998,5 +997,5 @@ index da1f9cc..0000000
 -
 -#endif /* !_CRYPT_H_RPCGEN */
 -- 
-1.9.1
+2.17.0
 
diff --git a/package/libtirpc/0005-Add-more-XDR-files-needed-to-build-rpcbind-on-top-of.patch b/package/libtirpc/0004-Add-more-XDR-files-needed-to-build-rpcbind-on-top-of.patch
similarity index 100%
rename from package/libtirpc/0005-Add-more-XDR-files-needed-to-build-rpcbind-on-top-of.patch
rename to package/libtirpc/0004-Add-more-XDR-files-needed-to-build-rpcbind-on-top-of.patch
diff --git a/package/libtirpc/0006-Disable-DES-authentification-support.patch b/package/libtirpc/0005-Disable-DES-authentification-support.patch
similarity index 100%
rename from package/libtirpc/0006-Disable-DES-authentification-support.patch
rename to package/libtirpc/0005-Disable-DES-authentification-support.patch
diff --git a/package/libtirpc/0007-include-stdint.h-for-uintptr_t.patch b/package/libtirpc/0006-include-stdint.h-for-uintptr_t.patch
similarity index 100%
rename from package/libtirpc/0007-include-stdint.h-for-uintptr_t.patch
rename to package/libtirpc/0006-include-stdint.h-for-uintptr_t.patch
diff --git a/package/libtirpc/libtirpc.mk b/package/libtirpc/libtirpc.mk
index d9bf22b83e..319b78c3f0 100644
--- a/package/libtirpc/libtirpc.mk
+++ b/package/libtirpc/libtirpc.mk
@@ -10,6 +10,7 @@ LIBTIRPC_SITE = http://downloads.sourceforge.net/project/libtirpc/libtirpc/$(LIB
 LIBTIRPC_LICENSE = BSD-3-Clause
 LIBTIRPC_LICENSE_FILES = COPYING
 
+LIBTIRPC_DEPENDENCIES = host-nfs-utils
 LIBTIRPC_INSTALL_STAGING = YES
 LIBTIRPC_AUTORECONF = YES
 
@@ -18,4 +19,11 @@ LIBTIRPC_CONF_ENV = CFLAGS="$(TARGET_CFLAGS) -DGQ"
 
 LIBTIRPC_CONF_OPTS = --disable-gssapi
 
+define HOST_LIBTIRPC_INSTALL_CMDS
+	$(INSTALL) -D -m 0644 $(@D)/tirpc/rpc/types.h $(HOST_DIR)/include/rpc/types.h
+	$(INSTALL) -D -m 0644 $(@D)/tirpc/netconfig.h $(HOST_DIR)/include/netconfig.h
+endef
+
 $(eval $(autotools-package))
+# We are only copying headers; no need for the autotools infrastructure
+$(eval $(host-generic-package))
diff --git a/package/libvncserver/0001-Limit-client-cut-text-length-to-1-MB.patch b/package/libvncserver/0001-Limit-client-cut-text-length-to-1-MB.patch
new file mode 100644
index 0000000000..84a537640d
--- /dev/null
+++ b/package/libvncserver/0001-Limit-client-cut-text-length-to-1-MB.patch
@@ -0,0 +1,65 @@
+From 28afb6c537dc82ba04d5f245b15ca7205c6dbb9c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
+Date: Mon, 26 Feb 2018 13:48:00 +0100
+Subject: [PATCH] Limit client cut text length to 1 MB
+
+This patch constrains a client cut text length to 1 MB. Otherwise
+a client could make server allocate 2 GB of memory and that seems to
+be to much to classify it as a denial of service.
+
+The limit also prevents from an integer overflow followed by copying
+an uninitilized memory when processing msg.cct.length value larger
+than SIZE_MAX or INT_MAX - sz_rfbClientCutTextMsg.
+
+This patch also corrects accepting length value of zero (malloc(0) is
+interpreted on differnet systems differently).
+
+CVE-2018-7225
+<https://github.com/LibVNC/libvncserver/issues/218>
+
+Signed-off-by: Peter Korsgaard <peter@korsgaard.com>
+---
+ libvncserver/rfbserver.c | 20 +++++++++++++++++++-
+ 1 file changed, 19 insertions(+), 1 deletion(-)
+
+diff --git a/libvncserver/rfbserver.c b/libvncserver/rfbserver.c
+index 116c488..4fc4d9d 100644
+--- a/libvncserver/rfbserver.c
++++ b/libvncserver/rfbserver.c
+@@ -88,6 +88,8 @@
+ #include <errno.h>
+ /* strftime() */
+ #include <time.h>
++/* PRIu32 */
++#include <inttypes.h>
+ 
+ #ifdef LIBVNCSERVER_WITH_WEBSOCKETS
+ #include "rfbssl.h"
+@@ -2575,7 +2577,23 @@ rfbProcessClientNormalMessage(rfbClientPtr cl)
+ 
+ 	msg.cct.length = Swap32IfLE(msg.cct.length);
+ 
+-	str = (char *)malloc(msg.cct.length);
++	/* uint32_t input is passed to malloc()'s size_t argument,
++	 * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int
++	 * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int
++	 * argument. Here we impose a limit of 1 MB so that the value fits
++	 * into all of the types to prevent from misinterpretation and thus
++	 * from accessing uninitialized memory (CVE-2018-7225) and also to
++	 * prevent from a denial-of-service by allocating to much memory in
++	 * the server. */
++	if (msg.cct.length > 1<<20) {
++	    rfbLog("rfbClientCutText: too big cut text length requested: %" PRIu32 "\n",
++		    msg.cct.length);
++	    rfbCloseClient(cl);
++	    return;
++	}
++
++	/* Allow zero-length client cut text. */
++	str = (char *)calloc(msg.cct.length ? msg.cct.length : 1, 1);
+ 	if (str == NULL) {
+ 		rfbLogPerror("rfbProcessClientNormalMessage: not enough memory");
+ 		rfbCloseClient(cl);
+-- 
+2.11.0
+
diff --git a/package/libvorbis/0001-CVE-2017-14160-fix-bounds-check-on-very-low-sample-rates.patch b/package/libvorbis/0001-CVE-2017-14160-fix-bounds-check-on-very-low-sample-rates.patch
new file mode 100644
index 0000000000..e84f3d4799
--- /dev/null
+++ b/package/libvorbis/0001-CVE-2017-14160-fix-bounds-check-on-very-low-sample-rates.patch
@@ -0,0 +1,28 @@
+From: Thomas Daede <daede003@umn.edu>
+Date: Wed, 9 May 2018 21:56:59 +0000 (-0700)
+Subject: CVE-2017-14160: fix bounds check on very low sample rates.
+X-Git-Url: https://git.xiph.org/?p=vorbis.git;a=commitdiff_plain;h=018ca26dece618457dd13585cad52941193c4a25
+
+CVE-2017-14160: fix bounds check on very low sample rates.
+
+Downloaded from upstream commit
+https://git.xiph.org/?p=vorbis.git;a=commitdiff;h=018ca26dece618457dd13585cad52941193c4a25
+
+Signed-off-by: Bernd Kuhls <bernd.kuhls@t-online.de>
+---
+
+diff --git a/lib/psy.c b/lib/psy.c
+index 422c6f1..1310123 100644
+--- a/lib/psy.c
++++ b/lib/psy.c
+@@ -602,8 +602,9 @@ static void bark_noise_hybridmp(int n,const long *b,
+   for (i = 0, x = 0.f;; i++, x += 1.f) {
+ 
+     lo = b[i] >> 16;
+-    if( lo>=0 ) break;
+     hi = b[i] & 0xffff;
++    if( lo>=0 ) break;
++    if( hi>=n ) break;
+ 
+     tN = N[hi] + N[-lo];
+     tX = X[hi] - X[-lo];
diff --git a/package/libxslt/0001-Fix-heap-overread-in-xsltFormatNumberConversion.patch b/package/libxslt/0001-Fix-heap-overread-in-xsltFormatNumberConversion.patch
deleted file mode 100644
index 1ad494a6c0..0000000000
--- a/package/libxslt/0001-Fix-heap-overread-in-xsltFormatNumberConversion.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From eb1030de31165b68487f288308f9d1810fed6880 Mon Sep 17 00:00:00 2001
-From: Nick Wellnhofer <wellnhofer@aevum.de>
-Date: Fri, 10 Jun 2016 14:23:58 +0200
-Subject: [PATCH] Fix heap overread in xsltFormatNumberConversion
-
-An empty decimal-separator could cause a heap overread. This can be
-exploited to leak a couple of bytes after the buffer that holds the
-pattern string.
-
-Found with afl-fuzz and ASan.
-
-Signed-off-by: Baruch Siach <baruch@tkos.co.il>
----
-Patch status: upstream commit eb1030de311
-
- libxslt/numbers.c | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
-diff --git a/libxslt/numbers.c b/libxslt/numbers.c
-index d1549b46ca26..e78c46b6357b 100644
---- a/libxslt/numbers.c
-+++ b/libxslt/numbers.c
-@@ -1090,7 +1090,8 @@ xsltFormatNumberConversion(xsltDecimalFormatPtr self,
-     }
- 
-     /* We have finished the integer part, now work on fraction */
--    if (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) {
-+    if ( (*the_format != 0) &&
-+         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {
-         format_info.add_decimal = TRUE;
- 	the_format += xsltUTF8Size(the_format);	/* Skip over the decimal */
-     }
--- 
-2.10.2
-
diff --git a/package/libxslt/libxslt.hash b/package/libxslt/libxslt.hash
index 8222bc590d..f28150b71e 100644
--- a/package/libxslt/libxslt.hash
+++ b/package/libxslt/libxslt.hash
@@ -1,2 +1,5 @@
 # Locally calculated after checking pgp signature
-sha256	b5976e3857837e7617b29f2249ebb5eeac34e249208d31f1fbf7a6ba7a4090ce	libxslt-1.1.29.tar.gz
+sha256	526ecd0abaf4a7789041622c3950c0e7f2c4c8835471515fd77eec684a355460	libxslt-1.1.32.tar.gz
+
+# Hash for license file:
+sha256	7e48e290b6bfccc2ec1b297023a1d77f2fd87417f71fbb9f50aabef40a851819	COPYING
diff --git a/package/libxslt/libxslt.mk b/package/libxslt/libxslt.mk
index d89dde8d00..f05bc5a70a 100644
--- a/package/libxslt/libxslt.mk
+++ b/package/libxslt/libxslt.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-LIBXSLT_VERSION = 1.1.29
+LIBXSLT_VERSION = 1.1.32
 LIBXSLT_SITE = ftp://xmlsoft.org/libxslt
 LIBXSLT_INSTALL_STAGING = YES
 LIBXSLT_LICENSE = MIT
@@ -13,11 +13,9 @@ LIBXSLT_LICENSE_FILES = COPYING
 LIBXSLT_CONF_OPTS = \
 	--with-gnu-ld \
 	--without-debug \
-	--without-python \
-	--with-libxml-prefix=$(STAGING_DIR)/usr/ \
-	--with-libxml-libs-prefix=$(STAGING_DIR)/usr/lib
+	--without-python
 LIBXSLT_CONFIG_SCRIPTS = xslt-config
-LIBXSLT_DEPENDENCIES = libxml2
+LIBXSLT_DEPENDENCIES = host-pkgconf libxml2
 
 # GCC bug with Os/O2/O3, PR77311
 # error: unable to find a register to spill in class 'CCREGS'
@@ -35,7 +33,7 @@ endif
 
 HOST_LIBXSLT_CONF_OPTS = --without-debug --without-python --without-crypto
 
-HOST_LIBXSLT_DEPENDENCIES = host-libxml2
+HOST_LIBXSLT_DEPENDENCIES = host-pkgconf host-libxml2
 
 $(eval $(autotools-package))
 $(eval $(host-autotools-package))
diff --git a/package/linux-headers/Config.in.host b/package/linux-headers/Config.in.host
index 7d579325aa..982e24fff8 100644
--- a/package/linux-headers/Config.in.host
+++ b/package/linux-headers/Config.in.host
@@ -240,14 +240,14 @@ endchoice
 
 config BR2_DEFAULT_KERNEL_HEADERS
 	string
-	default "3.2.101"	if BR2_KERNEL_HEADERS_3_2
-	default "4.1.51"	if BR2_KERNEL_HEADERS_4_1
-	default "4.4.131"	if BR2_KERNEL_HEADERS_4_4
-	default "4.9.98"	if BR2_KERNEL_HEADERS_4_9
+	default "3.2.102"	if BR2_KERNEL_HEADERS_3_2
+	default "4.1.52"	if BR2_KERNEL_HEADERS_4_1
+	default "4.4.138"	if BR2_KERNEL_HEADERS_4_4
+	default "4.9.109"	if BR2_KERNEL_HEADERS_4_9
 	default "4.10.17"	if BR2_KERNEL_HEADERS_4_10
 	default "4.11.12"	if BR2_KERNEL_HEADERS_4_11
 	default "4.12.14"	if BR2_KERNEL_HEADERS_4_12
 	default "4.13.16"	if BR2_KERNEL_HEADERS_4_13
-	default "4.14.39"	if BR2_KERNEL_HEADERS_4_14
+	default "4.14.50"	if BR2_KERNEL_HEADERS_4_14
 	default "4.15.18"	if BR2_KERNEL_HEADERS_4_15
 	default BR2_DEFAULT_KERNEL_VERSION if BR2_KERNEL_HEADERS_VERSION
diff --git a/package/log4cplus/log4cplus.mk b/package/log4cplus/log4cplus.mk
index 292fa66d49..b4a57c36c3 100644
--- a/package/log4cplus/log4cplus.mk
+++ b/package/log4cplus/log4cplus.mk
@@ -7,7 +7,7 @@
 LOG4CPLUS_VERSION = 1.1.2
 LOG4CPLUS_SOURCE = log4cplus-$(LOG4CPLUS_VERSION).tar.xz
 LOG4CPLUS_SITE = http://downloads.sourceforge.net/project/log4cplus/log4cplus-stable/$(LOG4CPLUS_VERSION)
-LOG4CPLUS_LICENSE = Apache-2.0
+LOG4CPLUS_LICENSE = Apache-2.0, BSD-2-Clause
 LOG4CPLUS_LICENSE_FILES = LICENSE
 LOG4CPLUS_INSTALL_STAGING = YES
 
diff --git a/package/lrzsz/lrzsz.mk b/package/lrzsz/lrzsz.mk
index 5dac07a295..25ecf3dead 100644
--- a/package/lrzsz/lrzsz.mk
+++ b/package/lrzsz/lrzsz.mk
@@ -24,6 +24,10 @@ define LRZSZ_INSTALL_TARGET_CMDS
 	$(INSTALL) -m 0755 -D $(@D)/src/lsz $(TARGET_DIR)/usr/bin/sz
 	ln -sf rz $(TARGET_DIR)/usr/bin/lrz
 	ln -sf sz $(TARGET_DIR)/usr/bin/lsz
+	ln -sf rz $(TARGET_DIR)/usr/bin/rb
+	ln -sf sz $(TARGET_DIR)/usr/bin/sb
+	ln -sf rz $(TARGET_DIR)/usr/bin/rx
+	ln -sf sz $(TARGET_DIR)/usr/bin/sx
 endef
 
 $(eval $(autotools-package))
diff --git a/package/ltrace/Config.in b/package/ltrace/Config.in
index 4d5fb723d6..2defbe28a0 100644
--- a/package/ltrace/Config.in
+++ b/package/ltrace/Config.in
@@ -1,14 +1,20 @@
+config BR2_PACKAGE_LTRACE_ARCH_SUPPORTS
+	bool
+	default y if BR2_arm
+	default y if BR2_i386
+	default y if BR2_mips
+	default y if BR2_mipsel
+	default y if BR2_powerpc
+	default y if BR2_sparc
+	default y if BR2_x86_64
+	default y if BR2_xtensa
+
 config BR2_PACKAGE_LTRACE
 	bool "ltrace"
 	depends on BR2_USE_WCHAR # elfutils
 	depends on !BR2_STATIC_LIBS # elfutils
 	depends on BR2_TOOLCHAIN_USES_UCLIBC || BR2_TOOLCHAIN_USES_GLIBC # elfutils
-	# ltrace normally has mips/mipsel support, but it's currently
-	# broken (error: 'struct ltelf' has no member named
-	# 'relplt_count'). Issue reported upstream at
-	# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=756764.
-	depends on (BR2_i386 || BR2_arm || BR2_mips || BR2_mipsel \
-		|| BR2_powerpc || BR2_sparc || BR2_x86_64 || BR2_xtensa)
+	depends on BR2_PACKAGE_LTRACE_ARCH_SUPPORTS
 	select BR2_PACKAGE_ELFUTILS
 	help
 	  Debugging program which runs a specified command until it
@@ -19,5 +25,6 @@ config BR2_PACKAGE_LTRACE
 	  http://ltrace.org
 
 comment "ltrace needs a uClibc or glibc toolchain w/ wchar, dynamic library"
+	depends on BR2_PACKAGE_LTRACE_ARCH_SUPPORTS
 	depends on !BR2_USE_WCHAR || BR2_STATIC_LIBS \
 		|| !(BR2_TOOLCHAIN_USES_UCLIBC || BR2_TOOLCHAIN_USES_GLIBC)
diff --git a/package/lynx/0001-src-chrtrans-don-t-build-host-tools-with-target-LDFL.patch b/package/lynx/0001-src-chrtrans-don-t-build-host-tools-with-target-LDFL.patch
new file mode 100644
index 0000000000..cc057cee13
--- /dev/null
+++ b/package/lynx/0001-src-chrtrans-don-t-build-host-tools-with-target-LDFL.patch
@@ -0,0 +1,41 @@
+From bb47abe9e7996147f6b7b325f5c9b2143abf8f13 Mon Sep 17 00:00:00 2001
+From: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Date: Mon, 7 May 2018 22:00:52 +0200
+Subject: [PATCH] src/chrtrans: don't build host tools with target LDFLAGS
+
+In a cross-compilation context, the LDFLAGS variable contains linker
+flags used when building things for the target. However, the makeuctb
+tool is built for the host machine, and therefore should not use the
+same LDFLAGS as the target, which is why BUILD_LDFLAGS exist.
+
+Using LDFLAGS when building a tool for the host can cause problems
+when some flags in LDFLAGS are not supported by the host machine. For
+example, if you're linking statically lynx for the target, but the
+build machine does not support static linking:
+
+gcc -I../.. -I../../src -I../../src/chrtrans -I../../WWW/Library/Implementation -I../../     -static  -o makeuctb makeuctb.o
+/usr/bin/ld: cannot find -lc
+collect2: error: ld returned 1 exit status
+
+Signed-off-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Upstream-status: submitted on the mailing list
+---
+ src/chrtrans/makefile.in | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/src/chrtrans/makefile.in b/src/chrtrans/makefile.in
+index aab358f..6e0ef03 100644
+--- a/src/chrtrans/makefile.in
++++ b/src/chrtrans/makefile.in
+@@ -123,7 +123,7 @@ OBJS		= makeuctb$o
+ C_SRC		= $(OBJS:$o=.c)
+ 
+ $(MAKEUCTB) : $(OBJS)
+-	$(BUILD_CC) $(CC_OPTS) $(LDFLAGS) $(BUILD_LDFLAGS) -o $@ $(OBJS) $(INTLLIB) $(BUILD_LIBS)
++	$(BUILD_CC) $(CC_OPTS) $(BUILD_LDFLAGS) -o $@ $(OBJS) $(INTLLIB) $(BUILD_LIBS)
+ 
+ makeuctb$o : $(srcdir)/UCkd.h $(srcdir)/makeuctb.c
+ 
+-- 
+2.14.3
+
diff --git a/package/mariadb/mariadb.hash b/package/mariadb/mariadb.hash
index cc1e353ab7..7eea62ab7b 100644
--- a/package/mariadb/mariadb.hash
+++ b/package/mariadb/mariadb.hash
@@ -1,5 +1,5 @@
-# From https://downloads.mariadb.org/mariadb/10.1.31/
-sha256 ab7641c2fe4e5289da6141766a9c3350e013def56fafd6f1377080bc8048b2e6  mariadb-10.1.31.tar.gz
+# From https://downloads.mariadb.org/mariadb/10.1.33/
+sha256 94312c519f2c0c25e1964c64e22aff0036fb22dfb2685638f43a6b2211395d2d  mariadb-10.1.33.tar.gz
 
 # Hash for license files
 sha256 69ce89a0cadbe35a858398c258be93c388715e84fc0ca04e5a1fd1aa9770dd3a  README
diff --git a/package/mariadb/mariadb.mk b/package/mariadb/mariadb.mk
index 54eafc1702..ce846d9cda 100644
--- a/package/mariadb/mariadb.mk
+++ b/package/mariadb/mariadb.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-MARIADB_VERSION = 10.1.31
+MARIADB_VERSION = 10.1.33
 MARIADB_SITE = https://downloads.mariadb.org/interstitial/mariadb-$(MARIADB_VERSION)/source
 MARIADB_LICENSE = GPL-2.0 (server), GPL-2.0 with FLOSS exception (GPL client library), LGPL-2.0 (LGPL client library)
 # Tarball no longer contains LGPL license text
diff --git a/package/mbedtls/mbedtls.hash b/package/mbedtls/mbedtls.hash
index f5331bed15..16f03fb7d8 100644
--- a/package/mbedtls/mbedtls.hash
+++ b/package/mbedtls/mbedtls.hash
@@ -1,5 +1,5 @@
-# From https://tls.mbed.org/tech-updates/releases/mbedtls-2.8.0-2.7.2-and-2.1.11-released
-sha1	e36d7cbdc2ed0a5d5659385840e8fbb4d351234e	mbedtls-2.7.2-apache.tgz
-sha256	fd38c2bb5fbe1ffd3e7fdcdd71130986f2010f25b3a5575eb8ded0dd3bc573d7	mbedtls-2.7.2-apache.tgz
+# From https://tls.mbed.org/tech-updates/releases/mbedtls-2.9.0-2.7.3-and-2.1.12-released
+sha1	8352f6713a9ee695f6f19e893c0e85941af71967	mbedtls-2.7.3-apache.tgz
+sha256	05282af7d95fedb2430c248ffe3081646800b8dae9071f8da11a07100963d765	mbedtls-2.7.3-apache.tgz
 # Locally calculated
 sha256	cfc7749b96f63bd31c3c42b5c471bf756814053e847c10f3eb003417bc523d30	apache-2.0.txt
diff --git a/package/mbedtls/mbedtls.mk b/package/mbedtls/mbedtls.mk
index ca44ee3713..e6012dcb3f 100644
--- a/package/mbedtls/mbedtls.mk
+++ b/package/mbedtls/mbedtls.mk
@@ -5,7 +5,7 @@
 ################################################################################
 
 MBEDTLS_SITE = https://tls.mbed.org/code/releases
-MBEDTLS_VERSION = 2.7.2
+MBEDTLS_VERSION = 2.7.3
 MBEDTLS_SOURCE = mbedtls-$(MBEDTLS_VERSION)-apache.tgz
 MBEDTLS_CONF_OPTS = \
 	-DENABLE_PROGRAMS=$(if $(BR2_PACKAGE_MBEDTLS_PROGRAMS),ON,OFF) \
diff --git a/package/mpg123/mpg123.hash b/package/mpg123/mpg123.hash
index cbab6f3ee9..22db5bca3c 100644
--- a/package/mpg123/mpg123.hash
+++ b/package/mpg123/mpg123.hash
@@ -1,5 +1,7 @@
-# Locally calculated after checking pgp signature
-sha256	5314b0fb8ad291bfc79ff4c5c321b971916819a65233ec065434358fcf8aee38	mpg123-1.25.2.tar.bz2
-
+# From https://sourceforge.net/projects/mpg123/files/mpg123/1.25.10/
+sha1 604784ddbcfe282bffdc595d1d45c677c7cf381f  mpg123-1.25.10.tar.bz2
+md5 ea32caa61d41d8be797f0b04a1b43ad9  mpg123-1.25.10.tar.bz2
+# Locally calculated
+sha256 6c1337aee2e4bf993299851c70b7db11faec785303cfca3a5c3eb5f329ba7023  mpg123-1.25.10.tar.bz2
 # License file
 sha256  f40e0dd86b27b52e429b693a87b3ca63ae0a98a4d142e77207aa6bdf1db7a295  COPYING
diff --git a/package/mpg123/mpg123.mk b/package/mpg123/mpg123.mk
index 01923d7990..dd2d39d978 100644
--- a/package/mpg123/mpg123.mk
+++ b/package/mpg123/mpg123.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-MPG123_VERSION = 1.25.2
+MPG123_VERSION = 1.25.10
 MPG123_SOURCE = mpg123-$(MPG123_VERSION).tar.bz2
 MPG123_SITE = http://downloads.sourceforge.net/project/mpg123/mpg123/$(MPG123_VERSION)
 MPG123_CONF_OPTS = --disable-lfs-alias
diff --git a/package/nasm/0001-nasmlib-Drop-unused-seg_init.patch b/package/nasm/0001-nasmlib-Drop-unused-seg_init.patch
new file mode 100644
index 0000000000..a18d121bfb
--- /dev/null
+++ b/package/nasm/0001-nasmlib-Drop-unused-seg_init.patch
@@ -0,0 +1,32 @@
+From 5eb1838b4d3752fd863d19442943983a2a5ee87c Mon Sep 17 00:00:00 2001
+From: Cyrill Gorcunov <gorcunov@gmail.com>
+Date: Sat, 10 Feb 2018 00:33:41 +0300
+Subject: [PATCH] nasmlib: Drop unused seg_init
+
+The helper has been eliminated in 2c4a4d5810d0a59b033a07876a2648ef5d4c2859
+
+https://bugzilla.nasm.us/show_bug.cgi?id=3392461
+
+Signed-off-by: Cyrill Gorcunov <gorcunov@gmail.com>
+---
+ include/nasmlib.h | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/include/nasmlib.h b/include/nasmlib.h
+index 79e866b5..fee1b5ea 100644
+--- a/include/nasmlib.h
++++ b/include/nasmlib.h
+@@ -188,10 +188,8 @@ int64_t readnum(char *str, bool *error);
+ int64_t readstrnum(char *str, int length, bool *warn);
+ 
+ /*
+- * seg_init: Initialise the segment-number allocator.
+  * seg_alloc: allocate a hitherto unused segment number.
+  */
+-void pure_func seg_init(void);
+ int32_t pure_func seg_alloc(void);
+ 
+ /*
+-- 
+2.17.0
+
diff --git a/package/nasm/nasm.hash b/package/nasm/nasm.hash
index 260e5d7bc4..db5b857193 100644
--- a/package/nasm/nasm.hash
+++ b/package/nasm/nasm.hash
@@ -1,3 +1,3 @@
 # Locally calculated
-sha256 8ac3235f49a6838ff7a8d7ef7c19a4430d0deecc0c2d3e3e237b5e9f53291757  nasm-2.13.02.tar.xz
+sha256 812ecfb0dcbc5bd409aaa8f61c7de94c5b8752a7b00c632883d15b2ed6452573  nasm-2.13.03.tar.xz
 sha256 1563996c52e220e15ef2418e67d39488255aa8c28c89e617074d3afe3ee329e0  LICENSE
diff --git a/package/nasm/nasm.mk b/package/nasm/nasm.mk
index ee3fd9c542..76bcca3bbf 100644
--- a/package/nasm/nasm.mk
+++ b/package/nasm/nasm.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-NASM_VERSION = 2.13.02
+NASM_VERSION = 2.13.03
 NASM_SOURCE = nasm-$(NASM_VERSION).tar.xz
 NASM_SITE = http://www.nasm.us/pub/nasm/releasebuilds/$(NASM_VERSION)
 NASM_LICENSE = BSD-2-Clause
diff --git a/package/netplug/S29netplug b/package/netplug/S29netplug
index d3df9ddff5..66459061b3 100755
--- a/package/netplug/S29netplug
+++ b/package/netplug/S29netplug
@@ -22,8 +22,8 @@ elif [ -f /etc/rc.d/init.d/functions ]; then
 fi
 
 # Source networking configuration.
-if [ -f /etc/sysconfig/network ]; then
-	. /etc/sysconfig/network
+if [ -f /etc/default/network ]; then
+	. /etc/default/network
 
 	# Check that networking is up.
 	[ ${NETWORKING} = "no" ] && exit 0
@@ -32,10 +32,8 @@ elif [ ! -f /etc/network/interfaces ]; then
 	exit 0
 fi
 
-[ -x /sbin/netplugd ] || exit 0
-
-if [ -f /etc/sysconfig/netplugd ]; then
-    . /etc/sysconfig/netplugd
+if [ -f /etc/default/netplugd ]; then
+    . /etc/default/netplugd
 fi
 
 # See how we were called.
@@ -43,7 +41,7 @@ case "$1" in
   start)
 	# Start daemon.
 	printf "Starting network plug daemon: "
-	start-stop-daemon -S -q -p /var/run/netplugd.pid -x /sbin/netplugd ${NETPLUGDARGS}
+	start-stop-daemon -S -q -x /sbin/netplugd -- -p /var/run/netplugd.pid ${NETPLUGDARGS}
 	RETVAL=$?
 	echo
 	[ $RETVAL -eq 0 ] && touch /var/lock/subsys/netplugd
@@ -51,7 +49,7 @@ case "$1" in
   stop)
 	# Stop daemon.
 	printf "Shutting down network plug daemon: "
-	start-stop-daemon -K -n netplugd
+	start-stop-daemon -K -q -p /var/run/netplugd.pid
 	RETVAL=$?
 	echo
 	[ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/netplugd
diff --git a/package/network-manager/Config.in b/package/network-manager/Config.in
index 72658c1278..9602cc4a1a 100644
--- a/package/network-manager/Config.in
+++ b/package/network-manager/Config.in
@@ -1,5 +1,5 @@
 config BR2_PACKAGE_NETWORK_MANAGER
-	bool "networkmanager"
+	bool "network-manager"
 	depends on BR2_PACKAGE_LIBGPG_ERROR_ARCH_SUPPORTS # libgcrypt
 	depends on !BR2_STATIC_LIBS # gnutls
 	depends on BR2_USE_MMU # dbus
diff --git a/package/nfs-utils/Config.in b/package/nfs-utils/Config.in
index 4e139363fc..055b711f0d 100644
--- a/package/nfs-utils/Config.in
+++ b/package/nfs-utils/Config.in
@@ -11,7 +11,7 @@ config BR2_PACKAGE_NFS_UTILS
 	help
 	  The NFS Linux kernel server.
 
-	  http://sourceforge.net/projects/nfs
+	  http://linux-nfs.org/
 
 if BR2_PACKAGE_NFS_UTILS
 
diff --git a/package/nfs-utils/nfs-utils.mk b/package/nfs-utils/nfs-utils.mk
index 26112d69f2..9fa7ae200b 100644
--- a/package/nfs-utils/nfs-utils.mk
+++ b/package/nfs-utils/nfs-utils.mk
@@ -24,6 +24,20 @@ NFS_UTILS_CONF_OPTS = \
 	--with-statedir=/run/nfs \
 	--with-rpcgen=internal
 
+HOST_NFS_UTILS_CONF_OPTS = \
+	--disable-nfsv4 \
+	--disable-nfsv41 \
+	--disable-gss \
+	--disable-uuid \
+	--disable-ipv6 \
+	--without-tcp-wrappers \
+	--with-statedir=/run/nfs \
+	--disable-caps \
+	--disable-tirpc \
+	--without-systemd \
+	--with-rpcgen=internal
+HOST_NFS_UTILS_DEPENDENCIES = host-pkgconf host-libtirpc
+
 NFS_UTILS_TARGETS_$(BR2_PACKAGE_NFS_UTILS_RPCDEBUG) += usr/sbin/rpcdebug
 NFS_UTILS_TARGETS_$(BR2_PACKAGE_NFS_UTILS_RPC_LOCKD) += usr/sbin/rpc.lockd
 NFS_UTILS_TARGETS_$(BR2_PACKAGE_NFS_UTILS_RPC_RQUOTAD) += usr/sbin/rpc.rquotad
@@ -89,4 +103,13 @@ endef
 # nfsiostat is interpreted python, so remove it unless it's in the target
 NFS_UTILS_POST_INSTALL_TARGET_HOOKS += $(if $(BR2_PACKAGE_PYTHON),,NFS_UTILS_REMOVE_NFSIOSTAT)
 
+define HOST_NFS_UTILS_BUILD_CMDS
+	$(MAKE) -C $(@D)/tools/rpcgen
+endef
+
+define HOST_NFS_UTILS_INSTALL_CMDS
+	$(INSTALL) -D -m 0755 $(@D)/tools/rpcgen/rpcgen $(HOST_DIR)/bin/rpcgen
+endef
+
 $(eval $(autotools-package))
+$(eval $(host-autotools-package))
diff --git a/package/nodejs/nodejs.hash b/package/nodejs/nodejs.hash
index b3900f6a7d..be4c3de4f7 100644
--- a/package/nodejs/nodejs.hash
+++ b/package/nodejs/nodejs.hash
@@ -1,5 +1,5 @@
-# From http://nodejs.org/dist/v8.11.1/SHASUMS256.txt
-sha256 40a6eb51ea37fafcf0cfb58786b15b99152bec672cccf861c14d1cca0ad4758a  node-v8.11.1.tar.xz
+# From http://nodejs.org/dist/v8.11.3/SHASUMS256.txt
+sha256 577c751fdca91c46c60ffd8352e5b465881373bfdde212c17c3a3c1bd2616ee0  node-v8.11.3.tar.xz
 
 # Hash for license file
 sha256 b87be6c1479ed977481115869c2dd8b6d59e5ea55aa09939d6c898242121b2f5  LICENSE
diff --git a/package/nodejs/nodejs.mk b/package/nodejs/nodejs.mk
index 2642525c47..61cd03bb8f 100644
--- a/package/nodejs/nodejs.mk
+++ b/package/nodejs/nodejs.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-NODEJS_VERSION = 8.11.1
+NODEJS_VERSION = 8.11.3
 NODEJS_SOURCE = node-v$(NODEJS_VERSION).tar.xz
 NODEJS_SITE = http://nodejs.org/dist/v$(NODEJS_VERSION)
 NODEJS_DEPENDENCIES = host-python host-nodejs c-ares \
diff --git a/package/openvmtools/openvmtools.mk b/package/openvmtools/openvmtools.mk
index cc71324ff0..9501ef3361 100644
--- a/package/openvmtools/openvmtools.mk
+++ b/package/openvmtools/openvmtools.mk
@@ -17,7 +17,7 @@ OPENVMTOOLS_CONF_OPTS = --with-dnet \
 	--without-gtkmm --without-kernel-modules \
 	--disable-deploypkg --without-xerces
 OPENVMTOOLS_CONF_ENV += CUSTOM_DNET_CPPFLAGS=" "
-OPENVMTOOLS_DEPENDENCIES = libglib2 libdnet
+OPENVMTOOLS_DEPENDENCIES = host-nfs-utils libglib2 libdnet
 
 # When libfuse is available, openvmtools can build vmblock-fuse, so
 # make sure that libfuse gets built first
diff --git a/package/patch/patch.mk b/package/patch/patch.mk
index 33f0039d60..d581682c70 100644
--- a/package/patch/patch.mk
+++ b/package/patch/patch.mk
@@ -11,10 +11,10 @@ PATCH_LICENSE = GPL-3.0+
 PATCH_LICENSE_FILES = COPYING
 
 ifeq ($(BR2_PACKAGE_ATTR),y)
-PATCH_CONF_OPTS += --enable-attr
+PATCH_CONF_OPTS += --enable-xattr
 PATCH_DEPENDENCIES += attr
 else
-PATCH_CONF_OPTS += --disable-attr
+PATCH_CONF_OPTS += --disable-xattr
 endif
 
 $(eval $(autotools-package))
diff --git a/package/perl/0001-PATCH-Remove-existing-files-before-overwriting-them.patch b/package/perl/0001-PATCH-Remove-existing-files-before-overwriting-them.patch
new file mode 100644
index 0000000000..5223b78c01
--- /dev/null
+++ b/package/perl/0001-PATCH-Remove-existing-files-before-overwriting-them.patch
@@ -0,0 +1,46 @@
+From ae65651eab053fc6dc4590dbb863a268215c1fc5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
+Date: Fri, 8 Jun 2018 11:45:40 +0100
+Subject: [PATCH] [PATCH] Remove existing files before overwriting them
+
+Archive should extract only the latest same-named entry.
+Extracted regular file should not be writtent into existing block
+device (or any other one).
+
+https://rt.cpan.org/Ticket/Display.html?id=125523
+
+[Peter: rewrite path to match perl tarball with sed 's|\(lib/Archive\)|cpan/Archive-Tar/\1|g']
+Signed-off-by: Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
+Signed-off-by: Peter Korsgaard <peter@korsgaard.com>
+---
+ cpan/Archive-Tar/lib/Archive/Tar.pm | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git a/cpan/Archive-Tar/lib/Archive/Tar.pm b/cpan/Archive-Tar/lib/Archive/Tar.pm
+index 6244369..a83975f 100644
+--- a/cpan/Archive-Tar/lib/Archive/Tar.pm
++++ b/cpan/Archive-Tar/lib/Archive/Tar.pm
+@@ -845,6 +845,20 @@ sub _extract_file {
+         return;
+     }
+ 
++    ### If a file system already contains a block device with the same name as
++    ### the being extracted regular file, we would write the file's content
++    ### to the block device. So remove the existing file (block device) now.
++    ### If an archive contains multiple same-named entries, the last one
++    ### should replace the previous ones. So remove the old file now.
++    ### If the old entry is a symlink to a file outside of the CWD, the new
++    ### entry would create a file there. This is CVE-2018-12015
++    ### <https://rt.cpan.org/Ticket/Display.html?id=125523>.
++    if (-l $full || -e _) {
++	if (!unlink $full) {
++	    $self->_error( qq[Could not remove old file '$full': $!] );
++	    return;
++	}
++    }
+     if( length $entry->type && $entry->is_file ) {
+         my $fh = IO::File->new;
+         $fh->open( $full, '>' ) or (
+-- 
+2.11.0
+
diff --git a/package/perl/perl.hash b/package/perl/perl.hash
index 14e6b117ca..210f6d581b 100644
--- a/package/perl/perl.hash
+++ b/package/perl/perl.hash
@@ -1,7 +1,7 @@
-# Hashes from: http://www.cpan.org/src/5.0/perl-5.26.1.tar.xz.{md5,sha1,sha256}.txt
-md5    70e988b4318739b0cf3ad5e120bfde88                                 perl-5.26.1.tar.xz
-sha1   403bb1804cb41416153d908eea093f2be22a77f6                         perl-5.26.1.tar.xz
-sha256 fe8208133e73e47afc3251c08d2c21c5a60160165a8ab8b669c43a420e4ec680 perl-5.26.1.tar.xz
+# Hashes from: http://www.cpan.org/src/5.0/perl-5.26.2.tar.xz.{md5,sha1,sha256}.txt
+md5    1fa1b53eeff76aa37b17bfc9b2771671                                 perl-5.26.2.tar.xz
+sha1   bfa5c7921ed7bf5e035dbf2f7ff81367b81e372c                         perl-5.26.2.tar.xz
+sha256 0f8c0fb1b0db4681adb75c3ba0dd77a0472b1b359b9e80efd79fc27b4352132c perl-5.26.2.tar.xz
 
-# Hashes from: http://github.com/arsv/perl-cross/releases/download/1.1.8/perl-cross-1.1.8.hash
-sha256	08e626ed9c419b8a695a8762ff8b41a553023175e4ad67b5e858fc9b4322521c  perl-cross-1.1.8.tar.gz
+# Hashes from: http://github.com/arsv/perl-cross/releases/download/1.1.9/perl-cross-1.1.9.hash
+sha256	0bbb450e48d07e7fdf867d578b1780ac8f0e8dc284d52301dac4d763b42f6041  perl-cross-1.1.9.tar.gz
diff --git a/package/perl/perl.mk b/package/perl/perl.mk
index 58bf3eb6ae..7b4a2710b1 100644
--- a/package/perl/perl.mk
+++ b/package/perl/perl.mk
@@ -6,14 +6,14 @@
 
 # When updating the version here, also update utils/scancpan
 PERL_VERSION_MAJOR = 26
-PERL_VERSION = 5.$(PERL_VERSION_MAJOR).1
+PERL_VERSION = 5.$(PERL_VERSION_MAJOR).2
 PERL_SITE = http://www.cpan.org/src/5.0
 PERL_SOURCE = perl-$(PERL_VERSION).tar.xz
 PERL_LICENSE = Artistic or GPL-1.0+
 PERL_LICENSE_FILES = Artistic Copying README
 PERL_INSTALL_STAGING = YES
 
-PERL_CROSS_VERSION = 1.1.8
+PERL_CROSS_VERSION = 1.1.9
 # DO NOT refactor with the github helper (the result is not the same)
 PERL_CROSS_SITE = https://github.com/arsv/perl-cross/releases/download/$(PERL_CROSS_VERSION)
 PERL_CROSS_SOURCE = perl-cross-$(PERL_CROSS_VERSION).tar.gz
diff --git a/package/php-amqp/Config.in b/package/php-amqp/Config.in
index 0aa2021f5a..dc779f0ee0 100644
--- a/package/php-amqp/Config.in
+++ b/package/php-amqp/Config.in
@@ -2,6 +2,7 @@ config BR2_PACKAGE_PHP_AMQP
 	bool "php-amqp"
 	depends on BR2_PACKAGE_PHP
 	depends on BR2_TOOLCHAIN_HAS_THREADS # rabbitmq-c
+	select BR2_PACKAGE_OPENSSL # rabbitmq-c: amqp_ssl_socket.h
 	select BR2_PACKAGE_RABBITMQ_C
 	help
 	  Communicate with any AMQP compliant server.
diff --git a/package/pkg-generic.mk b/package/pkg-generic.mk
index d635516734..a689dde4d2 100644
--- a/package/pkg-generic.mk
+++ b/package/pkg-generic.mk
@@ -510,6 +510,9 @@ ifeq ($$($(2)_SITE_METHOD),local)
 ifeq ($$($(2)_OVERRIDE_SRCDIR),)
 $(2)_OVERRIDE_SRCDIR = $$($(2)_SITE)
 endif
+ifeq ($$($(2)_OVERRIDE_SRCDIR),)
+$$(error $(1) has local site method, but `$(2)_SITE` is not defined)
+endif
 endif
 
 ifndef $(2)_LICENSE
diff --git a/package/poppler/poppler.mk b/package/poppler/poppler.mk
index 5946cbec24..bad61a6613 100644
--- a/package/poppler/poppler.mk
+++ b/package/poppler/poppler.mk
@@ -14,6 +14,10 @@ POPPLER_INSTALL_STAGING = YES
 POPPLER_CONF_OPTS = --with-font-configuration=fontconfig \
 	--enable-xpdf-headers
 
+ifeq ($(BR2_TOOLCHAIN_HAS_LIBATOMIC),y)
+POPPLER_CONF_ENV += LDFLAGS="$(TARGET_LDFLAGS) -latomic"
+endif
+
 ifeq ($(BR2_PACKAGE_CAIRO),y)
 POPPLER_CONF_OPTS += --enable-cairo-output
 POPPLER_DEPENDENCIES += cairo
diff --git a/package/procps-ng/0001-remove-index.patch b/package/procps-ng/0001-remove-index.patch
deleted file mode 100644
index 1d85b31cb5..0000000000
--- a/package/procps-ng/0001-remove-index.patch
+++ /dev/null
@@ -1,16 +0,0 @@
-sysctl: remove use of legacy index()
-
-[yann.morin.1998@free.fr: adapt to procps-ng]
-Signed-off-by: "Yann E. MORIN" <yann.morin.1998@free.fr>
-diff -durN procps-v3.3.9.orig/sysctl.c procps-v3.3.9/sysctl.c
---- procps-v3.3.9.orig/sysctl.c	2013-12-03 12:16:18.000000000 +0100
-+++ procps-v3.3.9/sysctl.c	2014-05-31 00:45:00.869748741 +0200
-@@ -794,7 +794,7 @@
- 		      program_invocation_short_name);
- 
- 	for ( ; *argv; argv++) {
--		if (WriteMode || index(*argv, '='))
-+		if (WriteMode || strchr(*argv, '='))
- 			ReturnCode += WriteSetting(*argv);
- 		else
- 			ReturnCode += ReadSetting(*argv);
diff --git a/package/procps-ng/0002-use-pkgconfig-for-ncursesw-cflags.patch b/package/procps-ng/0002-use-pkgconfig-for-ncursesw-cflags.patch
deleted file mode 100644
index 1329ac4bbd..0000000000
--- a/package/procps-ng/0002-use-pkgconfig-for-ncursesw-cflags.patch
+++ /dev/null
@@ -1,57 +0,0 @@
-Don't assume ncursesw headers are in ../usr/include/ncursesw/..
-On a pure build/system without legacy ncurses that may not be true.
-Since we're using pkg-config let it provide the correct include path.
-
-Status: contacted one of the maintainers on sf.net
-(ticket submission closed to the public, no other way of contacting them).
-
-Signed-off-by: Gustavo Zacarias <gustavo@zacarias.com.ar>
-[Bernd: Rebased for version 3.3.11]
-
-diff -Nura procps-ng-3.3.10.orig/configure.ac procps-ng-3.3.10/configure.ac
---- procps-ng-3.3.10.orig/configure.ac	2015-04-07 19:21:55.729819952 -0300
-+++ procps-ng-3.3.10/configure.ac	2015-04-07 19:32:09.511706653 -0300
-@@ -138,7 +138,8 @@
-   ])
-   AM_CONDITIONAL(WITH_NCURSES, true)
-   if test "$enable_watch8bit" = yes; then
--    PKG_CHECK_MODULES([NCURSESW], [ncursesw], [WATCH_NCURSES_LIBS="$NCURSESW_LIBS"], [
-+    PKG_CHECK_MODULES([NCURSESW], [ncursesw], [WATCH_NCURSES_LIBS="$NCURSESW_LIBS"]
-+    [WATCH_NCURSES_CFLAGS="$NCURSESW_CFLAGS"], [
-       AC_CHECK_LIB([ncursesw], [addwstr], [WATCH_NCURSES_LIBS=-lncursesw],
-                    [AC_MSG_ERROR([Cannot find ncurses wide library ncursesw with --enable-watch8bit])])
-     ])
-@@ -148,6 +149,7 @@
- fi
- AC_SUBST([NCURSES_LIBS])
- AC_SUBST([WATCH_NCURSES_LIBS])
-+AC_SUBST([WATCH_NCURSES_CFLAGS])
- 
- AC_ARG_WITH([systemd],
-   [AS_HELP_STRING([--with-systemd], [enable systemd support])],
-diff -Nura procps-ng-3.3.10.orig/Makefile.am procps-ng-3.3.10/Makefile.am
---- procps-ng-3.3.10.orig/Makefile.am	2015-04-07 19:21:55.655817434 -0300
-+++ procps-ng-3.3.10/Makefile.am	2015-04-07 19:32:54.516238136 -0300
-@@ -97,6 +97,7 @@
- slabtop_LDADD = $(LDADD) @NCURSES_LIBS@
- watch_SOURCES = watch.c lib/strutils.c lib/fileutils.c
- watch_LDADD = @WATCH_NCURSES_LIBS@ $(CYGWINFLAGS)
-+watch_CFLAGS = @WATCH_NCURSES_CFLAGS@
- top_top_SOURCES = \
- 	top/top.h \
- 	top/top.c \
-diff -Nura procps-ng-3.3.10.orig/watch.c procps-ng-3.3.10/watch.c
---- procps-ng-3.3.10.orig/watch.c	2015-04-07 19:21:55.707819203 -0300
-+++ procps-ng-3.3.10/watch.c	2015-04-07 19:22:27.323895083 -0300
-@@ -51,10 +51,8 @@
- #ifdef WITH_WATCH8BIT
- # include <wchar.h>
- # include <wctype.h>
--# include <ncursesw/ncurses.h>
--#else
--# include <ncurses.h>
- #endif	/* WITH_WATCH8BIT */
-+#include <ncurses.h>
- 
- #ifdef FORCE_8BIT
- # undef isprint
diff --git a/package/procps-ng/0003-ps-output.c-include-dlfcn.h-only-when-necessary.patch b/package/procps-ng/0003-ps-output.c-include-dlfcn.h-only-when-necessary.patch
deleted file mode 100644
index dca28fab14..0000000000
--- a/package/procps-ng/0003-ps-output.c-include-dlfcn.h-only-when-necessary.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From 4fc9a348026a945aec8eddffc7613de9cb10b10c Mon Sep 17 00:00:00 2001
-From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-Date: Sun, 7 Aug 2016 11:08:26 +0200
-Subject: [PATCH] ps/output.c: include <dlfcn.h> only when necessary
-
-dlopen() functionality is only used when SELinux support is enabled, so
-<dlfcn.h> only needs to be included when ENABLE_LIBSELINUX is
-defined. This fixes the build in configurations where <dlfcn.h> is not
-available.
-
-Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
----
- ps/output.c | 2 ++
- 1 file changed, 2 insertions(+)
-
-diff --git a/ps/output.c b/ps/output.c
-index 42c04cf..f540832 100644
---- a/ps/output.c
-+++ b/ps/output.c
-@@ -46,7 +46,9 @@
-  */
- 
- #include <ctype.h>
-+#if ENABLE_LIBSELINUX
- #include <dlfcn.h>
-+#endif
- #include <fcntl.h>
- #include <grp.h>
- #include <limits.h>
--- 
-2.7.4
-
diff --git a/package/procps-ng/procps-ng.hash b/package/procps-ng/procps-ng.hash
index 62d61727b1..123db992ef 100644
--- a/package/procps-ng/procps-ng.hash
+++ b/package/procps-ng/procps-ng.hash
@@ -1,3 +1,8 @@
 # From http://sourceforge.net/projects/procps-ng/files/Production/
-md5	957e42e8b193490b2111252e4a2b443c	procps-ng-3.3.12.tar.xz
-sha1	82c0745f150f1385ca01fe7d24f05f74e31c94c6	procps-ng-3.3.12.tar.xz
+md5	2b0717a7cb474b3d6dfdeedfbad2eccc	procps-ng-3.3.15.tar.xz
+sha1	2929bc64f0cf7b2db997eef79b7187658e47230d	procps-ng-3.3.15.tar.xz
+# Locally calculated after checking signature
+# http://downloads.sourceforge.net/project/procps-ng/Production/procps-ng-3.3.15.tar.xz.asc
+sha256 10bd744ffcb3de2d591d2f6acf1a54a7ba070fdcc432a855931a5057149f0465  procps-ng-3.3.15.tar.xz
+sha256 8177f97513213526df2cf6184d8ff986c675afb514d4e68a404010521b880643  COPYING
+sha256 681e386e44a19d7d0674b4320272c90e66b6610b741e7e6305f8219c42e85366  COPYING.LIB
diff --git a/package/procps-ng/procps-ng.mk b/package/procps-ng/procps-ng.mk
index 22ebc1a8fd..e1fddea32c 100644
--- a/package/procps-ng/procps-ng.mk
+++ b/package/procps-ng/procps-ng.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-PROCPS_NG_VERSION = 3.3.12
+PROCPS_NG_VERSION = 3.3.15
 PROCPS_NG_SOURCE = procps-ng-$(PROCPS_NG_VERSION).tar.xz
 PROCPS_NG_SITE = http://downloads.sourceforge.net/project/procps-ng/Production
 PROCPS_NG_LICENSE = GPL-2.0+, LGPL-2.0+ (libproc and libps)
@@ -12,9 +12,6 @@ PROCPS_NG_LICENSE_FILES = COPYING COPYING.LIB
 PROCPS_NG_INSTALL_STAGING = YES
 PROCPS_NG_DEPENDENCIES = ncurses host-pkgconf $(TARGET_NLS_DEPENDENCIES)
 PROCPS_NG_CONF_OPTS = LIBS=$(TARGET_NLS_LIBS)
-# For 0002-use-pkgconfig-for-ncursesw-cflags.patch
-PROCPS_NG_AUTORECONF = YES
-PROCPS_NG_GETTEXTIZE = YES
 
 # If both procps-ng and busybox are selected, make certain procps-ng
 # wins the fight over who gets to have their utils actually installed.
@@ -43,6 +40,10 @@ PROCPS_NG_CONF_OPTS += \
 	--enable-watch8bit
 endif
 
+ifeq ($(BR2_USE_WCHAR),)
+PROCPS_NG_CONF_OPTS += CPPFLAGS=-DOFF_XTRAWIDE
+endif
+
 # numa support requires libdl, so explicitly disable it when
 # BR2_STATIC_LIBS=y
 ifeq ($(BR2_STATIC_LIBS),y)
diff --git a/package/python-websockets/0001-Fix-behavior-of-recv-in-the-CLOSING-state.patch b/package/python-websockets/0001-Fix-behavior-of-recv-in-the-CLOSING-state.patch
new file mode 100644
index 0000000000..cb97b36bde
--- /dev/null
+++ b/package/python-websockets/0001-Fix-behavior-of-recv-in-the-CLOSING-state.patch
@@ -0,0 +1,261 @@
+From 402059e4a46a764632eba8a669f5b012f173ee7b Mon Sep 17 00:00:00 2001
+From: Aymeric Augustin <aymeric.augustin@m4x.org>
+Date: Tue, 1 May 2018 17:05:05 +0200
+Subject: [PATCH] Fix behavior of recv() in the CLOSING state.
+
+The behavior wasn't tested correctly: in some test cases, the connection
+had already moved to the CLOSED state, where the close code and reason
+are already known.
+
+Refactor half_close_connection_{local,remote} to allow multiple runs of
+the event loop while remaining in the CLOSING state. Refactor affected
+tests accordingly.
+
+I verified that all tests in the CLOSING state were behaving is intended
+by inserting debug statements in recv/send/ping/pong and running:
+
+$ PYTHONASYNCIODEBUG=1 python -m unittest -v websockets.test_protocol.{Client,Server}Tests.test_{recv,send,ping,pong}_on_closing_connection_{local,remote}
+
+Fix #317, #327, #350, #357.
+
+Signed-off-by: Joseph Kogut <joseph.kogut@gmail.com>
+---
+ websockets/protocol.py      | 10 ++---
+ websockets/test_protocol.py | 78 +++++++++++++++++++++++++++++--------
+ 2 files changed, 66 insertions(+), 22 deletions(-)
+
+diff --git a/websockets/protocol.py b/websockets/protocol.py
+index f8121a1..7583fe9 100644
+--- a/websockets/protocol.py
++++ b/websockets/protocol.py
+@@ -303,7 +303,7 @@ class WebSocketCommonProtocol(asyncio.StreamReaderProtocol):
+         # Don't yield from self.ensure_open() here because messages could be
+         # received before the closing frame even if the connection is closing.
+ 
+-        # Wait for a message until the connection is closed
++        # Wait for a message until the connection is closed.
+         next_message = asyncio_ensure_future(
+             self.messages.get(), loop=self.loop)
+         try:
+@@ -315,15 +315,15 @@ class WebSocketCommonProtocol(asyncio.StreamReaderProtocol):
+             next_message.cancel()
+             raise
+ 
+-        # Now there's no need to yield from self.ensure_open(). Either a
+-        # message was received or the connection was closed.
+-
+         if next_message in done:
+             return next_message.result()
+         else:
+             next_message.cancel()
+             if not self.legacy_recv:
+-                raise ConnectionClosed(self.close_code, self.close_reason)
++                assert self.state in [State.CLOSING, State.CLOSED]
++                # Wait until the connection is closed to raise
++                # ConnectionClosed with the correct code and reason.
++                yield from self.ensure_open()
+ 
+     @asyncio.coroutine
+     def send(self, data):
+diff --git a/websockets/test_protocol.py b/websockets/test_protocol.py
+index 70348fb..bfd4e3b 100644
+--- a/websockets/test_protocol.py
++++ b/websockets/test_protocol.py
+@@ -105,7 +105,7 @@ class CommonTests:
+         self.loop.call_soon(self.loop.stop)
+         self.loop.run_forever()
+ 
+-    def make_drain_slow(self, delay=3 * MS):
++    def make_drain_slow(self, delay=MS):
+         # Process connection_made in order to initialize self.protocol.writer.
+         self.run_loop_once()
+ 
+@@ -174,6 +174,8 @@ class CommonTests:
+         # Empty the outgoing data stream so we can make assertions later on.
+         self.assertOneFrameSent(True, OP_CLOSE, close_frame_data)
+ 
++        assert self.protocol.state is State.CLOSED
++
+     def half_close_connection_local(self, code=1000, reason='close'):
+         """
+         Start a closing handshake but do not complete it.
+@@ -181,31 +183,56 @@ class CommonTests:
+         The main difference with `close_connection` is that the connection is
+         left in the CLOSING state until the event loop runs again.
+ 
++        The current implementation returns a task that must be awaited or
++        cancelled, else asyncio complains about destroying a pending task.
++
+         """
+         close_frame_data = serialize_close(code, reason)
+-        # Trigger the closing handshake from the local side.
+-        self.ensure_future(self.protocol.close(code, reason))
++        # Trigger the closing handshake from the local endpoint.
++        close_task = self.ensure_future(self.protocol.close(code, reason))
+         self.run_loop_once()    # wait_for executes
+         self.run_loop_once()    # write_frame executes
+         # Empty the outgoing data stream so we can make assertions later on.
+         self.assertOneFrameSent(True, OP_CLOSE, close_frame_data)
+-        # Prepare the response to the closing handshake from the remote side.
+-        self.loop.call_soon(
+-            self.receive_frame, Frame(True, OP_CLOSE, close_frame_data))
+-        self.loop.call_soon(self.receive_eof_if_client)
++
++        assert self.protocol.state is State.CLOSING
++
++        # Complete the closing sequence at 1ms intervals so the test can run
++        # at each point even it goes back to the event loop several times.
++        self.loop.call_later(
++            MS, self.receive_frame, Frame(True, OP_CLOSE, close_frame_data))
++        self.loop.call_later(2 * MS, self.receive_eof_if_client)
++
++        # This task must be awaited or cancelled by the caller.
++        return close_task
+ 
+     def half_close_connection_remote(self, code=1000, reason='close'):
+         """
+-        Receive a closing handshake.
++        Receive a closing handshake but do not complete it.
+ 
+         The main difference with `close_connection` is that the connection is
+         left in the CLOSING state until the event loop runs again.
+ 
+         """
++        # On the server side, websockets completes the closing handshake and
++        # closes the TCP connection immediately. Yield to the event loop after
++        # sending the close frame to run the test while the connection is in
++        # the CLOSING state.
++        if not self.protocol.is_client:
++            self.make_drain_slow()
++
+         close_frame_data = serialize_close(code, reason)
+-        # Trigger the closing handshake from the remote side.
++        # Trigger the closing handshake from the remote endpoint.
+         self.receive_frame(Frame(True, OP_CLOSE, close_frame_data))
+-        self.receive_eof_if_client()
++        self.run_loop_once()    # read_frame executes
++        # Empty the outgoing data stream so we can make assertions later on.
++        self.assertOneFrameSent(True, OP_CLOSE, close_frame_data)
++
++        assert self.protocol.state is State.CLOSING
++
++        # Complete the closing sequence at 1ms intervals so the test can run
++        # at each point even it goes back to the event loop several times.
++        self.loop.call_later(2 * MS, self.receive_eof_if_client)
+ 
+     def process_invalid_frames(self):
+         """
+@@ -335,11 +362,13 @@ class CommonTests:
+         self.assertEqual(data, b'tea')
+ 
+     def test_recv_on_closing_connection_local(self):
+-        self.half_close_connection_local()
++        close_task = self.half_close_connection_local()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.recv())
+ 
++        self.loop.run_until_complete(close_task)    # cleanup
++
+     def test_recv_on_closing_connection_remote(self):
+         self.half_close_connection_remote()
+ 
+@@ -421,24 +450,29 @@ class CommonTests:
+         self.assertNoFrameSent()
+ 
+     def test_send_on_closing_connection_local(self):
+-        self.half_close_connection_local()
++        close_task = self.half_close_connection_local()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.send('foobar'))
++
+         self.assertNoFrameSent()
+ 
++        self.loop.run_until_complete(close_task)    # cleanup
++
+     def test_send_on_closing_connection_remote(self):
+         self.half_close_connection_remote()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.send('foobar'))
+-        self.assertOneFrameSent(True, OP_CLOSE, serialize_close(1000, 'close'))
++
++        self.assertNoFrameSent()
+ 
+     def test_send_on_closed_connection(self):
+         self.close_connection()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.send('foobar'))
++
+         self.assertNoFrameSent()
+ 
+     # Test the ping coroutine.
+@@ -466,24 +500,29 @@ class CommonTests:
+         self.assertNoFrameSent()
+ 
+     def test_ping_on_closing_connection_local(self):
+-        self.half_close_connection_local()
++        close_task = self.half_close_connection_local()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.ping())
++
+         self.assertNoFrameSent()
+ 
++        self.loop.run_until_complete(close_task)    # cleanup
++
+     def test_ping_on_closing_connection_remote(self):
+         self.half_close_connection_remote()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.ping())
+-        self.assertOneFrameSent(True, OP_CLOSE, serialize_close(1000, 'close'))
++
++        self.assertNoFrameSent()
+ 
+     def test_ping_on_closed_connection(self):
+         self.close_connection()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.ping())
++
+         self.assertNoFrameSent()
+ 
+     # Test the pong coroutine.
+@@ -506,24 +545,29 @@ class CommonTests:
+         self.assertNoFrameSent()
+ 
+     def test_pong_on_closing_connection_local(self):
+-        self.half_close_connection_local()
++        close_task = self.half_close_connection_local()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.pong())
++
+         self.assertNoFrameSent()
+ 
++        self.loop.run_until_complete(close_task)    # cleanup
++
+     def test_pong_on_closing_connection_remote(self):
+         self.half_close_connection_remote()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.pong())
+-        self.assertOneFrameSent(True, OP_CLOSE, serialize_close(1000, 'close'))
++
++        self.assertNoFrameSent()
+ 
+     def test_pong_on_closed_connection(self):
+         self.close_connection()
+ 
+         with self.assertRaises(ConnectionClosed):
+             self.loop.run_until_complete(self.protocol.pong())
++
+         self.assertNoFrameSent()
+ 
+     # Test the protocol's logic for acknowledging pings with pongs.
+-- 
+2.17.0
+
diff --git a/package/python/0009-Fix-python-config-for-cross-builds.patch b/package/python/0009-Fix-python-config-for-cross-builds.patch
index 44ddbcec6f..761d6d9294 100644
--- a/package/python/0009-Fix-python-config-for-cross-builds.patch
+++ b/package/python/0009-Fix-python-config-for-cross-builds.patch
@@ -12,6 +12,8 @@ doesn't depend on the sysconfig import that usually leads to bad
 data/results.
 
 Signed-off-by: Gustavo Zacarias <gustavo@zacarias.com.ar>
+[Bernd: rebased for Python 2.7.15]
+Signed-off-by: Bernd Kuhls <bernd.kuhls@t-online.de>
 ---
  Makefile.pre.in          |  13 +++---
  Misc/python-config.sh.in | 102 +++++++++++++++++++++++++++++++++++++++++++++++
@@ -36,8 +38,8 @@ index 33b994d..beb0837 100644
  
  # Default target
  all:		@DEF_MAKE_ALL_RULE@
--build_all:	$(BUILDPYTHON) oldsharedmods sharedmods gdbhooks
-+build_all:	$(BUILDPYTHON) oldsharedmods sharedmods gdbhooks python-config
+-build_all:	check-clean-src $(BUILDPYTHON) oldsharedmods sharedmods gdbhooks
++build_all:	check-clean-src $(BUILDPYTHON) oldsharedmods sharedmods gdbhooks python-config
  
  # Compile a binary with profile guided optimization.
  profile-opt:
diff --git a/package/python/0035-GCC8-alignment-fix.patch b/package/python/0035-GCC8-alignment-fix.patch
deleted file mode 100644
index b742aa09de..0000000000
--- a/package/python/0035-GCC8-alignment-fix.patch
+++ /dev/null
@@ -1,65 +0,0 @@
-From 0b91f8a668201fc58fa732b8acc496caedfdbae0 Mon Sep 17 00:00:00 2001
-From: Florian Weimer <fw@deneb.enyo.de>
-Date: Sun, 29 Apr 2018 12:18:33 -0700
-Subject: [PATCH] Indicate that _PyGC_Head is only 8-byte aligned. (closes
- bpo-33374)
-
-By spec, the "long double" in _PyGC_Head requires the union to always be 16-byte
-aligned. However, obmalloc only yields 8-byte alignment. Compilers including GCC
-8 are starting to use alignment information to do store-merging. So, the "long
-double" needs to be changed to a simple "double" as was long ago done in Python
-3 by e348c8d154cf6342c79d627ebfe89dfe9de23817. For 2.7, we need to add some
-dummy padding to make sure _PyGC_Head stays the same size.
-
-Upstream: https://bugs.python.org/issue33374
-Signed-off-by: Stefan Becker <chemobejk@gmail.com>
----
- Include/objimpl.h                                       | 17 ++++++++++++++++-
- .../2018-04-29-12-07-00.bpo-33374.-xegL6.rst            |  3 +++
- 2 files changed, 19 insertions(+), 1 deletion(-)
- create mode 100644 Misc/NEWS.d/next/Core and Builtins/2018-04-29-12-07-00.bpo-33374.-xegL6.rst
-
-diff --git a/Include/objimpl.h b/Include/objimpl.h
-index 5f2868332955..cbf6bc3f8763 100644
---- a/Include/objimpl.h
-+++ b/Include/objimpl.h
-@@ -248,6 +248,20 @@ PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
- /* for source compatibility with 2.2 */
- #define _PyObject_GC_Del PyObject_GC_Del
- 
-+/*
-+ * Former over-aligned definition of PyGC_Head, used to compute the size of the
-+ * padding for the new version below.
-+ */
-+union _gc_head;
-+union _gc_head_old {
-+    struct {
-+        union _gc_head_old *gc_next;
-+        union _gc_head_old *gc_prev;
-+        Py_ssize_t gc_refs;
-+    } gc;
-+    long double dummy;
-+};
-+
- /* GC information is stored BEFORE the object structure. */
- typedef union _gc_head {
-     struct {
-@@ -255,7 +269,8 @@ typedef union _gc_head {
-         union _gc_head *gc_prev;
-         Py_ssize_t gc_refs;
-     } gc;
--    long double dummy;  /* force worst-case alignment */
-+    double dummy; /* Force at least 8-byte alignment. */
-+    char dummy_padding[sizeof(union _gc_head_old)];
- } PyGC_Head;
- 
- extern PyGC_Head *_PyGC_generation0;
-diff --git a/Misc/NEWS.d/next/Core and Builtins/2018-04-29-12-07-00.bpo-33374.-xegL6.rst b/Misc/NEWS.d/next/Core and Builtins/2018-04-29-12-07-00.bpo-33374.-xegL6.rst
-new file mode 100644
-index 000000000000..9ec1a605c8f2
---- /dev/null
-+++ b/Misc/NEWS.d/next/Core and Builtins/2018-04-29-12-07-00.bpo-33374.-xegL6.rst	
-@@ -0,0 +1,3 @@
-+Tweak the definition of PyGC_Head, so compilers do not believe it is always
-+16-byte aligned on x86. This prevents crashes with more aggressive
-+optimizations present in GCC 8.
diff --git a/package/python/python.hash b/package/python/python.hash
index 77e0fc878e..feadcfdcb5 100644
--- a/package/python/python.hash
+++ b/package/python/python.hash
@@ -1,6 +1,5 @@
-# From https://www.python.org/downloads/release/python-2714/
-md5 1f6db41ad91d9eb0a6f0c769b8613c5b  Python-2.7.14.tar.xz
+# From https://www.python.org/downloads/release/python-2715/
+md5 a80ae3cc478460b922242f43a1b4094d Python-2.7.15.tar.xz
 # Locally calculated
-sha256 71ffb26e09e78650e424929b2b457b9c912ac216576e6bd9e7d204ed03296a66  Python-2.7.14.tar.xz
-# License files, locally calculated
-sha256 d2d17b17388da74dc9c6bdbf78eb7237432c3f8a0c87852df740ec99de2ec680  LICENSE
+sha256 22d9b1ac5b26135ad2b8c2901a9413537e08749a753356ee913c84dbd2df5574  Python-2.7.15.tar.xz
+sha256 b9a6d9320b8f2693e8d41e496ce56caadacaddcca9be2a64a61749278f425cf2  LICENSE
diff --git a/package/python/python.mk b/package/python/python.mk
index aa7917ab46..79df3c462a 100644
--- a/package/python/python.mk
+++ b/package/python/python.mk
@@ -5,7 +5,7 @@
 ################################################################################
 
 PYTHON_VERSION_MAJOR = 2.7
-PYTHON_VERSION = $(PYTHON_VERSION_MAJOR).14
+PYTHON_VERSION = $(PYTHON_VERSION_MAJOR).15
 PYTHON_SOURCE = Python-$(PYTHON_VERSION).tar.xz
 PYTHON_SITE = https://python.org/ftp/python/$(PYTHON_VERSION)
 PYTHON_LICENSE = Python-2.0, others
diff --git a/package/quota/quota.mk b/package/quota/quota.mk
index 5bd9013d6a..38e18a60c2 100644
--- a/package/quota/quota.mk
+++ b/package/quota/quota.mk
@@ -6,7 +6,7 @@
 
 QUOTA_VERSION = 4.01
 QUOTA_SITE = http://downloads.sourceforge.net/project/linuxquota/quota-tools/$(QUOTA_VERSION)
-QUOTA_DEPENDENCIES = $(TARGET_NLS_DEPENDENCIES)
+QUOTA_DEPENDENCIES = $(TARGET_NLS_DEPENDENCIES) host-nfs-utils
 QUOTA_AUTORECONF = YES
 QUOTA_LICENSE = GPL-2.0+
 QUOTA_CONF_OPTS = --disable-strip-binaries
diff --git a/package/redis/redis.hash b/package/redis/redis.hash
index ce2d66b8c2..d9a14cef6c 100644
--- a/package/redis/redis.hash
+++ b/package/redis/redis.hash
@@ -1,4 +1,4 @@
 # From https://github.com/antirez/redis-hashes/blob/master/README
-sha256 31ae927cab09f90c9ca5954aab7aeecc3bb4da6087d3d12ba0a929ceb54081b5  redis-3.2.11.tar.gz
+sha256 98c4254ae1be4e452aa7884245471501c9aa657993e0318d88f048093e7f88fd  redis-3.2.12.tar.gz
 # Locally calculated
 sha256 cbf420a3672475a6e2765e3c0984c1f81efe0212afb94a3c998ee63bfd661063  COPYING
diff --git a/package/redis/redis.mk b/package/redis/redis.mk
index 82969c9022..cbd2d7bdcb 100644
--- a/package/redis/redis.mk
+++ b/package/redis/redis.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-REDIS_VERSION = 3.2.11
+REDIS_VERSION = 3.2.12
 REDIS_SITE = http://download.redis.io/releases
 REDIS_LICENSE = BSD-3-Clause (core); MIT and BSD family licenses (Bundled components)
 REDIS_LICENSE_FILES = COPYING
diff --git a/package/samba4/samba4.mk b/package/samba4/samba4.mk
index ada03c024f..86df8b896a 100644
--- a/package/samba4/samba4.mk
+++ b/package/samba4/samba4.mk
@@ -11,7 +11,7 @@ SAMBA4_INSTALL_STAGING = YES
 SAMBA4_LICENSE = GPL-3.0+
 SAMBA4_LICENSE_FILES = COPYING
 SAMBA4_DEPENDENCIES = \
-	host-e2fsprogs host-heimdal host-python \
+	host-e2fsprogs host-heimdal host-python host-nfs-utils \
 	e2fsprogs popt python zlib \
 	$(if $(BR2_PACKAGE_LIBAIO),libaio) \
 	$(if $(BR2_PACKAGE_LIBCAP),libcap) \
diff --git a/package/sysvinit/inittab b/package/sysvinit/inittab
index fad91eae8b..a31471031f 100644
--- a/package/sysvinit/inittab
+++ b/package/sysvinit/inittab
@@ -6,10 +6,14 @@ id:3:initdefault:
 
 si0::sysinit:/bin/mount -t proc proc /proc
 si1::sysinit:/bin/mount -o remount,rw /
-si2::sysinit:/bin/mkdir -p /dev/pts
-si3::sysinit:/bin/mkdir -p /dev/shm
-si4::sysinit:/bin/mount -a
-si5::sysinit:/bin/hostname -F /etc/hostname
+si2::sysinit:/bin/mkdir -p /dev/pts /dev/shm
+si3::sysinit:/bin/mount -a
+si4::sysinit:/sbin/swapon -a
+si5::sysinit:/bin/ln -sf /proc/self/fd /dev/fd 2>/dev/null
+si6::sysinit:/bin/ln -sf /proc/self/fd/0 /dev/stdin 2>/dev/null
+si7::sysinit:/bin/ln -sf /proc/self/fd/1 /dev/stdout 2>/dev/null
+si8::sysinit:/bin/ln -sf /proc/self/fd/2 /dev/stderr 2>/dev/null
+si9::sysinit:/bin/hostname -F /etc/hostname
 rcS:12345:wait:/etc/init.d/rcS
 
 # S0:1:respawn:/sbin/getty -L ttyS0 115200 vt100 # GENERIC_SERIAL
diff --git a/package/transmission/Config.in b/package/transmission/Config.in
index 2110e52ac6..dac4d1b330 100644
--- a/package/transmission/Config.in
+++ b/package/transmission/Config.in
@@ -32,11 +32,6 @@ config BR2_PACKAGE_TRANSMISSION_DAEMON
 	help
 	  Install transmission daemon.
 
-config BR2_PACKAGE_TRANSMISSION_REMOTE
-	bool "transmission-remote"
-	help
-	  Install transmission remote management tool.
-
 config BR2_PACKAGE_TRANSMISSION_GTK
 	bool "transmission-gtk"
 	depends on BR2_PACKAGE_LIBGTK3 && BR2_SYSTEM_ENABLE_NLS
diff --git a/package/transmission/S92transmission b/package/transmission/S92transmission
index e5976b0cfb..29d7cd5863 100644
--- a/package/transmission/S92transmission
+++ b/package/transmission/S92transmission
@@ -51,9 +51,6 @@ DAEMON=$(which $NAME)
 PIDFILE=/var/run/$NAME.pid
 SCRIPTNAME=/etc/init.d/$NAME
 
-# Exit if the package is not installed
-[ -x "$DAEMON" ] || exit 0
-
 # Read configuration variable file if it is present
 [ -r /etc/default/$NAME ] && . /etc/default/$NAME
 
diff --git a/package/transmission/transmission.mk b/package/transmission/transmission.mk
index 4e78604fdb..65add0d8c0 100644
--- a/package/transmission/transmission.mk
+++ b/package/transmission/transmission.mk
@@ -16,7 +16,7 @@ TRANSMISSION_DEPENDENCIES = \
 	zlib
 TRANSMISSION_AUTORECONF = YES
 TRANSMISSION_CONF_OPTS = \
-	--disable-libnotify \
+	--without-inotify \
 	--enable-lightweight
 TRANSMISSION_LICENSE = GPL-2.0 or GPL-3.0 with OpenSSL exception
 TRANSMISSION_LICENSE_FILES = COPYING
@@ -49,9 +49,9 @@ TRANSMISSION_CONF_OPTS += --enable-daemon
 
 ifeq ($(BR2_PACKAGE_SYSTEMD),y)
 TRANSMISSION_DEPENDENCIES += systemd
-TRANSMISSION_CONF_OPTS += --with-systemd-daemon
+TRANSMISSION_CONF_OPTS += --with-systemd
 else
-TRANSMISSION_CONF_OPTS += --without-systemd-daemon
+TRANSMISSION_CONF_OPTS += --without-systemd
 endif
 
 define TRANSMISSION_USERS
@@ -75,12 +75,6 @@ else
 TRANSMISSION_CONF_OPTS += --disable-daemon
 endif
 
-ifeq ($(BR2_PACKAGE_TRANSMISSION_REMOTE),y)
-TRANSMISSION_CONF_OPTS += --enable-remote
-else
-TRANSMISSION_CONF_OPTS += --disable-remote
-endif
-
 ifeq ($(BR2_PACKAGE_TRANSMISSION_GTK),y)
 TRANSMISSION_CONF_OPTS += --with-gtk
 TRANSMISSION_DEPENDENCIES += libgtk3
diff --git a/package/triggerhappy/triggerhappy.mk b/package/triggerhappy/triggerhappy.mk
index 9f74c486f1..4c39ab5e5d 100644
--- a/package/triggerhappy/triggerhappy.mk
+++ b/package/triggerhappy/triggerhappy.mk
@@ -8,9 +8,11 @@ TRIGGERHAPPY_VERSION = b822888066129350e51ad79f1cf307fa38dae4f7
 TRIGGERHAPPY_SITE = $(call github,wertarbyte,triggerhappy,$(TRIGGERHAPPY_VERSION))
 TRIGGERHAPPY_LICENSE = GPL-3.0+
 TRIGGERHAPPY_LICENSE_FILES = COPYING
+TRIGGERHAPPY_DEPENDENCIES = host-pkgconf
 
 define TRIGGERHAPPY_BUILD_CMDS
-	$(MAKE) $(TARGET_CONFIGURE_OPTS) -C $(@D) thd th-cmd
+	$(MAKE) $(TARGET_CONFIGURE_OPTS) PKGCONFIG="$(PKG_CONFIG_HOST_BINARY)" \
+		-C $(@D) thd th-cmd
 endef
 
 ifeq ($(BR2_PACKAGE_HAS_UDEV),y)
diff --git a/package/util-linux/0002-lib-randutils-Do-not-block-on-getrandom.patch b/package/util-linux/0002-lib-randutils-Do-not-block-on-getrandom.patch
new file mode 100644
index 0000000000..79fa577c4e
--- /dev/null
+++ b/package/util-linux/0002-lib-randutils-Do-not-block-on-getrandom.patch
@@ -0,0 +1,52 @@
+From a9cf659e0508c1f56813a7d74c64f67bbc962538 Mon Sep 17 00:00:00 2001
+From: Carlo Caione <carlo@endlessm.com>
+Date: Mon, 19 Mar 2018 10:31:07 +0000
+Subject: [PATCH] lib/randutils: Do not block on getrandom()
+
+In Endless we have hit a problem when using 'sfdisk' on the really first
+boot to automatically expand the rootfs partition. On this platform
+'sfdisk' is blocking on getrandom() because not enough random bytes are
+available. This is an ARM platform without a hwrng.
+
+We fix this passing GRND_NONBLOCK to getrandom(). 'sfdisk' will use the
+best entropy it has available and fallback only as necessary.
+
+Signed-off-by: Carlo Caione <carlo@endlessm.com>
+Signed-off-by: Peter Korsgaard <peter@korsgaard.com>
+---
+ lib/randutils.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+diff --git a/lib/randutils.c b/lib/randutils.c
+index e1c4059e1..02c3d9eb0 100644
+--- a/lib/randutils.c
++++ b/lib/randutils.c
+@@ -36,6 +36,8 @@
+ 
+ #if !defined(HAVE_GETRANDOM) && defined(SYS_getrandom)
+ /* libc without function, but we have syscal */
++#define GRND_NONBLOCK 0x01
++#define GRND_RANDOM 0x02
+ static int getrandom(void *buf, size_t buflen, unsigned int flags)
+ {
+ 	return (syscall(SYS_getrandom, buf, buflen, flags));
+@@ -104,13 +106,15 @@ void random_get_bytes(void *buf, size_t nbytes)
+ 		int x;
+ 
+ 		errno = 0;
+-		x = getrandom(cp, n, 0);
++		x = getrandom(cp, n, GRND_NONBLOCK);
+ 		if (x > 0) {			/* success */
+ 		       n -= x;
+ 		       cp += x;
+ 		       lose_counter = 0;
+ 		} else if (errno == ENOSYS)	/* kernel without getrandom() */
+ 			break;
++		else if (errno == EAGAIN)
++			break;
+ 		else if (lose_counter++ > 16)	/* entropy problem? */
+ 			break;
+ 	}
+-- 
+2.11.0
+
diff --git a/package/util-linux/0003-lib-randutils-don-t-break-on-EAGAIN-use-usleep.patch b/package/util-linux/0003-lib-randutils-don-t-break-on-EAGAIN-use-usleep.patch
new file mode 100644
index 0000000000..a48f12fcee
--- /dev/null
+++ b/package/util-linux/0003-lib-randutils-don-t-break-on-EAGAIN-use-usleep.patch
@@ -0,0 +1,71 @@
+From edc1c90cb972fdca1f66be5a8e2b0706bd2a4949 Mon Sep 17 00:00:00 2001
+From: Karel Zak <kzak@redhat.com>
+Date: Tue, 20 Mar 2018 14:17:24 +0100
+Subject: [PATCH] lib/randutils: don't break on EAGAIN, use usleep()
+
+The current code uses lose_counter to make more attempts to read
+random numbers. It seems better to wait a moment between attempts to
+avoid busy loop (we do the same in all-io.h).
+
+The worst case is 1 second delay for all random_get_bytes() on systems
+with uninitialized entropy pool -- for example you call sfdisk (MBR Id
+or GPT UUIDs) on very first boot, etc. In this case it will use libc
+rand() as a fallback solution.
+
+Note that we do not use random numbers for security sensitive things
+like keys or so. It's used for random based UUIDs etc.
+
+Addresses: https://github.com/karelzak/util-linux/pull/603
+Signed-off-by: Karel Zak <kzak@redhat.com>
+Signed-off-by: Peter Korsgaard <peter@korsgaard.com>
+---
+ lib/randutils.c | 17 ++++++++++++-----
+ 1 file changed, 12 insertions(+), 5 deletions(-)
+
+diff --git a/lib/randutils.c b/lib/randutils.c
+index 02c3d9eb0..de4279530 100644
+--- a/lib/randutils.c
++++ b/lib/randutils.c
+@@ -95,6 +95,9 @@ int random_get_fd(void)
+  * Use /dev/urandom if possible, and if not,
+  * use glibc pseudo-random functions.
+  */
++#define UL_RAND_READ_ATTEMPTS	8
++#define UL_RAND_READ_DELAY	125000	/* microseconds */
++
+ void random_get_bytes(void *buf, size_t nbytes)
+ {
+ 	unsigned char *cp = (unsigned char *)buf;
+@@ -111,11 +114,14 @@ void random_get_bytes(void *buf, size_t nbytes)
+ 		       n -= x;
+ 		       cp += x;
+ 		       lose_counter = 0;
+-		} else if (errno == ENOSYS)	/* kernel without getrandom() */
+-			break;
+-		else if (errno == EAGAIN)
++
++		} else if (errno == ENOSYS) {	/* kernel without getrandom() */
+ 			break;
+-		else if (lose_counter++ > 16)	/* entropy problem? */
++
++		} else if (errno == EAGAIN && lose_counter < UL_RAND_READ_ATTEMPTS) {
++			xusleep(UL_RAND_READ_DELAY);	/* no etropy, wait and try again */
++			lose_counter++;
++		} else
+ 			break;
+ 	}
+ 
+@@ -134,8 +140,9 @@ void random_get_bytes(void *buf, size_t nbytes)
+ 			while (n > 0) {
+ 				ssize_t x = read(fd, cp, n);
+ 				if (x <= 0) {
+-					if (lose_counter++ > 16)
++					if (lose_counter++ > UL_RAND_READ_ATTEMPTS)
+ 						break;
++					xusleep(UL_RAND_READ_DELAY);
+ 					continue;
+ 				}
+ 				n -= x;
+-- 
+2.11.0
+
diff --git a/package/wavpack/0005-issue-30-issue-31-issue-32-no-multiple-format-chunks.patch b/package/wavpack/0005-issue-30-issue-31-issue-32-no-multiple-format-chunks.patch
new file mode 100644
index 0000000000..f837a0e966
--- /dev/null
+++ b/package/wavpack/0005-issue-30-issue-31-issue-32-no-multiple-format-chunks.patch
@@ -0,0 +1,64 @@
+From 26cb47f99d481ad9b93eeff80d26e6b63bbd7e15 Mon Sep 17 00:00:00 2001
+From: David Bryant <david@wavpack.com>
+Date: Tue, 24 Apr 2018 22:18:07 -0700
+Subject: [PATCH] issue #30 issue #31 issue #32: no multiple format chunks in
+ WAV or W64
+
+Signed-off-by: Peter Korsgaard <peter@korsgaard.com>
+---
+ cli/riff.c   | 7 ++++++-
+ cli/wave64.c | 6 ++++++
+ 2 files changed, 12 insertions(+), 1 deletion(-)
+
+diff --git a/cli/riff.c b/cli/riff.c
+index 7bddf63..5d6452e 100644
+--- a/cli/riff.c
++++ b/cli/riff.c
+@@ -53,7 +53,7 @@ extern int debug_logging_mode;
+ 
+ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
+ {
+-    int is_rf64 = !strncmp (fourcc, "RF64", 4), got_ds64 = 0;
++    int is_rf64 = !strncmp (fourcc, "RF64", 4), got_ds64 = 0, format_chunk = 0;
+     int64_t total_samples = 0, infilesize;
+     RiffChunkHeader riff_chunk_header;
+     ChunkHeader chunk_header;
+@@ -140,6 +140,11 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
+         else if (!strncmp (chunk_header.ckID, "fmt ", 4)) {     // if it's the format chunk, we want to get some info out of there and
+             int supported = TRUE, format;                        // make sure it's a .wav file we can handle
+ 
++            if (format_chunk++) {
++                error_line ("%s is not a valid .WAV file!", infilename);
++                return WAVPACK_SOFT_ERROR;
++            }
++
+             if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
+                 !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||
+                 bcount != chunk_header.ckSize) {
+diff --git a/cli/wave64.c b/cli/wave64.c
+index fa928a0..0388dc7 100644
+--- a/cli/wave64.c
++++ b/cli/wave64.c
+@@ -53,6 +53,7 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
+     Wave64ChunkHeader chunk_header;
+     Wave64FileHeader filehdr;
+     WaveHeader WaveHeader;
++    int format_chunk = 0;
+     uint32_t bcount;
+ 
+     infilesize = DoGetFileSize (infile);
+@@ -104,6 +105,11 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
+         if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
+             int supported = TRUE, format;
+ 
++            if (format_chunk++) {
++                error_line ("%s is not a valid .W64 file!", infilename);
++                return WAVPACK_SOFT_ERROR;
++            }
++
+             chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;
+ 
+             if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
+-- 
+2.11.0
+
diff --git a/package/wavpack/0006-issue-33-sanitize-size-of-unknown-chunks-before-mall.patch b/package/wavpack/0006-issue-33-sanitize-size-of-unknown-chunks-before-mall.patch
new file mode 100644
index 0000000000..76ebce66d6
--- /dev/null
+++ b/package/wavpack/0006-issue-33-sanitize-size-of-unknown-chunks-before-mall.patch
@@ -0,0 +1,75 @@
+From 6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d Mon Sep 17 00:00:00 2001
+From: David Bryant <david@wavpack.com>
+Date: Tue, 24 Apr 2018 17:27:01 -0700
+Subject: [PATCH] issue #33, sanitize size of unknown chunks before malloc()
+
+Signed-off-by: Peter Korsgaard <peter@korsgaard.com>
+---
+ cli/dsdiff.c | 9 ++++++++-
+ cli/riff.c   | 9 ++++++++-
+ cli/wave64.c | 9 ++++++++-
+ 3 files changed, 24 insertions(+), 3 deletions(-)
+
+diff --git a/cli/dsdiff.c b/cli/dsdiff.c
+index c016df9..fa56bbb 100644
+--- a/cli/dsdiff.c
++++ b/cli/dsdiff.c
+@@ -279,7 +279,14 @@ int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
+         else {          // just copy unknown chunks to output file
+ 
+             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
+-            char *buff = malloc (bytes_to_copy);
++            char *buff;
++
++            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
++                error_line ("%s is not a valid .DFF file!", infilename);
++                return WAVPACK_SOFT_ERROR;
++            }
++
++            buff = malloc (bytes_to_copy);
+ 
+             if (debug_logging_mode)
+                 error_line ("extra unknown chunk \"%c%c%c%c\" of %d bytes",
+diff --git a/cli/riff.c b/cli/riff.c
+index de98c1e..7bddf63 100644
+--- a/cli/riff.c
++++ b/cli/riff.c
+@@ -286,7 +286,14 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
+         else {          // just copy unknown chunks to output file
+ 
+             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
+-            char *buff = malloc (bytes_to_copy);
++            char *buff;
++
++            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
++                error_line ("%s is not a valid .WAV file!", infilename);
++                return WAVPACK_SOFT_ERROR;
++            }
++
++            buff = malloc (bytes_to_copy);
+ 
+             if (debug_logging_mode)
+                 error_line ("extra unknown chunk \"%c%c%c%c\" of %d bytes",
+diff --git a/cli/wave64.c b/cli/wave64.c
+index 591d640..fa928a0 100644
+--- a/cli/wave64.c
++++ b/cli/wave64.c
+@@ -241,7 +241,14 @@ int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
+         }
+         else {          // just copy unknown chunks to output file
+             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
+-            char *buff = malloc (bytes_to_copy);
++            char *buff;
++
++            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
++                error_line ("%s is not a valid .W64 file!", infilename);
++                return WAVPACK_SOFT_ERROR;
++            }
++
++            buff = malloc (bytes_to_copy);
+ 
+             if (debug_logging_mode)
+                 error_line ("extra unknown chunk \"%c%c%c%c\" of %d bytes",
+-- 
+2.11.0
+
diff --git a/package/wget/wget.hash b/package/wget/wget.hash
index 0048557946..eee4a5194e 100644
--- a/package/wget/wget.hash
+++ b/package/wget/wget.hash
@@ -1,4 +1,5 @@
 # Locally calculated after checking pgp signature
-sha256 d59a745ad2c522970660bb30d38601f9457b151b322e01fa20a5a0da0f55df07  wget-1.19.2.tar.lz
+# https://ftp.gnu.org/gnu/wget/wget-1.19.5.tar.lz.sig
+sha256 29fbe6f3d5408430c572a63fe32bd43d5860f32691173dfd84edc06869edca75  wget-1.19.5.tar.lz
 # Locally calculated
-sha256 8ceb4b9ee5adedde47b31e975c1d90c73ad27b6b165a1dcd80c7c545eb65b903  COPYING
+sha256 e79e9c8a0c85d735ff98185918ec94ed7d175efc377012787aebcf3b80f0d90b  COPYING
diff --git a/package/wget/wget.mk b/package/wget/wget.mk
index 3fee8e1b0c..72a73cce79 100644
--- a/package/wget/wget.mk
+++ b/package/wget/wget.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-WGET_VERSION = 1.19.2
+WGET_VERSION = 1.19.5
 WGET_SOURCE = wget-$(WGET_VERSION).tar.lz
 WGET_SITE = $(BR2_GNU_MIRROR)/wget
 WGET_DEPENDENCIES = host-pkgconf
diff --git a/package/wireshark/wireshark.hash b/package/wireshark/wireshark.hash
index 2b44cc0757..4b9c646fa9 100644
--- a/package/wireshark/wireshark.hash
+++ b/package/wireshark/wireshark.hash
@@ -1,4 +1,4 @@
-# From: https://www.wireshark.org/download/src/all-versions/SIGNATURES-2.2.14.txt
-sha256 e7a3d4f9bbde20ea5ee09103f9f6dba38e3666dfe1d6a6a1c004602b5fac378b  wireshark-2.2.14.tar.bz2
+# From: https://www.wireshark.org/download/src/all-versions/SIGNATURES-2.2.15.txt
+sha256 d73583e9282d47c42b69fc3a1ac9cafb6047d1305f5027d4cf18e95922d11844  wireshark-2.2.15.tar.bz2
 # Locally calculated
 sha256 7cdbed2b697efaa45576a033f1ac0e73cd045644a91c79bbf41d4a7d81dac7bf  COPYING
diff --git a/package/wireshark/wireshark.mk b/package/wireshark/wireshark.mk
index ad475803b7..c9a4ef202d 100644
--- a/package/wireshark/wireshark.mk
+++ b/package/wireshark/wireshark.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-WIRESHARK_VERSION = 2.2.14
+WIRESHARK_VERSION = 2.2.15
 WIRESHARK_SOURCE = wireshark-$(WIRESHARK_VERSION).tar.bz2
 WIRESHARK_SITE = https://www.wireshark.org/download/src/all-versions
 WIRESHARK_LICENSE = wireshark license
diff --git a/package/xen/0003-memfd-fix-configure-test.patch b/package/xen/0003-memfd-fix-configure-test.patch
new file mode 100644
index 0000000000..95cb49bcf7
--- /dev/null
+++ b/package/xen/0003-memfd-fix-configure-test.patch
@@ -0,0 +1,62 @@
+From 75e5b70e6b5dcc4f2219992d7cffa462aa406af0 Mon Sep 17 00:00:00 2001
+From: Paolo Bonzini <pbonzini@redhat.com>
+Date: Tue, 28 Nov 2017 11:51:27 +0100
+Subject: [PATCH] memfd: fix configure test
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Recent glibc added memfd_create in sys/mman.h.  This conflicts with
+the definition in util/memfd.c:
+
+    /builddir/build/BUILD/qemu-2.11.0-rc1/util/memfd.c:40:12: error: static declaration of memfd_create follows non-static declaration
+
+Fix the configure test, and remove the sys/memfd.h inclusion since the
+file actually does not exist---it is a typo in the memfd_create(2) man
+page.
+
+Cc: Marc-Andr Lureau <marcandre.lureau@redhat.com>
+Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
+Signed-off-by: Baruch Siach <baruch@tkos.co.il>
+[ Changes by AF:
+ - Port the patch to the qemu-xen tree
+]
+Signed-off-by: Alistair Francis <alistair@alistair23.me>
+---
+Upstream status: commit 75e5b70e6b5
+
+ configure    | 2 +-
+ util/memfd.c | 4 +---
+ 2 files changed, 2 insertions(+), 4 deletions(-)
+
+diff --git a/configure b/configure
+index 9c8aa5a98bd4..99ccc1725ace 100755
+--- a/tools/qemu-xen/configure
++++ b/tools/qemu-xen/configure
+@@ -3923,7 +3923,7 @@ fi
+ # check if memfd is supported
+ memfd=no
+ cat > $TMPC << EOF
+-#include <sys/memfd.h>
++#include <sys/mman.h>
+ 
+ int main(void)
+ {
+diff --git a/util/memfd.c b/util/memfd.c
+index 4571d1aba866..412e94a405fc 100644
+--- a/tools/qemu-xen/util/memfd.c
++++ b/tools/qemu-xen/util/memfd.c
+@@ -31,9 +31,7 @@
+ 
+ #include "qemu/memfd.h"
+ 
+-#ifdef CONFIG_MEMFD
+-#include <sys/memfd.h>
+-#elif defined CONFIG_LINUX
++#if defined CONFIG_LINUX && !defined CONFIG_MEMFD
+ #include <sys/syscall.h>
+ #include <asm/unistd.h>
+ 
+-- 
+2.16.2
+
diff --git a/package/xen/xen.hash b/package/xen/xen.hash
index fa4d25bab2..5daebd4d65 100644
--- a/package/xen/xen.hash
+++ b/package/xen/xen.hash
@@ -1,2 +1,3 @@
 # Locally computed
-sha256 0262a7023f8b12bcacfb0b25e69b2a63291f944f7683d54d8f33d4b2ca556844 xen-4.10.0.tar.gz
+sha256 570d654f357d4085accdf752989c1cbc33e2075feac8fcc505d68bdb81b1a0cf xen-4.10.1.tar.gz
+sha256 dba0d79260259c013c52e5d4daeaea564a2fbb9ff7fc6778c377a401ec3898de COPYING
diff --git a/package/xen/xen.mk b/package/xen/xen.mk
index 8ba2b9d5c2..29699cf0f9 100644
--- a/package/xen/xen.mk
+++ b/package/xen/xen.mk
@@ -4,7 +4,7 @@
 #
 ################################################################################
 
-XEN_VERSION = 4.10.0
+XEN_VERSION = 4.10.1
 XEN_SITE = https://downloads.xenproject.org/release/xen/$(XEN_VERSION)
 XEN_LICENSE = GPL-2.0
 XEN_LICENSE_FILES = COPYING
@@ -17,7 +17,9 @@ else ifeq ($(ARCH),arm)
 XEN_ARCH = arm32
 endif
 
-XEN_CONF_OPTS = --disable-ocamltools
+XEN_CONF_OPTS = \
+	--disable-ocamltools \
+	--with-initddir=/etc/init.d
 
 XEN_CONF_ENV = PYTHON=$(HOST_DIR)/bin/python2
 XEN_MAKE_ENV = \
diff --git a/package/zmqpp/zmqpp.mk b/package/zmqpp/zmqpp.mk
index f576527463..e57f7de4ea 100644
--- a/package/zmqpp/zmqpp.mk
+++ b/package/zmqpp/zmqpp.mk
@@ -12,6 +12,15 @@ ZMQPP_LICENSE = MPL-2.0
 ZMQPP_LICENSE_FILES = LICENSE
 ZMQPP_MAKE_OPTS = LD="$(TARGET_CXX)" BUILD_PATH=./build PREFIX=/usr
 ZMQPP_LDFLAGS = $(TARGET_LDFLAGS) -lpthread
+ZMQPP_CONFIG = $(if $(BR2_ENABLE_DEBUG),debug,release)
+
+# gcc bug internal compiler error: in merge_overlapping_regs, at
+# regrename.c:304. This bug is fixed since gcc 6.
+# By setting CONFIG to empty, all optimizations such as -funroll-loops
+# -ffast-math -finline-functions -fomit-frame-pointer are disabled
+ifeq ($(BR2_or1k):$(BR2_TOOLCHAIN_GCC_AT_LEAST_6),y:)
+ZMQPP_CONFIG =
+endif
 
 ifeq ($(BR2_TOOLCHAIN_HAS_LIBATOMIC),y)
 ZMQPP_LDFLAGS += -latomic
@@ -31,7 +40,7 @@ endif
 
 define ZMQPP_BUILD_CMDS
 	$(TARGET_MAKE_ENV) $(MAKE) $(TARGET_CONFIGURE_OPTS) \
-		LDFLAGS="$(ZMQPP_LDFLAGS)" \
+		CONFIG=$(ZMQPP_CONFIG) LDFLAGS="$(ZMQPP_LDFLAGS)" \
 		$(ZMQPP_MAKE_OPTS) $(if $(BR2_PACKAGE_ZMQPP_CLIENT),client,library) -C $(@D)
 endef
 
diff --git a/support/dependencies/dependencies.sh b/support/dependencies/dependencies.sh
index 985b1d863b..f98678973b 100755
--- a/support/dependencies/dependencies.sh
+++ b/support/dependencies/dependencies.sh
@@ -11,27 +11,30 @@ if test $? != 0 ; then
 	exit 1
 fi
 
-# sanity check for CWD in LD_LIBRARY_PATH
-# try not to rely on egrep..
-if test -n "$LD_LIBRARY_PATH" ; then
-	echo TRiGGER_start"$LD_LIBRARY_PATH"TRiGGER_end | grep '::' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$LD_LIBRARY_PATH"TRiGGER_end | grep ':\.:' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$LD_LIBRARY_PATH"TRiGGER_end | grep 'TRiGGER_start:' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$LD_LIBRARY_PATH"TRiGGER_end | grep 'TRiGGER_start\.:' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$LD_LIBRARY_PATH"TRiGGER_end | grep ':TRiGGER_end' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$LD_LIBRARY_PATH"TRiGGER_end | grep ':\.TRiGGER_end' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$LD_LIBRARY_PATH"TRiGGER_end | grep 'TRiGGER_start\.TRiGGER_end' >/dev/null 2>&1
-	if test $? = 0; then
-		echo
-		echo "You seem to have the current working directory in your"
-		echo "LD_LIBRARY_PATH environment variable. This doesn't work."
-		exit 1;
-	fi
-fi;
+# Sanity check for CWD in LD_LIBRARY_PATH
+case ":${LD_LIBRARY_PATH:-unset}:" in
+(*::*|*:.:*)
+	echo
+	echo "You seem to have the current working directory in your"
+	echo "LD_LIBRARY_PATH environment variable. This doesn't work."
+	exit 1
+	;;
+esac
 
-# PATH should not contain a newline, otherwise it fails in spectacular ways
-# as soon as PATH is referenced in a package rule
-case "${PATH}" in
+# Sanity check for CWD in PATH. Having the current working directory
+# in the PATH makes various packages (e.g. toolchain, coreutils...)
+# build process break.
+# PATH should not contain a newline, otherwise it fails in spectacular
+# ways as soon as PATH is referenced in a package rule
+# An empty PATH is technically possible, but in practice we would not
+# even arrive here if that was the case.
+case ":${PATH:-unset}:" in
+(*::*|*:.:*)
+	echo
+	echo "You seem to have the current working directory in your"
+	echo "PATH environment variable. This doesn't work."
+	exit 1
+	;;
 (*"
 "*)	printf "\n"
 	# Break the '\n' sequence, or a \n is printed (which is not what we want).
@@ -41,22 +44,6 @@ case "${PATH}" in
 	;;
 esac
 
-# sanity check for CWD in PATH. Having the current working directory
-# in the PATH makes the toolchain build process break.
-# try not to rely on egrep..
-if test -n "$PATH" ; then
-	echo TRiGGER_start"$PATH"TRiGGER_end | grep ':\.:' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$PATH"TRiGGER_end | grep 'TRiGGER_start\.:' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$PATH"TRiGGER_end | grep ':\.TRiGGER_end' >/dev/null 2>&1 ||
-	echo TRiGGER_start"$PATH"TRiGGER_end | grep 'TRiGGER_start\.TRiGGER_end' >/dev/null 2>&1
-	if test $? = 0; then
-		echo
-		echo "You seem to have the current working directory in your"
-		echo "PATH environment variable. This doesn't work."
-		exit 1;
-	fi
-fi;
-
 if test -n "$PERL_MM_OPT" ; then
 	echo
 	echo "You have PERL_MM_OPT defined because Perl local::lib"
diff --git a/system/skeleton/etc/profile b/system/skeleton/etc/profile
index 3a97427fdf..1255d23ff4 100644
--- a/system/skeleton/etc/profile
+++ b/system/skeleton/etc/profile
@@ -8,7 +8,7 @@ if [ "$PS1" ]; then
 	fi
 fi
 
-export PAGER='/bin/more '
+export PAGER='/bin/more'
 export EDITOR='/bin/vi'
 
 # Source configuration files from /etc/profile.d
@@ -16,5 +16,5 @@ for i in /etc/profile.d/*.sh ; do
 	if [ -r "$i" ]; then
 		. $i
 	fi
-	unset i
 done
+unset i
diff --git a/toolchain/toolchain-buildroot/Config.in b/toolchain/toolchain-buildroot/Config.in
index 9668f8d41a..3f576297aa 100644
--- a/toolchain/toolchain-buildroot/Config.in
+++ b/toolchain/toolchain-buildroot/Config.in
@@ -22,7 +22,7 @@ config BR2_TOOLCHAIN_BUILDROOT_VENDOR
 
 choice
 	prompt "C library"
-	default BR2_TOOLCHAIN_UCLIBC
+	default BR2_TOOLCHAIN_BUILDROOT_UCLIBC
 	default BR2_TOOLCHAIN_BUILDROOT_GLIBC if BR2_powerpc64
 
 config BR2_TOOLCHAIN_BUILDROOT_UCLIBC
